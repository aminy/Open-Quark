<?xml version="1.0" encoding="UTF-8"?>
<!--
Copyright (c) 2006 BUSINESS OBJECTS SOFTWARE LIMITED
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.
 
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
 
    * Neither the name of Business Objects nor the names of its contributors
      may be used to endorse or promote products derived from this software
      without specific prior written permission.
 
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-->
<!--
    GemCutterManual.xml
    Creation date: Nov 22, 2006.
    By: Neil Corkum
-->
<!DOCTYPE book [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
<!ENTITY euro "&#8364;">
<!ENTITY % dbcent PUBLIC "-//OASIS//ENTITIES DocBook Character Entities V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/dbcentx.mod">
%dbcent;

<!ENTITY legal SYSTEM "LegalNotice.xml">
<!ENTITY jfit SYSTEM "UsingJFitInGemCutter.xml">
]>
<book version="5.0" xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xi="http://www.w3.org/2001/XInclude"
      xmlns:svg="http://www.w3.org/2000/svg"
      xmlns:mml="http://www.w3.org/1998/Math/MathML"
      xmlns:html="http://www.w3.org/1999/xhtml"
      xmlns:db="http://docbook.org/ns/docbook">
  <title>Business Objects Gem Cutter Manual</title>

  <info>
    <releaseinfo>Last modified: December 19, 2006</releaseinfo>

    <authorgroup>
      <author>
        <personname>Luke Evans</personname>
      </author>

      <author>
        <personname>Neil Corkum</personname>
      </author>
    </authorgroup>

    &legal;
  </info>

  <preface xml:id="Welcome">
    <title>Welcome</title>

    <para>Welcome to Business Objects <firstterm
    baseform="Gem">Gems</firstterm>. Business Objects Gems are a new way of
    describing your data and business logic. They are designed to make
    creating the data access and analysis components of your application
    remarkably easy, and their component nature allows for publishing
    libraries of Gems for use across multiple applications.</para>

    <para>Business Objects Gems are powerful components which hide most of the
    details about the originating data and analytic algorithms which get value
    from it. They can be used singularly or combined together powerfully, to
    create abstractions which can describe data filtering, consolidation or a
    full-blown business model.</para>

    <para>Out of the box, you will already have a very powerful suite of Gems
    which can be applied straight away to data. These libraries can be used to
    explore the data with our Gem enabled tools. However, you will normally
    have reason to refine your business logic by deriving new Gems from the
    default set, and you can do this easily by using the <firstterm
    baseform="Gem Cutter"><application class="software">Business Objects Gem
    Cutter</application></firstterm>.</para>

    <para>The Business Objects Gem Cutter is the design tool for Gems,
    providing all the tools you need to experiment, build new Gems and test
    them with real data.</para>

    <para>The design emphasis of the Gem Cutter was to create an environment
    in which the developer can develop business logic much more organically
    than traditional approaches. You are encouraged to try things out and to
    learn by experimentation and discovery. The Gem Cutter will only allow the
    creation of 'legal' Gems which at least have a meaningful relationship to
    the data and to each other. The environment promotes a Rapid Application
    Development approach to business logic and we think you'll find it an
    extremely productive way to develop your application's data manipulation
    logic.</para>
  </preface>

  <chapter xml:id="AnatomyOfAGem">
    <title>The Anatomy of a Gem</title>

    <section xml:id="Gems">
      <title>Gems</title>

      <para>We'll start by talking about what a <firstterm>Gem</firstterm>
      actually is and what benefits they provide.</para>

      <para>A Gem is simply a function. A function is a mathematical concept
      that takes one set and 'maps' it onto another set. Simply put, this
      means that a Gem takes an input and produces an output. Functions are
      nothing new in computing of course, and almost every language has some
      sort of function concept. However, in the Business Objects Gems
      framework, everything is a function (even the data!). This keeps
      everything extremely simple and well-ordered.</para>

      <para>At the point of consumption in compatible tools, a Gem is simply a
      named function which can be applied to data, can define the content of a
      field, or can be executed to perform some transformation to the data.
      Doing this simply involves picking the Gem from a browser or using the
      Intellicut feature (see <xref linkend="GettingHelpDefiningANewGem" />)
      to find and apply a Gem for the correct function.</para>

      <para>At design-time, the true nature of a Gem is exposed in order to
      permit editing and abstraction. We will begin to introduce the visual
      symbology used in the Gem Cutter as we explain the nature of
      Gems.</para>
    </section>

    <section xml:id="BasicRepresentationOfAGem">
      <title>Basic Representation of a Gem</title>

      <para>We can represent a Gem (a function) graphically, as an object
      which consumes some data and produces a result. A simple example is
      displayed in <xref linkend="FigureEqualsGem" />:</para>

      <figure xml:id="FigureEqualsGem">
        <title><function>equals</function> Gem</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/equalsGem.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>We use a left-to-right reading of the function application, and we
      can see two light pink inputs (with circular connectors) and a red
      output (with an arrow connector). This Gem (called
      <function>equals</function>) takes two inputs and produces a
      result.</para>

      <para>An easy way to get more information on the purpose of a Gem is to
      place your mouse pointer over the Gem and read the tooltip which
      appears. <xref linkend="FigureEqualsGemTooltips" /> gives an
      example.</para>

      <figure xml:id="FigureEqualsGemTooltips">
        <title><function>equals</function> Gem with tooltip displayed</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/equalsGemTooltip.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The tooltip provides us with a brief description of the function
      of the Gem. In the case of the <function>equals</function> Gem, the
      result produced will be <code>True</code> if the input values are equal
      to each other, and <code>False</code> otherwise.</para>

      <para><xref linkend="FigureSinGem" /> shows another Gem, the
      <function>sin</function> Gem.</para>

      <figure xml:id="FigureSinGem">
        <title><function>sin</function> Gem</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/sinGem.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Notice that the colours of the input and output are different on
      the <function>sin</function> Gem from those on the
      <function>equals</function> Gem. This is because colour is used as one
      of the indicators of type. We'll now talk a bit about the concept of
      type.</para>
    </section>

    <section xml:id="DataTypes">
      <title>Data Types</title>

      <para><firstterm>Type</firstterm> is a hugely important concept in Gems.
      Type is the way in which we can check if two Gems are compatible and can
      be meaningfully connected.</para>

      <para>Looking at the two Gems in <xref
      linkend="FigureEqualsSinGems" />:</para>

      <figure xml:id="FigureEqualsSinGems">
        <title><function>equals</function> and <function>sin</function>
        Gems</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/equalsGem.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/sinGem.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Notice that the colours of the Gem inputs and outputs are
      different. Each input and output with the same type will appear as the
      same colour. So, just from looking at these two Gems, it is clear that
      the two inputs to the <function>equals</function> Gem are of the same
      type, while the output is a different type. The input and output of the
      <function>sin</function> Gem are the same type, but this type differs
      from either of the types present on the <function>equals</function>
      Gem.</para>

      <para>Colour is really only a secondary hint about type however. To get
      specific information on a type, you can look up the Gem's reference
      description (which includes notes about its intended behaviour, plus a
      description of types) by right-clicking on the Gem and selecting
      <menuchoice>
          <guimenuitem>View Properties...</guimenuitem>
        </menuchoice> from the popup menu. You can also roll-over the
      connectors with the mouse, which will show you the types, as well as
      some additional information, in a tooltip, such as in <xref
      linkend="FigureOutputTooltipsEqualsSinGems" />:</para>

      <figure xml:id="FigureOutputTooltipsEqualsSinGems">
        <title>Output tooltips for <function>equals</function> and
        <function>sin</function> Gems</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/equalsGemWithOutputTooltip.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/sinGemWithOutputTooltip.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Notice that in this case, bright pink is representing a
      <type>Double</type> (double precision, floating point number) type and
      red is the colour used for a <type>Boolean</type> (boolean value)
      type.</para>

      <para>We can therefore see that the <function>sin</function> Gem will
      take a <type>Double</type> and return a <type>Double</type> (the sine of
      the input value) and the <function>equals</function> Gem will return
      <code>True</code> or <code>False</code> (depending on whether the two
      input values are equal).</para>

      <para>This is fairly straight-forward, and nothing that you wouldn't see
      in a traditional language. At this level, it is easy to see how we can
      arrange for the <application>Gem Cutter</application> to only permit an
      output of a Gem to connect to an input of another Gem if (and only if)
      the types are the same.</para>

      <para>The problem with this 'monomorphic typing' approach is that there
      has to be a Gem with a particular type configuration that performs the
      function required. This would lead to an explosion in the number of Gems
      that would have to be provided in order to cope with the large variety
      of types that are present in real systems. Instead, the type system
      supports what is known as <firstterm
      baseform="Polymorphism">polymorphism</firstterm>. This means we can
      describe Gems whose types will be compatible with a set of other
      types.</para>

      <para><xref linkend="FigureHeadGem" /> is an example of a polymorphic
      Gem:</para>

      <figure xml:id="FigureHeadGem">
        <title><function>head</function> Gem - a polymorphic Gem</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/headGemAllTooltips.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para><xref linkend="FigureHeadGem" /> shows tooltips for the input and
      output, as well as the Gem itself. These seem a little more cryptic than
      the previous examples, but they are still very straightforward. The
      function being shown (<function>head</function>) returns the first item
      in a list. The input is the list, and a <firstterm
      baseform="Type Expression">type expression</firstterm> with square
      brackets denotes a list of something, where the 'something' is shown
      inside the brackets. In this case, we can see that the 'something' is an
      'a'. This seems like a daft name for a type, and in fact it doesn't
      represent a type at all (which would in any case start with an uppercase
      letter). Actually, this is a <firstterm baseform="Type Variable">type
      variable</firstterm> and means 'anything'. Bearing this in mind, we can
      see that the <function>head</function> Gem takes a list of 'anythings'
      and returns an 'anything'. The fact that the same letter is used as the
      type variable tells us that whatever 'a' becomes will be consistent in
      both the input and output. In other words, if we use
      <function>head</function> on a list of double precision numbers
      (denoted: '<type>[Double]</type>'), we would expect the return type to
      be '<type>Double</type>'. The feature of using type variables in the
      type expressions is called <firstterm baseform="Parametric">parametric
      typing</firstterm>.</para>
    </section>

    <section xml:id="GemComposition">
      <title>Gem Composition</title>

      <para>The act of creating a new Gem from a collection of other Gems is
      called 'composition'. To compose a Gem in the Gem Cutter, you simply
      drag the output of a 'source Gem' to an input on a 'destination' Gem.
      Actually, the concepts of source and destination are a little false,
      because what you end up doing is creating a new function whose meaning
      is a perfect combination of the two Gems (i.e. there's no 'first' and
      'second' really).</para>

      <para>Here's what this looks like in the Gem Cutter. We'll be composing
      a function (possibly a new Gem) which will add up the first n elements
      of a list. To do this, we first need a function which can extract the
      first n elements. This happens to exist in the standard library of Gems,
      and is called <function>take</function>. <xref
      linkend="FigureTakeGem" /> shows the <function>take</function>
      Gem:</para>

      <figure xml:id="FigureTakeGem">
        <title><function>take</function> Gem</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/takeGemAllTooltips.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>In words, <function>take</function> requires a list of 'anythings'
      and an <type>Int</type> (integer) representing the number of elements to
      take from the list. It will provide a list of anythings (the list of the
      first n elements).</para>

      <para>We also need a Gem that can sum a list. Again, we find a standard
      library Gem to do this, called <function>sum</function>. Its graphical
      representation is displayed in <xref linkend="FigureSumGem" />:</para>

      <figure xml:id="FigureSumGem">
        <title><function>sum</function> Gem</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/sumGemAllTooltips.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>This Gem takes a list of numbers and returns a number (the
      total).</para>

      <para>We want to compose a function that will take the first elements of
      a list and then sum them, so we know we need to attach the output of
      take into the input of sum. Notice that we can tell this is possible in
      two ways:</para>

      <para>Firstly, the input type of sum is a more specific type of the
      output of take. The type <type>Num a =&gt; [a]</type> (a list of
      ‘anythings’, where ‘anything’ is a number value) is clearly a more
      specific version of <type>[a]</type>, which is the general list of
      'anythings' (see the section <xref
      linkend="UnderstandingTypeExpressions" /> for more information). So we
      can infer that the Gems are connectible in the way we want. Technically,
      we say that the types are <firstterm
      baseform="Unification">unifyable</firstterm>.</para>

      <para>Secondly, we can experiment by trying to connect the Gems in the
      way we want. This is achieved by dragging a link from the output of
      <function>take</function> to the input of <function>sum</function>.
      <xref linkend="FigureTakeConnectingSum" /> shows how it looks in the Gem
      Cutter:</para>

      <figure xml:id="FigureTakeConnectingSum">
        <title><function>take</function> Gem being connected to
        <function>sum</function> Gem</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/takeConnectingToSum.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>A light blue line extends from the light blue output of
      <function>take</function> to the desired input on
      <function>sum</function>. As the mouse nears the input, the cursor will
      change to one of two icons, to indicate either that the connection is
      possible (the types are compatible), or that this connection would be
      illegal. It is impossible to form an illegal connection between two
      Gems.</para>

      <para>In this case, the types are compatible, and when we release the
      mouse button, the connectors involved turn black and a connecting line
      is drawn between the Gems, as shown in <xref
      linkend="FigureTakeConnectingSum" />:</para>

      <figure xml:id="FigureTakeConnectedSum">
        <title><function>take</function> Gem connected to
        <function>sum</function> Gem</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/takeConnectedToSum.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The change to black indicates that the two Gems are now bound. In
      fact, although the distinction between the two Gems is preserved, we
      have created a new function object, and in effect there is no longer a
      concept of an output on <function>take</function> and an input on
      <function>sum</function>. Therefore, there are no types associated with
      these any more, resulting in the black colouration.</para>

      <para>An interesting point to note about the resulting graphical
      representation of the combination we just made is that the second input
      to <function>take</function> has changed colour to indicate that its
      type has changed. In fact it has changed to the same colour as the
      original input of <function>sum</function>. What has happened is that
      <function>take</function> 'realises' that it is required to produce a
      list of numbers as output (by being bound to <function>sum</function>
      which has this as an input requirement). This implies that it, in turn,
      must collect a list of numbers (instead of any list) in order to satisfy
      this requirement. It therefore advertises this fact with a change in its
      input type.</para>

      <para>Another point of note is that a Gem output does not have to be the
      same colour as the input of another Gem for these two Gems to be
      connectible. In the previous example, the output of
      <function>take</function> is light blue, while the input of
      <function>sum</function> is brown. These Gems can still be connected
      because the input to <function>sum</function> is just a more specific
      type than the output of <function>take</function>. An output on one Gem
      coloured the same as the input on another Gem guarantees that these two
      Gem connectors can be connected, but Gem connectors with different
      colours may also be connectible if there is a type compatible with both
      connectors.</para>
    </section>
  </chapter>

  <chapter xml:id="AnatomyOfTheGemCutter">
    <title>The Anatomy of the Gem Cutter</title>

    <para>The Gem Cutter is the design-time environment for creating general
    purpose Gems. The Gem Cutter is designed for large scale development of
    libraries of Gems for general consumption by other tools.</para>

    <para>Note that when using the Gem Cutter to create Gems, you are
    essentially writing CAL code. Gems in the Gem Cutter are graphical
    representations of CAL functions. By default, Gems are saved into the
    <filename>GemCutterSaveModule.cal</filename> file, so looking in this file
    will show you the CAL code written by the Gem Cutter for any Gems you have
    saved here.</para>

    <para>The Gem Cutter is simple in essence, being composed of two main
    sections:</para>

    <para><variablelist>
        <varlistentry>
          <term>The Sidebar</term>

          <listitem>
            <para>This area of the Gem Cutter contains the Gem Browser window,
            as well as windows providing information related to the current
            state of the Table Top. These additional windows, such as the
            Overview and the Argument Tree, can be switched on and off via the
            <guimenu>View</guimenu> menu.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>The Table Top</term>

          <listitem>
            <para>This is where most of the activity is. Here, you will work
            with component Gems, composing them together to form a new
            Gem.</para>
          </listitem>
        </varlistentry>
      </variablelist>There is also a toolbar and a status bar.</para>

    <para><xref linkend="FigureInterfaceOfTheGemCutter" /> shows the main
    features of the Gem Cutter's graphical interface:</para>

    <figure xml:id="FigureInterfaceOfTheGemCutter">
      <title>Interface of the Gem Cutter</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/GemCutterAnatomy.png"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>The specific functions of each piece will be described elsewhere in
    this manual.</para>
  </chapter>

  <chapter xml:id="WhereDoGemsLive">
    <title>Where Do Gems Live?</title>

    <para>Gems are conceptually stored in Vaults which are ultimately some
    form of physical storage mechanism (like a file or database). At this
    time, the Gem Cutter only supports one Vault – the standard vault. All Gem
    definitions are stored in the standard vault, which is simply a location
    in your file system containing CAL files. Each of these CAL files is
    referred to as a <firstterm>Module</firstterm>.</para>

    <section xml:id="ModulesAndWorkspaces">
      <title>Modules and Workspaces</title>

      <para>Modules are a system of organization for Gems. Each CAL file in a
      vault represents one module, and may contain one or more Gem
      definitions.</para>

      <para>To use modules in the Gem Cutter, they must be present in the
      current workspace. A workspace represents the range of Gems being worked
      with at any given time, and contains one or more CAL modules. Together,
      the modules in the workspace contain all the Gems that are currently
      available for use in the Gem Cutter.</para>

      <para>To add a module to the current workspace from the standard vault,
      the <menuchoice>
          <guimenu>Workspace</guimenu>

          <guisubmenu>Add Module</guisubmenu>

          <guimenuitem>From Standard Vault</guimenuitem>
        </menuchoice> menu option should be used. A dialog will then appear,
      allowing you to select which module to add to the workspace. The
      <menuchoice>
          <guimenu>Workspace</guimenu>

          <guisubmenu>Add Module</guisubmenu>

          <guimenuitem>Imported from Local File</guimenuitem>
        </menuchoice> menu option can be used to copy an existing CAL file
      from anywhere on the file system to the standard vault, allowing its use
      as a module in the Gem Cutter. Note that this will only work if the
      module being loaded is not already present in the standard vault.</para>

      <para>To remove a module from the current workspace, use the <menuchoice>
          <guimenu>Workspace</guimenu>

          <guimenuitem>Remove Module</guimenuitem>
        </menuchoice> menu option. This will display a dialog allowing you to
      select the module you would like to remove from the workspace.</para>

      <para>The current module has its name displayed in bright pink text in
      the <firstterm>Gem Browser</firstterm> (see <xref
      linkend="HowDoIFindGems" />). This is the module that any Gems created
      by the user will be saved in. To change the current module, open the
      context menu for the module you would like to be the new current module,
      and select the <menuchoice>
          <guimenuitem>Change to this Module</guimenuitem>
        </menuchoice> option.</para>

      <para>It is also possible to switch between different workspaces. The
      <menuchoice>
          <guimenu>File</guimenu>

          <guimenuitem>Switch Workspace</guimenuitem>
        </menuchoice> menu option will allow you to select a different
      workspace declaration file to load a workspace from. Alternatively, you
      can select one or more modules from the standard vault to form the basis
      of a new workspace. Note that certain modules will be included in the
      workspace if selected modules depend on them. For example, selecting to
      include the <package>Math</package> module will also include the
      <package>Prelude</package> module, because the <package>Math</package>
      module depends on functionality contained in the
      <package>Prelude</package> module.</para>
    </section>

    <section xml:id="HowDoIFindGems">
      <title>How Do I Find Gems? The Gem Browser</title>

      <para>The <firstterm>Gem Browser</firstterm> is a component of the Gem
      Cutter that helps the user easily locate and select Gems. The Gem
      Browser will open the default workspace by default (which includes all
      the primitive Gems and data types), and will allow the user to locate
      and add new modules to its outline view to explore these other Gem
      repositories.</para>

      <para>The Gem Browser is an outline control which displays the modules
      in the workspace. Inside the Drawers are the Gems themselves. Gems which
      display a yellow/orange icon (<guiicon><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/Gem_Yellow.gif"></imagedata>
          </imageobject>
        </inlinemediaobject></guiicon>) and have capitalised names are called
      Data Constructors (constructors for short). Gems which display a red
      icon (<guiicon><inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/Gem_Red.gif"></imagedata>
          </imageobject>
        </inlinemediaobject></guiicon>) are Functions.</para>

      <para><note>
          <para>For more information on Data Constructors, please refer to the
          <filename>CAL User’s Guide</filename> document.</para>
        </note><xref linkend="FigureGemBrowser" /> is a picture of the browser
      with the Prelude module open (where many basic, useful Gems are
      stored):</para>

      <figure xml:id="FigureGemBrowser">
        <title>The Gem Browser</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/gemBrowser.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The Gem Browser allows the user to view the available Gems sorted
      in various ways, in order to facilitate finding Gems for a specific
      purpose. The following orderings are possible:</para>

      <para><variablelist>
          <varlistentry>
            <term>Sort Alphabetically</term>

            <listitem>
              <para>Gems are sorted by name in lexicographical order.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Sort Data Constructors then Functions</term>

            <listitem>
              <para>Gems are sorted by kind (yellow constructors, red
              functions), and then by lexicographical order.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Group by Module</term>

            <listitem>
              <para>Gems are categorised according to their containing
              module.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Group by Arity</term>

            <listitem>
              <para>Gems are categorised into folders by the maximum number of
              arguments they will consume. This is the number of input
              connectors visible on the Gem when it is on the Table
              Top.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Group by Gem Type</term>

            <listitem>
              <para>Gems are categorised into folders according to their type.
              This is useful for finding Gems that use certain kinds of data
              to produce specific kinds of data.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Group by Input Types</term>

            <listitem>
              <para>Gems are categorised into folders according to their input
              types. This is useful for finding Gems that operate on certain
              kinds of data.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Group by Output Type</term>

            <listitem>
              <para>Gems are categorised into folders according to their
              output type. This is useful for finding a Gem which will produce
              a certain kind of data.</para>
            </listitem>
          </varlistentry>
        </variablelist>You can switch between the above views by using the
      context menu on a Gem module in the browser window. The effects of the
      ordering can be performed at the module level, on an existing grouping,
      or at the workspace level. Applying an ordering at the workspace level
      will transcend the module organisation of the Gems and enable you to see
      sorted Gems 'across' several modules. This is very useful when you know
      something about a Gem but can't remember where it is stored.</para>

      <para>To search the workspace, enter a string to search for in the text
      field below the pane containing the workspace tree. All Gems containing
      the string searched for will appear under the <guilabel>Search
      Results</guilabel> tree node in the workspace tree pane.</para>

      <section xml:id="BrowserViewQuickAccessPanel">
        <title>Browser View Quick Access Panel</title>

        <para>For convenience a 'quick access' panel is displayed at the
        bottom of the Browser's outline view in order to quickly switch
        between Gem views at the workspace level. In order to perform sorting
        at the module level, the context menu must be used on the appropriate
        module in the Gem Browser.</para>

        <para>The Quick Access Panel is displayed in <xref
        linkend="FigureQuickAccessPanel" />:</para>

        <figure xml:id="FigureQuickAccessPanel">
          <title>The Quick Access Panel</title>

          <screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="images/GemCutterManual/quickAccessPanel.png"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot>
        </figure>

        <para>From left to right, the buttons in the left section of the panel
        perform:</para>

        <para><simplelist columns="1">
            <member><guibutton><inlinemediaobject>
                <imageobject>
                  <imagedata fileref="images/GemCutterManual/sortAZ.gif"></imagedata>
                </imageobject>
              </inlinemediaobject></guibutton> Sort Alphabetically</member>

            <member><guibutton><inlinemediaobject>
                <imageobject>
                  <imagedata fileref="images/GemCutterManual/sortConstructorsFunctions.gif"></imagedata>
                </imageobject>
              </inlinemediaobject></guibutton> Sort Data Constructors then
            Functions</member>

            <member><guibutton><inlinemediaobject>
                <imageobject>
                  <imagedata fileref="images/GemCutterManual/catByModule.gif"></imagedata>
                </imageobject>
              </inlinemediaobject></guibutton> Group by Module</member>

            <member><guibutton><inlinemediaobject>
                <imageobject>
                  <imagedata fileref="images/GemCutterManual/catByArity.gif"></imagedata>
                </imageobject>
              </inlinemediaobject></guibutton> Group by Arity</member>

            <member><guibutton><inlinemediaobject>
                <imageobject>
                  <imagedata fileref="images/GemCutterManual/catByGemType.gif"></imagedata>
                </imageobject>
              </inlinemediaobject></guibutton> Group by Gem Type</member>

            <member><guibutton><inlinemediaobject>
                <imageobject>
                  <imagedata fileref="images/GemCutterManual/catByInputType.gif"></imagedata>
                </imageobject>
              </inlinemediaobject></guibutton> Group by Input Type</member>

            <member><guibutton><inlinemediaobject>
                <imageobject>
                  <imagedata fileref="images/GemCutterManual/catByOutputType.gif"></imagedata>
                </imageobject>
              </inlinemediaobject></guibutton> Group by Output Type</member>
          </simplelist>The two buttons on the right side of the Quick Access
        Panel are used to show or hide additional information in the Gem
        Browser. These two buttons (from left to right) have the following
        functionality:</para>

        <para><variablelist>
            <varlistentry>
              <term><guibutton><inlinemediaobject>
                  <imageobject>
                    <imagedata fileref="images/GemCutterManual/showTypeExpressions.gif"></imagedata>
                  </imageobject>
                </inlinemediaobject></guibutton> Display Gem Type</term>

              <listitem>
                <para>Displays the type of each Gem next to its name in the
                Gem Browser.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><inlinemediaobject>
                  <imageobject>
                    <imagedata fileref="images/GemCutterManual/showUnimportedGems.gif"></imagedata>
                  </imageobject>
                </inlinemediaobject> Display Gems from Unimported
              Modules</term>

              <listitem>
                <para>Displays Gems from unimported modules as well as those
                from currently imported modules.</para>
              </listitem>
            </varlistentry>
          </variablelist>Gems are generally accessed by dragging and dropping
        the required Gem from the Gem Browser pane into the position in the
        environment where the Gem is required. In the Gem Cutter, Gems can be
        dropped onto the Table Top. Alternatively, the <guibutton>Add Gem
        (<inlinemediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/addNewGem.gif"></imagedata>
            </imageobject>
          </inlinemediaobject>)</guibutton> button on the Toolbar can be
        pressed, followed by clicking on the Table Top and selecting a Gem
        from the menu that appears (see <xref
        linkend="GettingHelpDefiningANewGem" />). When this is done, a
        representation of the Gem is drawn on the Table Top, showing an output
        connector, and any input connectors.</para>
      </section>
    </section>
  </chapter>

  <chapter xml:id="DefiningANewGem">
    <title>Defining a New Gem</title>

    <para>In order to define a new Gem, the components from which the new Gem
    will be assembled must be collected onto the Table Top and composed
    together. As well as using Gems from a Vault, a variety of 'special' Gems
    are available on the toolbar which provide extra functionality. These are
    dealt with later in <xref linkend="SpecialGems" />.</para>

    <para>Gems are composed together to form the required function. Any inputs
    left unbound will automatically be treated as inputs to the newly created
    Gem. Once composition is complete, the new Gem is 'defined' by connecting
    the final output to a target. It is possible to have more Gems on the
    Table Top than are currently composed into a new Gem. Any Gems which are
    not connected into the 'tree' of Gems defined as having its root at the
    target are not considered a part of the new Gem. However, these Gems will
    still be saved as part of the Gem design if the Gem on the Table Top is
    saved.</para>

    <para><xref linkend="FigureNewGem" /> shows an example of a new Gem
    defined in the Gem Cutter:</para>

    <figure xml:id="FigureNewGem">
      <title>A newly defined Gem in the Gem Cutter</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/newGem.png"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>In this example, the <function>add</function> and
    <function>divide</function> Gems from the standard library have been
    composed together to form a new function. The output of this function has
    been connected to a target which identifies this composition as being a
    new Gem. Notice that the <function>subtract</function> Gem is playing no
    part in the <function>add</function>-<function>divide</function>
    composition and is therefore not part of the Gem under
    construction.</para>

    <para>At this point, the user may test the Gem using the green
    <guibutton>Play (<inlinemediaobject>
        <imageobject>
          <imagedata fileref="images/GemCutterManual/play.gif"></imagedata>
        </imageobject>
      </inlinemediaobject>)</guibutton> button in the toolbar, or name the Gem
    and save it to a Vault.</para>

    <para>Sometimes it is necessary to select Gems in order to target them for
    a certain operation. This can be achieved by clicking Gems in the
    following ways:</para>

    <para><itemizedlist>
        <listitem>
          <para>Clicking on a Gem to select it alone. This will deselect
          already selected Gems.</para>
        </listitem>

        <listitem>
          <para>Holding a <keycap function="control">Control</keycap> key and
          clicking on a Gem. This will 'toggle' the selection of the clicked
          Gem, whilst preserving the selection states of other Gems on the
          Table Top.</para>
        </listitem>
      </itemizedlist>You can also select multiple Gems by dragging a
    rectangular outline around a set of Gems on the Table Top. Using this
    technique, selection can be performed in the following ways:</para>

    <para><itemizedlist>
        <listitem>
          <para>Dragging an outline to completely enclose a set of Gems will
          select only these Gems. This will deselect already selected Gems not
          fully enclosed by the rectangular outline. The rectangular outline
          will appear solid.</para>
        </listitem>

        <listitem>
          <para>Holding a <keycap function="shift">Shift</keycap> key and
          dragging an outline around some Gems. This will preserve the
          selection of Gems not enclosed by the outline, and will select Gems
          enclosed by the rectangle.</para>
        </listitem>

        <listitem>
          <para>Holding a <keycap function="control">Control</keycap> key and
          dragging an outline around some Gems. This will preserve the
          selection of Gems not enclosed by the outline, and will 'toggle' the
          selection of Gems enclosed by the rectangle.</para>
        </listitem>
      </itemizedlist>Gems can be deleted from the Table Top by pressing the
    <keycap function="delete">Delete</keycap> key, selecting the <menuchoice>
        <guimenu>Edit</guimenu>

        <guimenuitem>Delete</guimenuitem>
      </menuchoice> menu option, or by choosing the <menuchoice>
        <guimenuitem>Delete Gem(s)</guimenuitem>
      </menuchoice> option from the Gem context menu (by right clicking on a
    Gem).</para>

    <para>To completely clear the Table Top (and start over), you can use the
    <menuchoice>
        <guimenu>File</guimenu>

        <guimenuitem>New</guimenuitem>
      </menuchoice> menu option, or click the <guibutton>New Table Top
    (<inlinemediaobject>
        <imageobject>
          <imagedata fileref="images/GemCutterManual/new.gif"></imagedata>
        </imageobject>
      </inlinemediaobject>)</guibutton> button on the toolbar.</para>

    <para>To tidy the appearance of the layout of Gems on the Table Top,
    select the <menuchoice>
        <guimenu>View</guimenu>

        <guimenuitem>Tidy Table Top</guimenuitem>
      </menuchoice> option from the menu bar, or press <accel>Ctrl+G</accel>.
    If tidying the appearance of only certain Gems is desired, select the Gems
    to be tidied, right-click to open a context menu and select the
    <menuchoice>
        <guimenuitem>Tidy Selection</guimenuitem>
      </menuchoice> option.</para>

    <para>To attempt to fit the Gem layout into a smaller area on the Table
    Top, select the <menuchoice>
        <guimenu>View</guimenu>

        <guimenuitem>Fit Table Top</guimenuitem>
      </menuchoice> option from the menu bar, or press
    <accel>Ctrl+H</accel>.</para>

    <section xml:id="GettingHelpDefiningANewGem">
      <title>Getting Help Defining a New Gem: IntelliCut</title>

      <para>The Gem Cutter has a feature called IntelliCut which will help you
      to build your Gem definitions. IntelliCut can be activated by letting
      the mouse pointer rest over a Gem connector (input or output), by
      accessing the context menu associated with the connector, or by
      selecting the <guibutton>Add Gem (<inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/addNewGem.gif"></imagedata>
          </imageobject>
        </inlinemediaobject>)</guibutton> button on the toolbar and clicking
      on the connector. IntelliCut is designed to provide assistance in
      finding Gems that can legally be connected to the Gem connection the
      mouse is over. It does this in a number of ways:</para>

      <para><itemizedlist>
          <listitem>
            <para>Suggesting connections which can be made to other Gems
            already on the Table Top.</para>
          </listitem>

          <listitem>
            <para>Showing you a list of Gems which can be brought out onto the
            Table Top and connected to the Gem from the modules currently open
            in the Gem Browser.</para>
          </listitem>
        </itemizedlist><xref linkend="FigureIntellicutInAction" /> shows
      IntelliCut in action:</para>

      <figure xml:id="FigureIntellicutInAction">
        <title>IntelliCut in action</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/intellicutInAction.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The user has let the mouse pointer hover over the output of the
      <function>add</function> Gem. IntelliCut responds by showing that legal
      connections can be made to both the inputs of the
      <function>subtract</function> Gem, or to a list of Gems not yet on the
      Table Top. At this point, the user can click on a Gem in the pop-up list
      to load a Gem onto the Table Top and automatically connect it to the
      output of <function>add</function>. Alternatively, the user could click
      on one of the indicated inputs to the <function>subtract</function> Gem
      or <function>result</function> Gem to form a connection to that
      Gem.</para>

      <para>Naturally, IntelliCut understands the type system of Business
      Objects Gems, so it can correctly suggest valid connections which can be
      made between different but compatible types. This is shown in <xref
      linkend="FigureIntellicutSuggestingConnections" />:</para>

      <figure xml:id="FigureIntellicutSuggestingConnections">
        <title>IntelliCut suggesting valid connections between Gems</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/intellicutConnectingTypes.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Here, IntelliCut is showing which Gems on the Table Top can be
      connected to the output of the <function>add</function> Gem. The
      <function>add</function> Gem's output is actually typed as a 'number'
      (type class <type>Num</type> - for information on type classes, see
      <xref linkend="UnderstandingTypeExpressions" />) which includes both
      integers (type <type>Int</type>) and floating point numbers (type
      <type>Double</type>). IntelliCut determines that both the
      <function>isEven</function> Gem (taking <type>Int</type>s) and the
      <function>sin</function> Gem (taking a <type>Double</type>) can both be
      legally connected to the output of <function>add</function>. IntelliCut
      also uses the type colour of the 'destination' type to draw the
      'potential connection' lines to indicate that these connections are
      compatible, but not the same, type.</para>

      <para>In the top right corner of the IntelliCut window, there are three
      buttons which are used to control the Gems that are displayed. These
      buttons have the following functionality:</para>

      <para><variablelist>
          <varlistentry>
            <term><guibutton><inlinemediaobject>
                <imageobject>
                  <imagedata fileref="images/GemCutterManual/Gem_Red.gif"></imagedata>
                </imageobject>
              </inlinemediaobject> Show Best Gems</guibutton></term>

            <listitem>
              <para>This button tells IntelliCut to display only the “best”
              Gems for the current connector. The Gems in this list will
              generally be very close in type to the current connector.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><guibutton><inlinemediaobject>
                <imageobject>
                  <imagedata fileref="images/GemCutterManual/showingGoodGems.gif"></imagedata>
                </imageobject>
              </inlinemediaobject> Show Likely Gems</guibutton></term>

            <listitem>
              <para>This button tells IntelliCut to display Gems that are
              likely to be useful if connected to the current connector. This
              option will always display more Gems than the “Show Best Gems”
              option, but less than the “Show All Gems” option. Note that this
              option may not be present if there are only a small number of
              Gems that are connectible to the current connector.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><guibutton><inlinemediaobject>
                <imageobject>
                  <imagedata fileref="images/GemCutterManual/showAllGems.gif"></imagedata>
                </imageobject>
              </inlinemediaobject> Show All Gems</guibutton></term>

            <listitem>
              <para>This button shows all Gems that are connectible to the
              current connector. No filtering of the list of Gems is
              performed.</para>
            </listitem>
          </varlistentry>
        </variablelist>The behaviour of IntelliCut can be modified using the
      IntelliCut Preference settings available through the <menuchoice>
          <guimenu>View</guimenu>

          <guimenuitem>Preferences</guimenuitem>
        </menuchoice> menu option. The panel shown in <xref
      linkend="FigureIntellicutPreferences" /> allows you to switch IntelliCut
      popup on or off, and to change the activation time period of
      IntelliCut:</para>

      <figure xml:id="FigureIntellicutPreferences">
        <title>IntelliCut Preferences panel</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/intellicutPreferences.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para><guilabel>Enable Pop-up IntelliCut</guilabel> turns on or off the
      automatic operation of IntelliCut features. This will cause IntelliCut
      to operate if the mouse is allowed to hover over connectible Gem
      features (usually inputs and the output). If this is checked (on) then
      the setting of the slider bar represents the number of seconds before
      IntelliCut appears after the mouse pauses over a Gem connectible
      feature. If Pop-up IntelliCut is turned off, then IntelliCut can still
      be manually invoked by right-clicking on a connectible feature.</para>
    </section>
  </chapter>

  <chapter xml:id="TestingANewGem">
    <title>Testing a New Gem</title>

    <para>Once a new Gem has been laid out on the Table Top, the new Gem is
    generally available for testing.</para>

    <para><xref linkend="FigureSampleTestGem" /> is a view of a sample Gem at
    this point, which adds two <type>Double</type>s then raises the result to
    the power of a third <type>Double</type>:</para>

    <figure xml:id="FigureSampleTestGem">
      <title>A sample Gem</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/sampleGemAddPower.png"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>The Gem developer is very likely to want to test the new Gem. In
    cases where the input types are relatively simple, this can be done by
    pressing on the 'play' button.</para>

    <para>In cases where complex data values are expected by the Gem, it may
    be necessary to attach other Gems to the inputs of the Gem under testing
    in order to provide it with test data. The Gem Cutter will indicate if
    this is required by alerting the user with the dialog in <xref
    linkend="FigureCannotExecuteGem" /> when the <guibutton>Play
    (<inlinemediaobject>
        <imageobject>
          <imagedata fileref="images/GemCutterManual/play.gif"></imagedata>
        </imageobject>
      </inlinemediaobject>)</guibutton> button is pressed:</para>

    <figure xml:id="FigureCannotExecuteGem">
      <title>Cannot Execute Gem dialog</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/cannotExecuteGemDialog.png"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>In the case of our simple
    <function>add</function>-<function>power</function> composition, we have
    very simple types, and the Gem Cutter is well able to deal with these.
    When the play button is pressed, the Gem Cutter realises that inputs are
    required in order to test the Gem and displays appropriate value entry
    panels to collect the required data. This is shown in <xref
    linkend="FigureTestingValueEntry" />:</para>

    <figure xml:id="FigureTestingValueEntry">
      <title>Testing a Gem - Value Entry panels</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/testingValuePanels.png"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>The status bar indicates that we are at the 'entry point' of the
    Gem. Notice that the target to be evaluated (in this case,
    <function>result</function>) gains a blue halo around it. Three value
    editors have appeared to collect values of the unbound inputs of the new
    Gem. In each case the required type of the input values is a double
    precision floating point number. To indicate this, the entry panels
    display an icon which hints at the appropriate type and each has a bright
    pink border to further associate them with the type <type>Double</type>.
    The arguments and their values are also displayed in the Arguments pane at
    the left of the screen.</para>

    <para>The user can supply values in each panel for each respective
    argument. All input values are validated by the Gem Cutter to ensure they
    are legal for the required type. Once the right values have been entered,
    the user can run the Gem execution by using the play button. Values can be
    entered in the Arguments pane on the left as well as in the value editor
    panels themselves, if desired.</para>

    <para>All of the built-in primitive types, as well as a number of more
    complex types, have value editors which can collect data for arguments.
    Lists, tuples and records are also supported, and value editors for the
    respective element types are presented accordingly. Alternatively, where
    an entry panel has an ellipsis button to the right on the text entry
    field, the user may expand the entry panel another level. This generally
    makes available a more detailed form of entry panel specific to the
    required type.</para>

    <para>For example, if we have a new Gem composed simply of the
    <function>sum</function> Gem from the standard library, and we attempt to
    run it, the first entry panel we will get will look like the one in <xref
    linkend="FigureSumValueEntry" />:</para>

    <figure xml:id="FigureSumValueEntry">
      <title>Value Entry panel for <function>sum</function> Gem</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/sumValueInputPanel.png"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>Notice that the icon on the entry panel indicates that the panel is
    expecting a list. We can expand the list entry panel a step by pressing
    its ellipsis button. This yields the view in <xref
    linkend="FigureListValueEditor" />:</para>

    <figure xml:id="FigureListValueEditor">
      <title>List Value Editor</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/listValueEditor.png"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>A larger panel pops up (but with the same coloured border). This is
    the list entry panel. We can enter items into the list by pressing the
    <guibutton>Add</guibutton> button. The newly added entry’s value can then
    be modified by clicking on the ellipsis button next to it.</para>

    <para>In this case, the first time this is done, a window will appear
    allowing the type of the list to be selected. The <function>sum</function>
    Gem accepts a list of any type that is a member of the <type>Num</type>
    type class. Therefore, a type for the elements of the list must be chosen,
    such as <type>Int</type> or <type>Double</type>. This window is displayed
    in <xref linkend="FigureTypeSelectionPanel" />:</para>

    <figure xml:id="FigureTypeSelectionPanel">
      <title>Type selection panel</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/typeSelectionPanel.png"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>Selecting <type>Double</type> for the list type, we now add a few
    more items to the list. <xref linkend="FigureListValueEditorDoubles" />
    shows the result:</para>

    <figure xml:id="FigureListValueEditorDoubles">
      <title>List Value Editor with <type>Double</type> values input</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/listValueEditorWithDoubleValues.png"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>We have added three list elements (<constant>23.5</constant>,
    <constant>5</constant>, and <constant>-6.2</constant>). Each time the
    <guibutton>Add</guibutton> button was pressed, a new floating point number
    entry panel appeared in the list (which will scroll if there are too many
    to show concurrently). We can reorder the list elements using the up and
    down arrow buttons on the list panel.</para>

    <para>As a convenience, for floating point numbers there is another level
    of panel that can be accessed for value entry. Pressing the ellipsis
    button on a floating point entry panel will pop up the panel in <xref
    linkend="FigureCalculatorPanel" />:</para>

    <figure xml:id="FigureCalculatorPanel">
      <title>Calculator panel</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/calculatorPanel.png"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>This is the Calculator Panel, and is provided in order to generate
    appropriate numeric values where these are constants derived from some
    arithmetic process. Notice how this panel indicates that it deals with
    ‘bright pink' types (<type>Double</type>) by colourising its border
    accordingly.</para>

    <para>Once argument values have been assigned the Gem is run by the user
    and a result is obtained. The result value may be of a simple type (such
    as a single numeric value), or it could be a data structure, such as a
    list. In each case, the result can be explored in the Results window which
    pops up. <xref linkend="FigureGemResultsPanel" /> shows the result of our
    <function>sum</function> Gem from before:</para>

    <figure xml:id="FigureGemResultsPanel">
      <title>Gem Results panel</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/gemResultsPanel.png"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>The result is shown in a familiar control – a Value Panel. If the
    result is of a compound type, then the result can be explored by clicking
    on the ellipsis button to the right of the result text. Doing so will
    'expand' the result to show you more internal structure. For example, a
    list value will expand into a scrollable list control showing all the list
    members.</para>

    <para>The Results window can be closed by clicking on the window close
    button in the top-right corner. However, you may leave the window open and
    continue to test your Gem for the purpose of comparing future results with
    those just obtained.</para>

    <para>You may have noticed that when the green ‘play’ button is pressed
    for the first time, the buttons in the Toolbar change to look like those
    in <xref linkend="FigureToolbarButtonsTestingGem" />:</para>

    <figure xml:id="FigureToolbarButtonsTestingGem">
      <title>Toolbar buttons when testing a Gem</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/toolbarButtonsTestingGem.png"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>The red <guibutton>Stop (<inlinemediaobject>
        <imageobject>
          <imagedata fileref="images/GemCutterManual/stop.gif"></imagedata>
        </imageobject>
      </inlinemediaobject>)</guibutton> button is used to stop the running of
    the Gem and return to design mode.</para>

    <para>The numbered buttons are used to select the Gem’s arguments. In this
    case, the Gem constructed on the Table Top has only one input argument –
    the list that is an input to the <function>sum</function> Gem.</para>

    <para>The <guibutton>Reset Argument Values (<inlinemediaobject>
        <imageobject>
          <imagedata fileref="images/GemCutterManual/reset.gif"></imagedata>
        </imageobject>
      </inlinemediaobject>)</guibutton> button clears all the Gem’s argument
    values, while remaining in test mode so that new argument values can be
    entered.</para>

    <para>Occasionally, you may need to change the type of a value being used
    as a test input to a Gem. For instance, you may have tested a Gem with a
    list of <type>Int</type>s and you want to test it again with a list of
    <type>Double</type>s. In this scenario, you would start with test input
    value entry panels looking like those shown in <xref
    linkend="FigureListValueEditorInts" />:</para>

    <figure xml:id="FigureListValueEditorInts">
      <title>List Value Editor for <type>Int</type>s</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/listValueEditorInts.png"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>Notice that the type icon (in this case, the icon for
    <type>Int</type>: <guiicon><inlinemediaobject>
        <imageobject>
          <imagedata fileref="images/GemCutterManual/integer.gif"></imagedata>
        </imageobject>
      </inlinemediaobject></guiicon>) in the panel is highlighted with a
    yellow border. This indicates that the type is modifiable. Given that we
    want to change the type of the list element from an <type>Int</type> to a
    <type>Double</type>, we can click on the active list element's type icon
    to bring up a type list. The list that pops up shows us the options we
    have for morphing the original type into a new one. Also, you always have
    the option of deleting the type constraint completely (and effectively
    starting again from scratch).</para>

    <para>Once the new element type has been assigned, you can enter values of
    the new type and test the Gem again.</para>

    <section xml:id="ViewingTheGemDefinition">
      <title>Viewing the Gem Definition</title>

      <para>Sometimes it may be desirable to see the generated CAL code for a
      Gem before it has been saved to a module. To view the CAL code the Gem
      Cutter would generate for the Gem design currently on the Table Top,
      select the <menuchoice>
          <guimenu>Debug</guimenu>

          <guimenuitem>Dump Gem Definition</guimenuitem>
        </menuchoice> option from the menu bar. This will output the CAL
      definition of the Gem to the console.</para>

      <para>Let’s revisit the example shown at the beginning of <xref
      linkend="TestingANewGem" />, in <xref
      linkend="FigureTestingValueEntry" />. Using the <guimenuitem>Dump Gem
      Definition</guimenuitem> feature outputs the following text to the
      program console:</para>

      <para><computeroutput>Gem Definition: private result x y exponent =
      Math.power (x + y) exponent;</computeroutput></para>

      <para>Observe that the left-hand side of the Gem definition indicates
      that the result Gem takes three arguments: <parameter
      class="function">x</parameter>, <parameter
      class="function">y</parameter> and <parameter
      class="function">exponent</parameter>. The functionality of the Gem
      displayed on the right states that the Gem will add the arguments
      <parameter class="function">x</parameter> and <parameter
      class="function">y</parameter> together, then raise this to the power of
      the <parameter class="function">exponent</parameter> argument. This is
      identical to the Gem design currently set up on the Table Top.</para>

      <para>An alternative way to get the CAL code generated for the Gem
      design currently on the Table Top is to right-click on the Table Top and
      select the <menuchoice>
          <guisubmenu>Copy Special</guisubmenu>

          <guimenuitem>Target Gem Source</guimenuitem>
        </menuchoice> option.</para>
    </section>
  </chapter>

  <chapter xml:id="BurningInputs">
    <title>Burning Inputs</title>

    <para>So far we have considered fairly simple compositions of Gems where
    the simple output value is connected into the input of another Gem.
    However, not all Gem compositions are quite as straightforward. To
    illustrate this, we'll walk though a simple example.</para>

    <para>Suppose we wish to construct a Gem which will tell us if any number
    in a list is larger than <constant>pi</constant>. In order to do this, we
    can call upon the services of the <function>any</function> Gem in the List
    module. This Gem takes a list of any type and returns a
    <type>Boolean</type> value of <code>True</code> if any value in the list
    causes a supplied predicate function to return <code>True</code>. A
    predicate function is a function which will produce a <type>Boolean</type>
    value based on an input. In this case, the predicate required will examine
    a single element in the original list and indicate <code>True</code> if
    this element is greater than <constant>pi</constant> or <code>False</code>
    otherwise.</para>

    <para>Let's verify that any does indeed perform this function by examining
    its 'anatomy'. Dropping an <function>any</function> Gem on the Table Top
    allows us to inspect its inputs and output using the mouse to display
    tooltips (see <xref linkend="FigureAnyGemTooltips" />):</para>

    <figure xml:id="FigureAnyGemTooltips">
      <title><function>any</function> Gem with tooltips displayed</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/anyGemAllTooltips.png"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>The predicate function we want is very simple (just a test for being
    greater than <constant>pi</constant>). Again, we have a standard library
    Gem which will do the work for us, namely
    <function>greaterThan</function>. We can drop this onto the Table Top as
    well and perform a similar inspection (see <xref
    linkend="FigureGreaterThanGemTooltips" />):</para>

    <figure xml:id="FigureGreaterThanGemTooltips">
      <title><function>greaterThan</function> Gem with tooltips
      displayed</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/greaterThanGemAllTooltips.png"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>This tells us that <function>greaterThan</function> takes two values
    belonging to the class <type>Orderable</type> and produces a
    <type>Boolean</type> value.</para>

    <para>We can produce a function which will always test for a value being
    greater than <constant>pi</constant> by attaching a
    <constant>pi</constant> Gem to the second argument of
    <function>greaterThan</function>. The <function>pi</function> Gem takes no
    arguments and simply returns the double value <constant>pi</constant>.
    After dropping a <function>pi</function> Gem on the Table Top and
    connecting it up to the <function>greaterThan</function> Gem, we should
    end up with something that looks like <xref
    linkend="FigurePiGreaterThanGems" />:</para>

    <figure xml:id="FigurePiGreaterThanGems">
      <title><function>pi</function> Gem connected to
      <function>greaterThan</function> Gem</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/piGreaterThan.png"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>We're almost there! We've built a function which will do the actual
    value comparison we want, and we have the Gem which performs that actual
    work of checking a list based on such a comparison (the
    <function>any</function> Gem). All that remains is to connect these two
    up.</para>

    <para>It's about at this point that we realise why things aren't always
    that simple! The output of our '<function>greaterThan</function>
    <function>pi</function>' composite function is a <type>Boolean</type>
    value, but the first input to the <function>any</function> Gem asserts
    that it takes a function that takes a value and returns a
    <type>Boolean</type>. This would imply that we can't take the output of
    this predicate composite and simply connect it into the
    <function>any</function> function as we might think we would want to.
    Actually, this makes perfect sense, because what we actually want is for
    the whole predicate function to be internally provided with values from
    the elements of the input list to <function>any</function>. So, actually,
    we don't want to externally provide the argument to compare to
    <constant>pi</constant> at all. How do we communicate this fact to the Gem
    Cutter?</para>

    <para>The way to achieve what we want is by using 'input burning'. By
    burning the first argument to the <function>greaterThan</function> Gem, we
    are telling the Gem Cutter that we are not intending that this should have
    a single value provided to it, but that this value should be 'collected'
    later on when this function is applied to data (in this case within the
    <function>any</function> Gem). In actual fact, we want to create a
    functional result from the combination of the
    <function>greaterThan</function> Gem and the constant
    <constant>pi</constant>. This is achieved in the Gem Cutter by
    double-clicking an input to be burned or unburned. Doing this with the
    first argument of <function>greaterThan</function>, in our current
    example, will produce the result shown in <xref
    linkend="FigurePredicateFunctionInputBurning" />:</para>

    <figure xml:id="FigurePredicateFunctionInputBurning">
      <title>Predicate function created by input burning</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/piGreaterThanWithBurning.png"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>Notice how the input is now rendered with a 'burnt twig' look to
    tell us that it has been burned. More importantly, note that the output
    type of the combination has changed to a functional result (a function
    which takes a <type>Double</type> and returns a <type>Boolean</type>).
    This is exactly what we need for our predicate function for
    <function>any</function>. Because this is now a type match for the first
    argument of the <function>any</function> function, the
    '<function>greaterThan</function> <function>pi</function>' combination can
    now straightforwardly be connected to the first argument of
    <function>any</function>, giving us the Gem graph shown in <xref
    linkend="FigurePredicateFunctionAnyGem" />:</para>

    <figure xml:id="FigurePredicateFunctionAnyGem">
      <title>Predicate function connected to the <function>any</function>
      Gem</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/piGreaterThanAny.png"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>We can examine the remaining unconnected inputs and output to see
    that we have what we set out to produce. We can test the new Gem to verify
    that we have the correct behaviour. An example test is shown in <xref
    linkend="FigureTestingGemInputBurning" />:</para>

    <figure xml:id="FigureTestingGemInputBurning">
      <title>Testing a Gem with input burning</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/piGreaterThanAnyTesting.png"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>While we only had to burn a single input in this example, other
    scenarios may call for the burning of more than one input (including all
    the inputs of a Gem).</para>

    <para>Now that we've introduced the concept of burning, it’s safe to
    mention that in many cases, the mechanics of manually burning the inputs
    are unnecessary! Because complete and correct type information is always
    known for Gem components, there are many occasions where burning is
    required, and the correct input burn combination can be unambigously
    inferred by the Gem Cutter itself. In these situations, the Gem Cutter
    will allow the user to establish a connection between apparently
    incompatible Gem input-output combinations providing there are one or more
    inputs that can automatically be burnt to make the connection legal. In
    the example we have just examined, this would manifest as the view in
    <xref linkend="FigureAutomaticInputBurning" /> when attempting to connect
    the unburned <function>greaterThan</function> Gem to the
    <function>any</function> Gem:</para>

    <figure xml:id="FigureAutomaticInputBurning">
      <title>Automatic input burning</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/piGreaterThanAnyAutoBurning.png"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>Before we release the mouse button while dragging out the connection
    between the two Gems, and while hovering over the input to
    <function>any</function>, the Gem Cutter will indicate that a connection
    is possible if burning is performed on the
    <function>greaterThan</function> Gem. This is communicated by the cursor
    changing, and by the Gem Cutter provisionally burning the correct input of
    the <function>greaterThan</function> Gem. Completing the connection by
    releasing the mouse button in this configuration will establish the burnt
    argument(s) and the required connection.</para>

    <para>In cases where the Gem Cutter is not able to unambiguously establish
    a connection in this way through burning, it will indicate that a
    connection is still possible if the user can determine the burn
    configuration they need prior to connecting. For example, observe <xref
    linkend="FigureBurnQuestionMark" />:</para>

    <figure xml:id="FigureBurnQuestionMark">
      <title>The Gem Cutter cannot determine which input to burn</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/greaterThanAnyAutoBurnQuestion.png"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>In this case, we have tried to connect the output of the
    <function>greaterThan</function> Gem to the input of the
    <function>any</function> Gem before connecting anything to the inputs of
    the <function>greaterThan</function> Gem. The Gem Cutter has no way of
    knowing if we want its first or second input to be burnt, so the cursor
    changes to a burn icon with a question mark next to it. To connect the
    Gems in this manner, one of the inputs to the
    <function>greaterThan</function> Gem must be manually burnt.</para>

    <para>The IntelliCut feature of the Gem Cutter is also smart enough to
    handle cases where connections can be established between Gems when
    burning is required. Hovering over a Gem input will cause the IntelliCut
    list to popup after the appropriate pause, and this will include Gems
    which can be connected to the input if burning is performed on one or more
    of the new Gem's inputs. <xref linkend="FigureIntellicutInputBurning" />
    shows an example:</para>

    <figure xml:id="FigureIntellicutInputBurning">
      <title>IntelliCut showing Gems that can be connected with input
      burning</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/intellicutBurning.png"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>Notice that the Gem names appearing in the IntelliCut list can have
    a burn icon before them. Names appearing with no icon represent Gems which
    can simply be connected with no need for burning. Gems with a burn icon
    indicate Gems which can be connected to the input, but for which some
    burning is unambiguously required. If the user clicks on one of these, the
    chosen Gem will be added to the Table Top and connected to the appropriate
    input with the correct burning of the new Gem's inputs to make the
    connection meaningful (and legal!). Gem names that are followed by a burn
    icon containing a question mark are Gems which can be connected to the
    input, but for which there are multiple possible combinations of input
    burning which would result in a legal connection. Clicking on one of these
    will add the Gem to the Table Top, but will not connect it, as user
    intervention is required to burn the correct inputs on this Gem to obtain
    the user’s desired functionality.</para>
  </chapter>

  <chapter xml:id="SpecialGems">
    <title>Special Gems</title>

    <para>Special Gems are not actually 'special' at all, at least not at the
    point that a new Gem is saved. However, whilst the Gem is being created,
    Special Gems indicate a special type of contribution to the overall Gem
    definition. That is to say that they define something about the Gem that
    is not available from the libraries of Gems available through the Gem
    Browser.</para>

    <para>Special Gems are added to the Table Top by clicking on a button on
    the toolbar, rather than dragging from the Gem Browser. The toolbar
    section shown in <xref linkend="FigureSpecialGemsToolbarButtons" />
    includes buttons for each of the Special Gems:</para>

    <figure xml:id="FigureSpecialGemsToolbarButtons">
      <title>Special Gems Toolbar buttons</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/specialGemsToolbarButtons.png"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>Clicking on a Special Gem button will cause the cursor to change to
    an arrow with a picture of the selected Gem type beside it. Clicking on
    the Table Top will then place the required Special Gem at that
    location.</para>

    <para>It is also possible to add certain Special Gems from the context
    menu that appears when right-clicking on a Gem connector. The Special Gems
    that are available to add from the context menu depend on the particular
    connector.</para>

    <para>We will take each Special Gem in turn, describe its functionality
    and provide an example.</para>

    <section xml:id="TheValueGem">
      <title>The Value Gem</title>

      <para>The blue Value Gem simply defines a constant. It has a specific
      type and value which can be connected to a compatible input of a Gem to
      bind this value to the Gem. Value Gems appear as rectangular, blue Gems
      when they are added to the Table Top.</para>

      <para>Value Gems are often required to 'de-generalise' a Gem, fixing it
      to deal with a reduced (or specific) set of cases. For example, a
      general purpose filter could be fixed to only look for values above
      1000, rather than values above any input.</para>

      <para>Attaching Value Gems to inputs will remove that input from the set
      of inputs which will be exposed by the Gem under construction when it is
      saved.</para>

      <para>Value Gems use the value entry panels to collect the constant
      values of the particular type that is asserted by the Gem. For example,
      if the Gem is set up to be a constant list of double precision floating
      point numbers, then the list entry panel is used for elements of type
      <type>Double</type>.</para>

      <para>We will take a look at some examples of using the Value
      Gem.</para>

      <para><xref linkend="FigureValueGemLabelled" /> shows a Value Gem as it
      appears when placed on the Table Top, with its sections labelled:</para>

      <figure xml:id="FigureValueGemLabelled">
        <title>Value Gem with sections labelled</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/valueGemLabeled.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The Type Icon displays the type of the value represented by the
      Value Gem. The Value Entry panel displays the current value represented
      by the Value Gem, and allows the user to enter a new value. The Value
      Editor launch button launches a custom editor designed to edit the type
      of value the Value Gem is currently representing. Value Gems allow the
      user to set a value as part of the Gem definition, rather than leaving
      the Gem to collect the value when it is executed. Therefore, the
      value-collecting mechanism is reused in Value Gems.</para>

      <para>Initially a Value Gem does not know what type of value it is
      supposed to be representing. This is indicated by the type icon and
      value field showing a question mark. To begin with, we need to indicate
      what type the constant will be. To do this, we click on the ellipsis
      button to the right of the value entry panel, which displays the image
      in <xref linkend="FigureValueGemTypeSelectionPanel" />:</para>

      <figure xml:id="FigureValueGemTypeSelectionPanel">
        <title>Value Gem type selection panel</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/valueGemWithTypePanel.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>We are now presented with a list of possible types for the value.
      This list is composed from all the types that are currently visible from
      the modules that are open in the Gem Cutter. Let's create a
      <type>Time</type> value. To do this, we must double click on the
      <type>Time</type> item in the types list. The look of the Value Gem now
      changes to that in <xref linkend="FigureValueGemTimeType" />:</para>

      <figure xml:id="FigureValueGemTimeType">
        <title>Value Gem representing the <type>Time</type> type</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/timeValueGem.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The Value Gem now knows what type of value it is supposed to be
      representing, and changes to represent an editor for values of this
      type. Notice the following differences:</para>

      <para><itemizedlist>
          <listitem>
            <para>The type icon has changed to tell us that we are now dealing
            with a <type>Time</type> type.</para>
          </listitem>

          <listitem>
            <para>The value field is now showing a default value for this type
            (in this case, the current time and date).</para>
          </listitem>

          <listitem>
            <para>The colour of the Value Gem's output connector has changed.
            It will become the colour which will be used in this session of
            the Gem Cutter to represent all values of type
            <type>Time</type>.</para>
          </listitem>
        </itemizedlist>At this point, we can edit the actual value that the
      Value Gem represents. The way to edit the value depends on the type, but
      in general, you can alter the value by typing into the value field,
      clicking on the value field and using the cursor keys (up move values
      'up' or 'down'), or by invoking a custom editor specific to the type by
      clicking on the 'ellipsis' button on the right. In any case, the
      technique for altering the value is specific to the particular value
      entry panel for the selected type. It is therefore consistent with the
      situation where you are entering values of this type during Gem
      testing.</para>

      <para>Once you have set the desired value in the Value Gem, the output
      of the Value Gem can be connected to another Gem in the usual way. This
      will apply the value to the input of the other Gem.</para>

      <para>Business Objects Gems have an advanced type system that allows for
      complex types to be described. In keeping with the flexibility of this
      type system, Value Gems let you create compound, highly nested values.
      If you select a type which is a 'container' for other values (possibly
      of different types), the Value Gem value editors will let you continue
      to select nested types and therefore build up the 'shape' of the value
      you need.</para>

      <para>Here's an example of building a constant value which is a record
      containing an integer, a date and a colour value.</para>

      <para>As usual, we start with a completely unspecialised constant, as
      shown in <xref linkend="FigureUnspecializedValueGem" />:</para>

      <figure xml:id="FigureUnspecializedValueGem">
        <title>Unspecialized Value Gem</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/valueGemUnspecialized.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The first thing we need to say about our value is that it is a
      record of three values. The name of the type which describes this is
      <type>Record</type>. We'll select <type>{Record}</type> from the list of
      available types, as displayed in <xref
      linkend="FigureSelectingRecordValueGem" />:</para>

      <figure xml:id="FigureSelectingRecordValueGem">
        <title>Selecting the record type for a Value Gem</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/valueGemSelectingRecord.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Doing this changes the Value Gem, as before, to reflect the fact
      that we are now dealing with a <type>Record</type> value. This is
      displayed in <xref linkend="FigureValueGemRecordType" />:</para>

      <figure xml:id="FigureValueGemRecordType">
        <title>Value Gem representing a record type</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/valueGemRecordType.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The icon and value field both tell us we are dealing with a record
      type. Now, we need to specify that the <type>Record</type> should
      contain three items. To do this, click on the ellipsis button, and click
      the <guibutton>Add</guibutton> button three times. The result should
      look like <xref linkend="FigureRecordEditor" />:</para>

      <figure xml:id="FigureRecordEditor">
        <title>Record editor</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/valueGemRecordEditor.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The three question marks indicate that three values of unknown
      type are contained in this record. Now we need to tell the Value Gem
      what the types and values of each of the elements are.</para>

      <para>We want the first value to be an integer, so we click on the
      editor box for the first value and click the blue button outlined in
      yellow. Next, we select <type>Int</type> from the type menu shown in
      <xref linkend="FigureSelectingTypeRecordComponent" /> which
      appears.</para>

      <figure xml:id="FigureSelectingTypeRecordComponent">
        <title>Selecting a type for a record component</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/valueGemRecordTypeSelection.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>This changes the type of the first value in the record, and sets
      it to the default value (zero).</para>

      <para>We can repeat this process to set the types (and default values)
      for the second and third values contained in the <type>Record</type>
      type. We will end up with the view in <xref
      linkend="FigureRecordIntDateColor" />:</para>

      <figure xml:id="FigureRecordIntDateColor">
        <title>Record containing an <type>Int</type>, <type>Date</type> and
        <type>Color</type> value</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/valueGemRecordIntDateColor.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The names of the fields can also be changed. For example, we can
      change the name of the second field from “#2” to “date” by clicking on
      the box on the left with “#2” in it, and typing “date”. The result looks
      like <xref linkend="FigureRecordAfterRenamingDateField" />:</para>

      <figure xml:id="FigureRecordAfterRenamingDateField">
        <title>Record after renaming the <type>Date</type> type field</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/valueGemRecordDateRenamed.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Note that the entries in the record are automatically organised by
      the alphanumeric ordering of their names. This is just for convenience
      for the user, as records are essentially a map-like entity – order is
      not significant. Valid names include strings starting with a lower case
      letter and containing only alphanumeric characters and the underscore
      character, and the pound sign (#) followed by an integer.</para>

      <para>The Value Gem can always be revisited in order to edit the value
      of each part of the record. For instance, if we want to change the
      colour from black to red, we first click on the Value Gem, and select
      the ellipsis button next to the colour editor. This displays <xref
      linkend="FigureChangingColorField" />:</para>

      <figure xml:id="FigureChangingColorField">
        <title>Changing the <type>Color</type> field</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/valueGemRecordColorEditor.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Selecting an appropriate shade of red changes the Value Gem to
      display the new settings, as shown in <xref
      linkend="FigureRecordColorChangedToRed" />:</para>

      <figure xml:id="FigureRecordColorChangedToRed">
        <title>Record with <type>Color</type> changed to red</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/valueGemRecordColorRed.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Naturally, it is possible to set types for component values which
      are themselves compound, creating an even deeper nesting for the
      resultant value.</para>

      <para>If you make a mistake, or simply wish to change the design on the
      Gem being constructed to include a constant of a different type, you can
      change the type of a Value Gem. In order to change the type, the Gem
      Cutter must be in 'design mode' (i.e. you cannot change the design of a
      Gem if you are testing it). To change the type of a Value Gem, simply
      click on the type icon on the left of the Gem and select a new type from
      the menu that appears.</para>
    </section>

    <section xml:id="TheCodeGem">
      <title>The Code Gem</title>

      <para>Code Gems are used to inject a specific expression into the Gem
      under construction. In fact, Code Gems are actually code editors for the
      <firstterm>CAL</firstterm> language which underlies the Business Objects
      Gems concept. A Code Gem can therefore be made to represent any user
      defined function, including complex functions involving local variables
      and calls to external functions in the visible set of modules.</para>

      <para>Code Gems are functions and therefore appear as triangular Gems on
      the Table Top, but are green instead of the regular red or
      yellow.</para>

      <para>We'll now walk through an example of Code Gems to demonstrate how
      they might be used by creating a customised filter Gem. This Gem will
      find all entries in a list which have a value greater than 1000.</para>

      <para>Let's start by taking the <function>filter</function> Gem from the
      <package>List</package> module. We know that the output from this will
      be the output of the Gem we're designing, so we can go ahead and connect
      it to the Result Target. <xref linkend="FigureFilterGemResultTarget" />
      shows our Gem so far:</para>

      <figure xml:id="FigureFilterGemResultTarget">
        <title><function>filter</function> Gem connected to result
        target</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/filterResult.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Taking a look at the <function>filter</function> Gem tells us that
      it takes a predicate function as its first argument. This is a function
      that will return a <type>Boolean</type> type, which will indicate
      whether to accept or reject a list element into the set that
      <function>filter</function> will return. Hovering the mouse over the
      dark blue input (<xref linkend="FigureFilterGemWithTooltip" />) shows us
      its type:</para>

      <figure xml:id="FigureFilterGemWithTooltip">
        <title><function>filter</function> Gem with tooltip</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/filterGemTooltip.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>We can see that the type required is a function which takes
      anything (the 'a') and returns a <type>Boolean</type>. This definition
      sets the 'target' type that we have to achieve in our Code Gem in order
      to make it a compatible predicate function for
      <function>filter</function>.</para>

      <para>We'll now create a Code Gem that we'll edit to be a predicate
      function to achieve the desired effect. Pressing the <guibutton>Code Gem
      (<inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/code.gif"></imagedata>
          </imageobject>
        </inlinemediaobject>)</guibutton> button on the toolbar and clicking
      in an empty area on the Table Top adds a new Code Gem, as shown in <xref
      linkend="FigureNewCodeGemOnTableTop" />.</para>

      <figure xml:id="FigureNewCodeGemOnTableTop">
        <title>New Code Gem added to Table Top</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/filterNewCodeGem.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The new Code Gem is automatically named for us, although this is
      mostly for the user's benefit. Technically speaking, we will be creating
      a lambda expression, which means an anonymous function.</para>

      <para>Notice that the Code Gem appears broken at the moment. The cracks
      on its surface are an indication that the Gem is not 'good', that it
      requires some attention to be useable in the Gem we are constructing. At
      the moment, this is simply because we haven't actually given it a
      definition!</para>

      <para>By default, double-clicking a Code Gem will open its Code Gem
      Editor. <xref linkend="FigureCodeGemEditor" /> shows the editor for the
      new Gem:</para>

      <figure xml:id="FigureCodeGemEditor">
        <title>Code Gem Editor</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/newCodeGemEditor.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The Code Gem Editor associates itself with the Code Gem by name
      and by proximity (initially). Also, note that an image of a magnifying
      glass has appeared on the Code Gem. This indicates that this Code Gem’s
      associated editor window is open. The blue colour of the lens means that
      this Code Gem’s editor window has the focus currently. If the lens
      appears white, it means that this Gem’s editor window is open, but does
      not currently have the focus. This is useful to help show which Code Gem
      is currently being edited when multiple editor windows are open at
      once.</para>

      <para>The function we want to describe is a test for a value (which will
      be our list element) being greater than 1000. No big surprises here, the
      code we want is the expression:</para>

      <para><code language="CAL">element &gt; 1000</code></para>

      <para>The Code Gem Editor should look like <xref
      linkend="FigureCodeGemEditorWithCode" /> after typing in this piece of
      code:</para>

      <figure xml:id="FigureCodeGemEditorWithCode">
        <title>Code Gem Editor containing CAL code</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/codeGemEditorElementOver1000.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>As soon as we paused typing, the Code Gem Editor took the code and
      checked it. It was checked for syntactical correctness according to the
      CAL language specification, and it was checked for 'type correctness'.
      All this takes a tiny fraction of a second, so it is done every time the
      user pauses typing. This means that you can stop if you are unsure and
      see what the Code Gem Editor has to say.</para>

      <para>Notice that various fields have appeared or changed on the Code
      Gem Editor to indicate the meaning of the expression we just
      typed.</para>

      <para>Firstly, an item has appeared in a panel to the left of the typing
      area. This is telling us that the name <parameter
      class="function">element</parameter> has been inferred to be an argument
      (the icon on the left tells us this). It also tells us that the type of
      this argument is inferred as a <type>Num</type> (a number).</para>

      <para>At the bottom of the editor, we see the text "<type>-&gt;
      Boolean</type>". This tells us that the output type of the function has
      been inferred to be a <type>Boolean</type> type. Along with the
      argument, we can see that we have produced a function that takes a
      <type>Num</type> and produces a <type>Boolean</type>. The type
      expression of this would be (<type>Num a =&gt; a -&gt; Boolean</type>).
      This is perfectly compatible with the required type (<type>a -&gt;
      Boolean</type>), so we have succeeded in creating our required predicate
      function.</para>

      <para>What has happened so far illustrates one of the major features of
      Business Objects Gems and the CAL language, which is that the system
      will attempt to be as general as possible. In the absence of any
      information to the contrary, the CAL compiler has inferred that the most
      general type that the code will deal with is a number. If we were to
      force a more specific interpretation by changing the 1000 to 1000.0
      (making the number into a definite floating point <type>Double</type>),
      we would see the type of element change to <type>Double</type>. Go ahead
      and experiment with this, then return to the original source
      code.</para>

      <para>Syntax highlighting of the expression text itself gives further
      visual feedback about how the expression has been interpreted.</para>

      <para>Finally, we can tell the expression made sense because the Gem
      (behind the editor) has now been 'repaired' and is showing no signs of
      cracking!</para>

      <para>Now, to complete our filter, simply connect the output of the new
      Code Gem to the first input of the <function>filter</function> Gem. This
      will result in the input to the Code Gem being automatically burnt as
      per the requirements of the <function>filter</function> Gem. The filter
      is shown in <xref
      linkend="FigureGemFilterElementsGreaterThan1000" />:</para>

      <figure xml:id="FigureGemFilterElementsGreaterThan1000">
        <title>Gem to filter elements greater than 1000 from a list</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/codeGemFilter1000Complete.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Now, suppose that when we were coding the functionality of the new
      Code Gem, we made a mistake. <xref
      linkend="FigureCodeGemEditorIncorrectCode" /> shows an example where we
      got the expression wrong:</para>

      <figure xml:id="FigureCodeGemEditorIncorrectCode">
        <title>Code Gem Editor containing incorrect code</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/codeGemEditorCodeBroken.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>This time, the CAL compiler cannot infer that element is an
      argument, or give us a resultant type. Instead, the word “broken”
      appears in red text in the bottom right corner of the Code Gem Editor
      window, and the errors are underlined in red. The Gem has cracked again,
      showing that we have some work to do to 'fix it'. To view a more
      detailed definition of a specific error, place the mouse pointer over
      the underlined code, as in <xref
      linkend="FigureCodeGemEditorTooltipDescribingError" />:</para>

      <figure xml:id="FigureCodeGemEditorTooltipDescribingError">
        <title>Code Gem Editor with tooltip describing code error</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/codeGemEditorExaminingBrokenCode.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>In this case, we haven't finished the expression correctly.</para>

      <para>Another effect that was achieved once we had valid source in the
      Code Gem Editor was the fact that the Code Gem updated itself to show
      inputs and outputs of the correct type (at the same time that it became
      uncracked). The fixed Code Gem is displayed in <xref
      linkend="FigureCodeGemWithTooltips" />, along with its tooltips:</para>

      <figure xml:id="FigureCodeGemWithTooltips">
        <title>Code Gem with tooltips</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/codeGemWithTooltips.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Hovering the mouse of these new inputs and outputs will show us
      that the Gem believes that it takes a <type>Num</type> and returns a
      <type>Boolean</type>, just as expected. We can now go ahead and connect
      this Code Gem to the predicate input of the <function>filter</function>
      Gem and proceed to test or save our creation.</para>

      <para>You can continue to make changes to your Code Gem after having
      connected it to other Gems (on its inputs or output). However, doing so
      will establish type constraints for the Code Gem, so it is often better
      to develop the code without establishing connections until the code
      looks correct and the inferred types are what is expected.</para>

      <para>If you do connect the Code Gem and then alter the code, you will
      see a number of possible effects.</para>

      <para>Here is an example of constraints on code after composition with
      other Gems. We start with a simple Code Gem to add two numbers together.
      We have connected two <function>add</function> Gems to the inputs of the
      new Code Gem. This changes the type description of the arguments to show
      that they are connected. The Code Gem Editor has inferred that the
      output is a <type>Num</type>. The situation is displayed in <xref
      linkend="FigureTwoAddGemsCodeGem" />:</para>

      <figure xml:id="FigureTwoAddGemsCodeGem">
        <title>Two <function>add</function> Gems connected to a Code
        Gem</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/codeGemTwoAddGems.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>At this point, we will attempt to edit our CAL code to add a third
      parameter (added to the first two). The result is shown in <xref
      linkend="FigureCodeGemEditorThreeParameters" />:</para>

      <figure xml:id="FigureCodeGemEditorThreeParameters">
        <title>Code Gem Editor with three parameters</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/codeGemEditorThreeArgs.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The new thirdArg argument is recognised and inferred as a
      <type>Num</type> because of its relationship to the other arguments
      (through the <code>+</code> operator). The display of the Gem on the
      Table Top also changes to include the new argument, as shown in <xref
      linkend="FigureCodeGemThirdArgument" />:</para>

      <figure xml:id="FigureCodeGemThirdArgument">
        <title>Code Gem with added third argument</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/codeGemThreeArguments.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>What happens if we try to remove a connected argument reference
      from the code? We'll try this by deleting the reference to <parameter
      class="function">secondArg</parameter>. <xref
      linkend="FigureCodeGemEditorRemovedSecondArg" /> shows the
      result:</para>

      <figure xml:id="FigureCodeGemEditorRemovedSecondArg">
        <title>Code Gem Editor after removing <parameter
        class="function">secondArg</parameter></title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/codeGemEditorSecondArgRemoved.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The <parameter class="function">firstArg</parameter> and
      <parameter class="function">secondArg</parameter> arguments are held
      locked by the virtue of being connected to the <function>add</function>
      Gems. The <parameter class="function">secondArg</parameter> argument is
      now marked as being connected, but unused. The definition of the Code
      Gem tells us that the result of the Gem will be the addition of the
      <parameter class="function">firstArg</parameter> and <parameter
      class="function">thirdArg</parameter> arguments, but the resultant Code
      Gem will continue to have three arguments (the unused argument will
      appear in the argument list, even though it is never used by the
      function). Anything connected to this defunct argument will effectively
      be 'pruned away' by the CAL runtime when the Gem is executed as
      <parameter class="function">secondArg</parameter> can clearly have no
      impact on the result of the program. The Code Gem does rearrange order
      of the arguments slightly. It does this to try to keep the order of the
      arguments on the resulting function the same as the order of their
      appearance in the function definition. This is just a sensible
      'default', and we'll see later that the argument order can easily be
      changed.</para>

      <para>Now we'll take a look at what happens if we change the inferred
      type of a locked argument. Let's change the code such that it implies
      that first must be a list, as shown in <xref
      linkend="FigureArgumentTypeClashCodeGemEditor" />:</para>

      <figure xml:id="FigureArgumentTypeClashCodeGemEditor">
        <title>Argument type clash in the Code Gem Editor</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/codeGemEditorArgumentTypeClash.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Notice that the argument <parameter
      class="function">firstArg</parameter> is now flagged with a type clash
      error. The tooltip for this error in <xref
      linkend="FigureArgumentTypeClashErrorTooltip" /> shows us that the
      argument was locked to a <type>Num</type> and that a list of
      <type>Num</type>s is incompatible with this type constraint:</para>

      <figure xml:id="FigureArgumentTypeClashErrorTooltip">
        <title>Argument type clash error tooltip</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/typeClashErrorTooltip.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>This problem has also caused our Gem to 'break'.</para>

      <para>A similar situation exists for the output of a Code Gem. If we
      connect the output to another Gem, we establish a type constraint for
      the output type. Failing to comply with this constraint will result in a
      'broken' Code Gem and a flagged type error. This time, the type error
      will be displayed on the status line where we normally see the inferred
      output type, as shown in <xref
      linkend="FigureOutputTypeClashCodeGemEditor" />:</para>

      <figure xml:id="FigureOutputTypeClashCodeGemEditor">
        <title>Output type clash in the Code Gem Editor</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/codeGemEditorOutputTypeClash.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Here, we can see that the code has been changed to return a
      string, but an output type constraint exists for the Code Gem as it is
      connected to an <function>add</function> Gem. The type clash error is
      flagged on the status line and the tooltip tells us the details about
      the type incompatibility.</para>

      <para>Returning to our original definition, adding three arguments
      together, it is often important to be able to reorder the arguments of a
      function. This becomes important if we want to allow our resulting Gem
      to be easily used in partial evaluation. As such, we normally want the
      arguments that are more likely to be left unbound to occur at the end of
      the argument list. So, it's good practice to think about this when
      developing a Code Gem. How do we force the order of the arguments? Well,
      one way is simply to ensure that the arguments' variable names appear in
      the desired order in the syntax of the Gem’s CAL code. Doing this will
      allow the default ordering to take care of making sure the arguments are
      in the correct order. However, it is not always convenient, or even
      possible, to force the code to reflect the desired argument order.
      Instead, the Code Gem editor allows you to order the arguments
      manually.</para>

      <para>Starting with default ordering and our earlier example, the Code
      Gem editor will appear like <xref
      linkend="FigureCodeGemEditorBeforeArgumentReordering" />:</para>

      <figure xml:id="FigureCodeGemEditorBeforeArgumentReordering">
        <title>Code Gem Editor before argument reordering</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/codeGemEditorBeforeArgumentReordering.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Let's suppose that for reasons of being able to use the function
      naturally in future applications, we decide that we would like to have
      <parameter class="function">thirdArg</parameter> come before <parameter
      class="function">secondArg</parameter> in the argument list. To achieve
      this, click on the <parameter class="function">thirdArg</parameter>
      entry in the variables panel on the left and drag it up above the
      <parameter class="function">secondArg</parameter> entry. As we drag, an
      insertion line will indicate where the argument will be positioned if we
      release the mouse button. We want to release it when it looks like the
      image in <xref
      linkend="FigureArgumentsBeingReorderedCodeGemEditor" />:</para>

      <figure xml:id="FigureArgumentsBeingReorderedCodeGemEditor">
        <title>Arguments being reordered in the Code Gem Editor</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/codeGemEditorReorderingArguments.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Notice the item we are dragging appears grey and an insertion line
      is drawn above the <parameter class="function">secondArg</parameter>
      entry. The cursor also changes to indicate that we are dragging.</para>

      <para>When the mouse is released in the situation shown above,
      <parameter class="function">thirdArg</parameter> is repositioned in the
      variable panel to indicate that it is now the second argument of the
      function. This situation is shown in <xref
      linkend="FigureCodeGemEditorAfterArgumentReordering" />:</para>

      <figure xml:id="FigureCodeGemEditorAfterArgumentReordering">
        <title>Code Gem Editor after argument reordering</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/codeGemEditorAfterArgumentReordering.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Function calls appear in the panel on the left below the Arguments
      panel. These indicate that the variable has been inferred or set by the
      user to mean a call to another function. The fact that this is a call
      will also be indicated in the code through syntax highlighting.</para>

      <para>In some cases, the inferred class of the variable (argument or
      function call) will not be correct. This happens because the editor
      assumes that any variable names it discovers which match the names of
      other recognised functions are calls to that function. If this were
      always the case, then you would not be able to reuse the names of
      functions for arguments, which could be very awkward! Instead, where an
      incorrect assumption has been made about a call to an external function,
      the user is allowed to assert that the variable is actually an argument.
      This can be done simply by clicking on the name in the Arguments or
      Functions panel, and dragging it to the other panel. Alternatively,
      right-clicking on the argument or function name in one of the panels on
      the left will display a context menu allowing the user to choose whether
      this identifier should be treated as an argument or a function.</para>

      <para>For example, suppose we have the Code Gem in <xref
      linkend="FigureAverageCodeGemAndEditor" />:</para>

      <figure xml:id="FigureAverageCodeGemAndEditor">
        <title><function>average</function> Code Gem and editor</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/codeGemEditorAverage.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The desired functionality of the Gem is that it will take a sum of
      some values and a count of the number of values as inputs, and divide
      the sum by the count to produce an average value. However, the Gem
      Cutter has inferred that the variable <varname>sum</varname> refers to
      the function <function>List.sum</function> (a function to sum the values
      in a list), instead of treating it as an argument to the Code Gem, as we
      want. This has caused the Gem to break.</para>

      <para>Fixing this is done by dragging <varname>sum</varname> from the
      Functions panel to the Arguments panel, or by right-clicking it and
      selecting the <guimenuitem>Argument</guimenuitem> option from the
      context menu. <xref
      linkend="FigureAverageCodeGemAfterFunctionChangedToArgument" /> shows
      the completed Code Gem:</para>

      <figure xml:id="FigureAverageCodeGemAfterFunctionChangedToArgument">
        <title><function>average</function> Code Gem after changing function
        name to argument</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/codeGemEditorAverageFixed.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The Code Gem Editor also offers code completion for function and
      data constructor names. To invoke this, press <accel>Ctrl+Space</accel>
      while typing in the editor window. A window will pop up and give a list
      of all the possible functions and data constructors that match the text
      that has already been typed. An example is shown in <xref
      linkend="FigureCodeCompletionCodeGemEditor" />:</para>

      <figure xml:id="FigureCodeCompletionCodeGemEditor">
        <title>Code completion in the Code Gem Editor</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/codeGemEditorCodeCompletion.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Any of the functions in the list can be selected and inserted into
      the code by clicking the desired function with the mouse, or by moving
      to the desired function with the arrow keys and pressing <keycap
      function="enter">Enter</keycap>.</para>

      <para>Another convenient way to insert functions into the code in the
      Code Gem Editor is by dragging and dropping them from the Gem Browser.
      This is done the same way as dropping a Gem on the Table Top, except
      that you drop it in the appropriate place in your code in the editor
      window.</para>

      <para>The Code Gem Editor includes an easy method to rename local
      variables (variables defined in a <code language="CAL">let</code>
      expression). To rename a local variable, right-click on an instance of
      the variable to open its context menu, shown in <xref
      linkend="FigureRenamingVariableInCodeGemEditor" />:</para>

      <figure xml:id="FigureRenamingVariableInCodeGemEditor">
        <title>Renaming a variable in the Code Gem Editor</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/codeGemEditorRenamingVariable.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Select the <guimenuitem>Rename variable</guimenuitem> option.
      Typing a new variable name will now cause every instance of this
      variable name in the code to be updated. For example, we can change
      variable <varname>x</varname> to <varname>minValue</varname> as
      displayed in <xref
      linkend="FigureCodeGemEditorAfterRenamingVariable" />:</para>

      <figure xml:id="FigureCodeGemEditorAfterRenamingVariable">
        <title>Code Gem Editor after renaming a variable</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/codeGemEditorVariableRenamed.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Both of the locations of <varname>x</varname> in the code are
      immediately replaced with the new variable name.</para>

      <para>A feature available from the Table Top of the Gem Cutter is the
      ability to copy the code from Code Gems into the system buffer. To
      access this feature, right-click on the Table Top to open a context menu
      and select the <menuchoice>
          <guisubmenu>Copy Special</guisubmenu>

          <guimenuitem>Code Gems</guimenuitem>
        </menuchoice> option. This copies the code from all the Code Gems into
      the system buffer so that it can be pasted into another location.
      Alternatively, the code from a single Code Gem, or a selection of Code
      Gems, can be copied by selecting the desired Code Gems, then
      right-clicking on a selected Code Gem and invoking the <menuchoice>
          <guisubmenu>Copy Special</guisubmenu>

          <guimenuitem>Code Gems</guimenuitem>
        </menuchoice> option.</para>
    </section>

    <section xml:id="CollectorsAndEmitters">
      <title>Collectors and Emitters</title>

      <para><firstterm baseform="Collector">Collectors</firstterm> are special
      gems which collect a result. The purpose of a Collector is to identify a
      result, and to name the result. Collectors can be run, causing the
      result to be evaluated. The main use of a Collector, however, is to give
      a name to a value so that the value can be used as an input to other
      Gems.</para>

      <para>Having created a Collector and named it, and connected it to the
      output of a Gem, the user has effectively created a 'variable'. This
      will store the result. In order to use the same result in further
      computation within the Gem being constructed, the user creates
      <firstterm baseform="Emitter">Emitters</firstterm> as required. Each
      Emitter can then be used to connect the result to other Gem inputs. This
      effectively allows one output to be ‘split’ in order to connect to
      multiple inputs of other Gems.</para>

      <para>Here's a simple example. Let's say we want to filter out all the
      elements of a numeric list which are above the average (of all the
      elements in the list). Even with this simple definition, we can see that
      'elements of a numeric list' occurs twice. This is a clue to the fact
      that we will require a variable.</para>

      <para>Let's start by getting the obvious components, a
      <function>filter</function>, a <function>greaterThan</function> and an
      <function>average</function> Gem, and placing them on the Table Top such
      as in <xref linkend="FigureGemsOnTableTop" />:</para>

      <figure xml:id="FigureGemsOnTableTop">
        <title>Gems on Table Top</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/averageFilterGreaterThan.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>We want to create a ‘variable’ representing ‘the elements of a
      list’. To do this, we place a Collector Gem on the Table Top by
      selecting the <guibutton>Add Collector Gem (<inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/collector.gif"></imagedata>
          </imageobject>
        </inlinemediaobject>)</guibutton> button in the Toolbar, and clicking
      a blank area on the Table Top. Next, we rename the new Collector Gem to
      <varname>list</varname> by right-clicking on the Gem and selecting the
      <guimenuitem>Rename Gem</guimenuitem> option, or simply by
      double-clicking the Collector Gem. The result looks like <xref
      linkend="FigureTableTopCollectorAdded" />:</para>

      <figure xml:id="FigureTableTopCollectorAdded">
        <title>Table Top with Collector Gem added</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/tableTopWithCollectorAdded.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The next step is to find the average of our list. To do this, we
      place an Emitter Gem by clicking on the down arrow next to the
      <guibutton>Add Emitter Gem (<inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/reflector.gif"></imagedata>
          </imageobject>
        </inlinemediaobject>)</guibutton> button in the Toolbar, selecting
      <varname>list</varname>, and clicking on a blank area in the Table Top.
      Once the new Emitter has been placed, we connect it to the input of the
      <function>average</function> Gem.</para>

      <para>We also need to filter this list. In order to set our list as
      input to the <function>filter</function> Gem, we must place another
      Emitter Gem, and connect it to the second input of the
      <function>filter</function> Gem. The result should look like <xref
      linkend="FigureEmittersConnected" />:</para>

      <figure xml:id="FigureEmittersConnected">
        <title>Emitter Gems connected on Table Top</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/listCollectorAndEmitters.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>We want the list to be filtered so that only the elements greater
      than the average are given in the result. Attaching the output of the
      <function>average</function> Gem to the second input of the
      <function>greaterThan</function> Gem sets the
      <function>greaterThan</function> Gem up to compare numbers to the
      average value of the list. The output of the
      <function>greaterThan</function> Gem can now be connected to the first
      input of the <function>filter</function> Gem. Note that when this is
      done, the first input to the <function>greaterThan</function> Gem is
      automatically burnt (see <xref linkend="BurningInputs" />) so that it is
      a function of the correct type required by the
      <function>filter</function> Gem. Lastly, the output of the
      <function>filter</function> Gem is connected to the result target. The
      completed Gem looks like <xref
      linkend="FigureCompletedFilteringGemLayout" />:</para>

      <figure xml:id="FigureCompletedFilteringGemLayout">
        <title>Completed filtering Gem layout</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/completedFilteringGem.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <section xml:id="CreatingLocalFunctions">
        <title>Creating Local Functions</title>

        <para>In the previous example demonstrating the use of Collector and
        Emitter Gems, we created a Gem which could filter a list and return
        only list elements greater than the average of the list. What if we
        wanted to modify the filtering function so that elements will be
        returned if they are greater than the list average, or if they are
        less than five?</para>

        <para>The Gem layout in <xref
        linkend="FigureCompletedFilteringGemLayout" /> can be modified to look
        like <xref linkend="FigureModifiedFilteringGemLayout" />:</para>

        <figure xml:id="FigureModifiedFilteringGemLayout">
          <title>Modified filtering Gem layout</title>

          <screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="images/GemCutterManual/modifiedFilteringGemNewPredicate.png"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot>
        </figure>

        <para>We would like to somehow connect the <function>or</function> Gem
        to the first input of the <function>filter</function> Gem, as was done
        in the previous example with the <function>greaterThan</function> Gem.
        This time, however, we have a problem: the input we would like to burn
        is not on the or Gem at all, but instead is represented by the
        collector labelled <varname>value</varname>. How, then, do we get the
        Gem Cutter to recognize that we want the tree of Gems connected to the
        <function>or</function> Gem to be treated as the predicate function to
        be input to the <function>filter</function> Gem, with the
        <varname>value</varname> input burnt?</para>

        <para>The solution is to create a local function. To do this, first
        connect a Collector Gem to the output of the <function>or</function>
        Gem, and rename it with an appropriate name for the local function. In
        this case, it has been named <function>filterFunc</function>, as in
        <xref
        linkend="FigureModifiedFilteringGemFilterfuncCollector" />:</para>

        <figure xml:id="FigureModifiedFilteringGemFilterfuncCollector">
          <title>Modified filtering Gem layout with
          <function>filterFunc</function> collector</title>

          <screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="images/GemCutterManual/filteringGemWithFilterfunc.png"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot>
        </figure>

        <para>Now, it is necessary to specify that the input to the Collector
        named <varname>value</varname> should be treated as an input to our
        local function, <function>filterFunc</function>, instead of to the
        result target. To do this, right-click on the input to the
        <varname>value</varname> Collector, select the <guisubmenu>Retarget
        Input</guisubmenu> option from the menu, and select
        <function>filterFunc</function> from the submenu that appears. Note
        that the circle around the input on the <varname>value</varname>
        Collector changes colour from red to black, indicating that this input
        is now targeting another collector instead of the result target
        (compare <xref
        linkend="FigureModifiedFilteringGemFilterfuncCollector" /> with <xref
        linkend="FigureCompletedModifiedFilteringGem" />).</para>

        <para>The local function is now complete! To use it, simply place an
        Emitter Gem for <function>filterFunc</function>. <xref
        linkend="FigureFilterFuncEmitterGem" /> shows what it will look
        like:</para>

        <figure xml:id="FigureFilterFuncEmitterGem">
          <title><function>filterFunc</function> Emitter Gem</title>

          <screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="images/GemCutterManual/filterFuncLocalFunction.png"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot>
        </figure>

        <para>You will notice that the Emitter now has a triangle shape like a
        regular function Gem, and has an input in addition to its output.
        Instead of representing a value, this Emitter now represents a
        function that takes a <type>Double</type> as input and returns a
        <type>Boolean</type>.</para>

        <para>To complete the Gem, all that is left to do is to burn the input
        to the <function>filterFunc</function> Emitter Gem, and connect it to
        the first input of the <function>filter</function> Gem. Here is the
        finished Gem in <xref
        linkend="FigureCompletedModifiedFilteringGem" />:</para>

        <figure xml:id="FigureCompletedModifiedFilteringGem">
          <title>Completed modified filtering Gem using local function</title>

          <screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="images/GemCutterManual/modifiedFilteringGemCompleted.png"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot>
        </figure>

        <para>Local functions are very useful when a simple function is needed
        inside the function (Gem) being designed, and it is not desirable to
        save this inner function separately.</para>
      </section>
    </section>

    <section xml:id="TheRecordCreationGem">
      <title>The Record Creation Gem</title>

      <para>The <firstterm>Record Creation Gem</firstterm> is used to create a
      record via connections to its inputs.</para>

      <para>The Record Creation Gem is shown in <xref
      linkend="FigureRecordCreationGem" />:</para>

      <figure xml:id="FigureRecordCreationGem">
        <title>Record Creation Gem</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/recordCreationGem.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The Record Creation Gem has one or more labeled inputs. Each of
      these labeled inputs represents a record field whose name is the label
      on the input, and whose value is any connection to that input. The
      output of the Gem is a record value comprised of fields whose names and
      values correspond to the Record Creation Gem's input labels and
      connections.</para>

      <para>For instance, the output of the gem in <xref
      linkend="FigureRecordCreationGemExample" /> is a record value with two
      fields: the first field is named "name" and has a value of "Fred", and
      the second is named "age" with a value of "22". This represents the
      record value <code>{name="Fred", value=22}</code>.</para>

      <figure xml:id="FigureRecordCreationGemExample">
        <title>Creation of a record with "name" and "age" fields</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/recordCreationGemExample.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>When a record creation gem is first placed it has a two inputs,
      each of which are labeled with a default field name. An input's field
      name can be changed by double-clicking on its label and entering a new
      field name. Additional actions are available in the context menu when
      right-clicking on the Gem: <guimenuitem>Add Field</guimenuitem>,
      <guimenuitem>Delete Field</guimenuitem>, and <guimenuitem>Rename
      Field</guimenuitem> can be used to add new fields, delete existing
      fields, or rename fields (similar to double-clicking a field name)
      respectively.</para>
    </section>

    <section xml:id="TheRecordFieldSelectionGem">
      <title>The Record Field Selection Gem</title>

      <para>The <firstterm>Record Field Selection Gem</firstterm> is a
      triangular purple Gem. It is often used when working with records. Its
      function is to obtain the value of a particular field from an existing
      record.</para>

      <para>The Record Field Selection Gem is shown in <xref
      linkend="FigureExtractorGem" />:</para>

      <figure xml:id="FigureExtractorGem">
        <title>Record Field Selection Gem</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/extractorGem.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The Record Field Selection Gem always has exactly one input
      connector. The name displayed on the Gem represents the name of the
      field that will be selected from a record that is input to the
      Gem.</para>

      <para>When a record field selection gem is first created the field to
      select is automatic. This is indicated by an asterisk appended to the
      end of the field name. It means that any type of record can be connected
      to the input, providing any output constraints can be satisfied. When a
      connection is made, a combo box is displayed allowing the user to select
      a valid field. Once a field has been selected, the field becomes fixed,
      and can not change again automatically, even if the gem is disconnected
      and reconnected. In this state, only records which contain the
      appropriate field can be connected. However, the field can be modified
      explicitly at any time, either by double-clicking on the Gem, or by
      right-clicking on the Gem and selecting the <guimenuitem>Change Field to
      Select</guimenuitem> option from the context menu. This will allow the
      user to enter or select a field that is consistent with the input and
      output connections.</para>
    </section>
  </chapter>

  <chapter xml:id="PropertiesBrowser">
    <title>The Properties Browser</title>

    <para>The Properties Browser is a section of the Gem Cutter that displays
    information about all the different modules and Gems in the current
    workspace. The Properties Browser is a useful tool for examining all the
    different Gems available for use. It can also be used to modify Gem
    metadata (data about the Gems), or write new metadata for newly created
    Gems.</para>

    <section xml:id="ViewingGemAndModuleMetadata">
      <title>Viewing Gem and Module Metadata</title>

      <para>To open the Properties Browser, select the <menuchoice>
          <guimenu>View</guimenu>

          <guimenuitem>Properties Browser...</guimenuitem>
        </menuchoice> menu option. Alternatively, to display the properties of
      a Gem or module directly, right-click on the Gem or module in the Gem
      Browser, or a Gem on the Table Top. From the context menu, select the
      <menuchoice>
          <guimenuitem>View Properties...</guimenuitem>
        </menuchoice> option.</para>

      <para><xref linkend="FigurePropertiesBrowser" /> shows what the
      Properties Browser looks like:</para>

      <figure xml:id="FigurePropertiesBrowser">
        <title>The Properties Browser</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/propertiesBrowser.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The panel on the left side of the Properties Browser is called the
      Navigation Panel. The Navigation Panel allows for easy browsing of all
      the modules in the workspace, and all the Gems they contain. The layout
      of the Navigation Panel is similar to the Gem Browser, except that the
      Navigation Panel organizes the contents of each module into folders that
      organize Gems according to their CAL representations. These folders
      are:</para>

      <variablelist>
        <varlistentry>
          <term>Functions</term>

          <listitem>
            <para>The Functions folder contains a list of all the function
            (red) Gems in the module.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Types</term>

          <listitem>
            <para>The Types folder contains a list of all the data types
            defined in the module. Any type that has data constructors (yellow
            Gems) for it will have an expandable node for the type name, with
            the data constructors listed.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Classes</term>

          <listitem>
            <para>The Classes folder contains a list of all the type classes
            defined in the module. Each type class has a list of class methods
            accessible by expanding the node containing the name of the type
            class.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Instances</term>

          <listitem>
            <para>The Instances folder contains a list of all the specific
            types that implement functions from type classes. These functions
            each have their own metadata, which gives details about the
            implementation of a type class function for a specific
            type.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>The panel on the right side of the Properties Browser is where the
      information related to the Gem or module selected in the Navigation
      panel is displayed. At the top of this panel is a toolbar that looks
      like <xref linkend="FigurePropertiesBrowserToolbar" />:</para>

      <figure xml:id="FigurePropertiesBrowserToolbar">
        <title>Properties Browser toolbar</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/propertiesBrowserToolbar.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>This toolbar contains <guibutton>Back</guibutton> and
      <guibutton>Forward</guibutton> buttons that function similarly to the
      buttons in a web browser, allowing the user to navigate back and forth
      between previously viewed pages in the Properties Browser. It also
      contains a button to toggle display of the <guibutton>Navigation
      Panel</guibutton> on or off, and a <guibutton>Print</guibutton> button
      to print the currently displayed metadata. The
      <guibutton>Edit</guibutton> button is used to edit the metadata for the
      item currently displayed (see <xref linkend="EditingMetadata" /> for
      more information). Finally, basic search functionality is available in
      the Properties Browser. Typing a search string in the
      <guilabel>Search</guilabel> field and pressing Enter will search all
      metadata in the current workspace, and display the results below with
      hyperlinks to each topic found.</para>

      <para>Under this is a bar displaying where the current page of metadata
      is in the tree. It also provides links to different sections of the
      current page of metadata. It is displayed in <xref
      linkend="FigurePropertiesBrowserNavigationBar" />:</para>

      <figure xml:id="FigurePropertiesBrowserNavigationBar">
        <title>Section of Properties Browser navigation bar</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/propertiesBrowserNavigationBar.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>This particular screenshot indicates that the metadata currently
      being viewed is for the <function>add</function> function. This function
      is a method of the <type>Num</type> type class, which is part of the
      <package>Prelude</package> module in the workspace. The
      <package>Workspace</package>, <package>Prelude</package> and
      <type>Num</type> text in this example provide links directly to each of
      these sections.</para>

      <para>The links in the second row of this section of the Properties
      Browser direct the user to different sections in the current page of
      metadata.</para>
    </section>

    <section xml:id="EditingMetadata">
      <title>Editing Metadata</title>

      <para>The Properties Browser provides an easy way to edit metadata for
      Gems and modules. This is a particularly useful feature when you are
      creating new Gems, and want to provide documentation about their
      functionality.</para>

      <para>To start editing the metadata of a Gem or module, open the
      Properties Browser to the page for the entity you want to edit, and
      click the <guibutton>Edit</guibutton> button in the toolbar.
      Alternatively, right-clicking on an entity in the Gem Browser window,
      and selecting the <menuchoice>
          <guimenuitem>Edit Properties</guimenuitem>
        </menuchoice> option from the context menu will open the Properties
      Browser in editing mode.</para>

      <para>Let’s take a look at an example of creating metadata for a newly
      designed Gem. In this example, a Gem called
      <function>nChooseR</function> has just been designed and saved to the
      <package>GemCutterSaveModule</package> module. The function of this Gem
      is to calculate the number of combinations of <parameter
      class="function">r</parameter> elements that can be selected from a
      group of <parameter class="function">n</parameter> elements. The Gem
      with its tooltips displayed is shown in <xref
      linkend="FigureNChooseRGemDefaultTooltips" />:</para>

      <figure xml:id="FigureNChooseRGemDefaultTooltips">
        <title><function>nChooseR</function> Gem with default tooltips</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/nChooseRGem.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Note that the default tooltips are not very informative. Adding
      metadata to this Gem is desirable, in part, because it will add
      information to these tooltips to better explain the functionality of the
      Gem to someone who has never used it before.</para>

      <para>Entering Edit mode, the Properties Browser looks like <xref
      linkend="FigurePropertiesBrowserEditMode" />:</para>

      <figure xml:id="FigurePropertiesBrowserEditMode">
        <title>Properties Browser in edit mode</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/propertiesBrowserNChooseRNew.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Each of the five sections listed can be expanded in order to edit
      the metadata contained within. Clicking on the <guilabel>Basic
      Properties</guilabel> option displays the pane in <xref
      linkend="FigureBasicPropertiesPanel" />:</para>

      <figure xml:id="FigureBasicPropertiesPanel">
        <title><guilabel>Basic Properties</guilabel> panel</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/basicProperties.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The <guilabel>Basic Properties</guilabel> section is used to edit
      basic information about the Gem. Editing each of the fields has the
      following effects:</para>

      <variablelist>
        <varlistentry>
          <term>Display Name</term>

          <listitem>
            <para>Changes the displayed name of the Gem in the Properties
            Browser. If nothing is entered, the displayed name defaults to the
            name given to the Gem when it was saved. This field is useful if
            it is desired to have a Gem with spaces in its name in metadata,
            something which the Gem Cutter does not allow in its name for a
            Gem.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Short Description</term>

          <listitem>
            <para>A brief description of the Gem. This description will be
            displayed as a tooltip when the mouse pointer is moved over the
            Gem in the Gem Browser or on the Table Top.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Long Description</term>

          <listitem>
            <para>A more detailed description of the Gem. This description
            will appear in the Properties Browser when viewing the Gem’s
            properties. It will also display as a tooltip if the
            <guilabel>Short Description</guilabel> section is left
            blank.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Author</term>

          <listitem>
            <para>The author of the Gem.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Version</term>

          <listitem>
            <para>The version of the Gem.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Preferred</term>

          <listitem>
            <para>Metadata attribute indicating if this is a “preferred” Gem –
            can be used by other applications to filter Gems.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Expert</term>

          <listitem>
            <para>Metadata attribute indicating if this is an “expert” Gem –
            can be used by other applications to filter Gems.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Related Features</term>

          <listitem>
            <para>A list of other Gem Cutter features that are related to the
            current entity being edited. Modules, types, type classes and Gems
            can be selected from the list on the left (the current workspace)
            and added to the list on the right, which represents this Gem’s
            related features.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Displayed in <xref
      linkend="FigureBasicPropertiesPanelMetadataEntered" /> is the pane after
      entering relevant information for the <function>nChooseR</function>
      Gem:</para>

      <figure xml:id="FigureBasicPropertiesPanelMetadataEntered">
        <title><guilabel>Basic Properties</guilabel> panel with metadata
        entered</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/basicPropertiesValuesEntered.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The next entry section is <guilabel>Gem Properties</guilabel>. The
      purpose of this section is to specify any categories the Gem is a part
      of. These categories can then be used by other applications that are
      organizing Gems by examining their metadata. To add a category, type its
      name in the box at the top and click the <guibutton>Add</guibutton>
      button. To remove a category from the list, select it and click the
      <guibutton>Remove</guibutton> button. <xref
      linkend="FigureGemPropertiesPanel" /> shows the <guilabel>Gem
      Properties</guilabel> panel after adding a category:</para>

      <figure xml:id="FigureGemPropertiesPanel">
        <title><guilabel>Gem Properties</guilabel> panel</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/gemProperties.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The <guilabel>Gem Arguments and Return Value</guilabel> section
      allows the user to modify metadata pertaining to the arguments and
      return value of the Gem. This is displayed in <xref
      linkend="FigureGemArgumentsReturnValuePanel" />:</para>

      <figure xml:id="FigureGemArgumentsReturnValuePanel">
        <title><guilabel>Gem Arguments and Return Value</guilabel>
        panel</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/gemArgumentsReturnValue.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>For each argument, a display name and short description can be
      entered. These two options function the same way for arguments as they
      do for Gems (see above). Clicking on the <guibutton>Edit Argument
      Properties...</guibutton> button will open up a whole new edit page for
      the argument, which will be similar to the page for Gems.</para>

      <para>The return type is the argument at the bottom, and can be given a
      short description that will appear as a tooltip.</para>

      <para>After entering results, the <guilabel>Gem Arguments and Return
      Value</guilabel> panel looks like <xref
      linkend="FigureGemArgumentsReturnValueMetadataEntered" /> for the
      <function>nChooseR</function> Gem:</para>

      <figure xml:id="FigureGemArgumentsReturnValueMetadataEntered">
        <title><guilabel>Gem Arguments and Return Value</guilabel> panel with
        metadata entered</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/gemArgumentsReturnValueMetadataEntered.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The next pane of data is titled <guilabel>Usage
      Examples</guilabel>. This section allows examples of code using this Gem
      to be displayed and calculated. Initially, this section is empty, as
      shown in <xref linkend="FigureUsageExamplesPanel" />:</para>

      <figure xml:id="FigureUsageExamplesPanel">
        <title><guilabel>Usage Examples</guilabel> panel</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/usageExamples.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Clicking on the <guibutton>New (<inlinemediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/new.gif"></imagedata>
          </imageobject>
        </inlinemediaobject>)</guibutton> button in the top right corner will
      add a new example to the section, shown in <xref
      linkend="FigureUsageExamplesNew" />:</para>

      <figure xml:id="FigureUsageExamplesNew">
        <title><guilabel>Usage Examples</guilabel> panel with new
        example</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/usageExamplesNew.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Notice that the section at the bottom appears similar to the Code
      Gem editor. A piece of CAL code can be entered here to demonstrate the
      functionality of the Gem. If the play button (green arrow) is pressed,
      the editor will display the result at the bottom of the pane, if
      possible. Our new usage example is shown in <xref
      linkend="FigureUsageExamplesCompleted" />:</para>

      <figure xml:id="FigureUsageExamplesCompleted">
        <title><guilabel>Usage Examples</guilabel> panel with completed
        example</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/usageExamplesCalculated.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The final pane that appears is the <guilabel>Custom
      Attributes</guilabel> pane. This pane allows custom pairs of names and
      values to be added to the Gem metadata. To add a custom attribute, click
      the <guibutton>New</guibutton> button, and enter a name and value for
      the attribute. We will not add any custom attributes to the
      <function>nChooseR</function> Gem.</para>

      <para>When editing of the Gem metadata is complete, click the
      <guibutton>Save</guibutton> button in the toolbar to save the metadata.
      Clicking the <guibutton>Close</guibutton> button will exit the metadata
      editor, and display the metadata panel for the
      <function>nChooseR</function> Gem, which should look like <xref
      linkend="FigureMetadataNChooseR" />:</para>

      <figure xml:id="FigureMetadataNChooseR">
        <title>Metadata for the <function>nChooseR</function> Gem</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/nChooseRMetadata.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>All the Gem metadata is now displayed in the standard format used
      by the Properties Browser. Also, <xref
      linkend="FigureNChooseRGemNewTooltips" /> shows the Gem with its
      tooltips displayed after updating the metadata:</para>

      <figure xml:id="FigureNChooseRGemNewTooltips">
        <title><function>nChooseR</function> Gem with new tooltips</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/nChooseRGemNewTooltips.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>This is now far more informative than the default tooltips for the
      Gem. The functionality of this Gem is now much clearer for someone who
      has never used this Gem before.</para>
    </section>
  </chapter>

  <chapter xml:id="MiscellaneousFeatures">
    <title>Miscellaneous Features</title>

    <para>This section describes a number of useful miscellaneous Gem Cutter
    features.</para>

    <section xml:id="RenamingEntities">
      <title>Renaming Entities</title>

      <para>The Gem Cutter can rename an existing Gem, type, type class or
      module, and update all workspace references to the entity being renamed
      in Gem definitions and in metadata. To use this feature, select the
      <menuchoice>
          <guimenu>Workspace</guimenu>

          <guimenuitem>Rename</guimenuitem>
        </menuchoice> menu option, and select the kind of entity to rename. A
      dialog will appear in which you can input the existing name of the
      entity to rename, and the new name. The Gem Cutter will then go through
      all source and metadata resources, and perform the requested
      change.</para>

      <para>An alternative way to accomplish this for Gems and modules is to
      right-click on the Gem or module to be renamed in the Gem Browser, and
      select the <menuchoice>
          <guimenuitem>Rename (Gem/Module)...</guimenuitem>
        </menuchoice> option from the context menu.</para>
    </section>

    <section xml:id="GeneratingEnumerations">
      <title>Generating Enumerations</title>

      <para>An enumeration is a type that contains a set of values that are
      part of the type, and whose data constructors have no arguments. To
      generate an enumeration, select the <menuchoice>
          <guimenu>Generate</guimenu>

          <guimenuitem>Enumeration...</guimenuitem>
        </menuchoice> menu option. This will display the dialog box in <xref
      linkend="FigureGenerateEnumerationDialog" />:</para>

      <figure xml:id="FigureGenerateEnumerationDialog">
        <title><guilabel>Generate Enumeration</guilabel> dialog box</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/generateEnumeration.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Entering an existing enumeration name will allow modification of
      the enumeration. Entering a new enumeration name will allow a new
      enumeration to be created. An enumeration is created by naming it, then
      adding values by entering them in the <guilabel>Value</guilabel> field
      and pressing the <guibutton>Add</guibutton> button.</para>

      <para>The <guilabel>Instances</guilabel> drop-down box is used to select
      which type classes the enumeration will implement. For example, if the
      enumeration implements <type>Prelude.Ord</type>, the elements in the
      enumeration will have an "order", and will be comparable with Gems such
      as <function>greaterThan</function> and
      <function>lessThan</function>.</para>

      <para>For example, suppose we want to create an enumeration called
      <type>Season</type> that will enumerate the seasons in the year. After
      entering the enumeration name and values, the dialog looks like <xref
      linkend="FigureGeneratingSeasonEnumeration" />:</para>

      <figure xml:id="FigureGeneratingSeasonEnumeration">
        <title>Generating a <type>Season</type> enumeration</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/generateEnumerationSeason.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Upon clicking <guibutton>OK</guibutton>, the enumeration is
      generated. A data constructor for each possible value in the enumeration
      is created and placed in the current module, as shown in the Gem Browser
      in <xref linkend="FigureSeasonEnumerationGemBrowser" />:</para>

      <figure xml:id="FigureSeasonEnumerationGemBrowser">
        <title><type>Season</type> enumeration in the Gem Browser</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/seasonEnumerationInGemBrowser.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para><xref linkend="FigureSpringDataConstructor" /> shows a sample data
      constructor for the enumeration:</para>

      <figure xml:id="FigureSpringDataConstructor">
        <title><type>Spring</type> data constructor</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/dataConstructorSpring.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The enumeration can now be used in the construction of new Gems.
      Also, note from <xref linkend="FigureValueGemSeason" /> that the
      enumeration is now a valid type to use in a Value Gem:</para>

      <figure xml:id="FigureValueGemSeason">
        <title>Value Gem representing the <type>Season</type> data
        type</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/valueGemSeason.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>
    </section>

    <section xml:id="CreatingNewMinimalWorkspaceDeclaration">
      <title>Creating a New Minimal Workspace Declaration</title>

      <para>The Gem Cutter provides a feature to create a new workspace
      declaration. To create a new workspace declaration, select the
      <menuchoice>
          <guimenu>Workspace</guimenu>

          <guimenuitem>Create Minimal Workspace Declaration...</guimenuitem>
        </menuchoice> option from the menu bar. The dialog in <xref
      linkend="FigureCreateMinimalWorkspaceDeclaration" /> will appear:</para>

      <figure xml:id="FigureCreateMinimalWorkspaceDeclaration">
        <title><guilabel>Create Minimal Workspace Declaration</guilabel>
        dialog box</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/createMinimalWorkspaceDeclarationDialog.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Suppose we want to create a workspace only containing the
      <package>List</package> module (the <package>Prelude</package> module
      will also be included, as it is required by all other modules). To do
      this, we enter a name for the workspace declaration file in the field at
      the top, or click the <guibutton>Browse...</guibutton> button to choose
      exactly where the workspace declaration file will be saved on the file
      system. Next, we check the box next to the <package>List</package>
      module in the <guilabel>Select Modules</guilabel> box. We can also check
      the checkbox at the bottom of the dialog to tell the Gem Cutter to
      switch to the new workspace immediately after it is created. The dialog
      now looks like <xref
      linkend="FigureCreatingMinimalWorkspaceListModule" />:</para>

      <figure xml:id="FigureCreatingMinimalWorkspaceListModule">
        <title>Creating a minimal workspace including the
        <package>List</package> module</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/createMinimalWorkspaceDeclarationList.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Clicking <guibutton>OK</guibutton> now generates the new workspace
      declaration file, and switches to the new workspace. The Gem Browser
      (<xref linkend="FigureNewMinimalWorkspaceGemBrowser" />) now shows the
      contents of the new workspace:</para>

      <figure xml:id="FigureNewMinimalWorkspaceGemBrowser">
        <title>New minimal workspace in the Gem Browser</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/minimalWorkspaceGemBrowser.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>
    </section>

    <section xml:id="SearchingModuleCode">
      <title>Searching Module Code</title>

      <para>The Gem Cutter has a search feature which can be used to search
      the CAL code of all modules. To open the search dialog, select the
      <menuchoice>
          <guimenu>Edit</guimenu>

          <guimenuitem>Search...</guimenuitem>
        </menuchoice> option from the menu bar, click the flashlight button on
      the toolbar, or press <accel>Ctrl+F</accel>. The search dialog shown in
      <xref linkend="FigureSearchDialog" /> will appear:</para>

      <figure xml:id="FigureSearchDialog">
        <title><guilabel>Search</guilabel> dialog box</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/searchDialog.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>To search for something, select the category of what to search for
      with the radio buttons, enter a search term in the field at the top of
      the dialog, and press <keycap function="enter">Enter</keycap>. The frame
      at the bottom of the window will display any occurrences of the entity
      that was searched for. <xref linkend="FigureUsingSearchDialog" /> shows
      an example:</para>

      <figure xml:id="FigureUsingSearchDialog">
        <title>Using the <guilabel>Search</guilabel> dialog box</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/searchExample.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Clicking on one of the items in the list of locations found will
      open a text editor displaying the contents of the module file at the
      selected line.</para>
    </section>

    <section xml:id="GenerateJDBCDataSource">
      <title>Generating a JDBC Data Source</title>

      <para>The Gem Cutter has a feature to allow easy creation of JDBC data
      sources. This is very useful for processing database records within the
      Gem Cutter. In order to use this feature you must first create a
      database connection gem. The easiest way to do this is to use the
      DataGems.jdbcConnectionWithDriverCheck gem. This gem has four inputs:
      <itemizedlist>
          <listitem>
            <para>JDBC driver location (fully qualified class name),</para>
          </listitem>

          <listitem>
            <para>the url of a JDBC database resource,</para>
          </listitem>

          <listitem>
            <para>the database login,</para>
          </listitem>

          <listitem>
            <para>and the database password.</para>
          </listitem>
        </itemizedlist> To make a new database connection add this gem and
      four value gems to the table top. Enter the four values for your
      database into the value gems, and connect them to the four inputs.
      Connect the output to the target gem. Rename the target gem to something
      that is appropriate for your database connection, and save it. An
      example database connection gem design is shown in <xref
      linkend="DataConnection" /> <figure xml:id="DataConnection">
          <title>Example Data Connection Gem Design</title>

          <screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="images/GemCutterManual/dataSource.png"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot>
        </figure></para>

      <para>Once you have created a database connection you are ready to
      create the JDBC datasource that uses it. To launch the graphical
      interface for the JDBC data source generator, select <menuchoice>
          <guimenu>Generate</guimenu>

          <guimenuitem>JDBC Data Source...</guimenuitem>
        </menuchoice> in the Gem Cutter.</para>

      <para>You should be presented with the dialog box shown in <xref
      linkend="FigureGenerateJDBC1" />:</para>

      <figure xml:id="FigureGenerateJDBC1">
        <title><guilabel>Generate JDBC Resultset Gem</guilabel> dialog
        box</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/generateJDBC1.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Enter an appropriate name for the data source and check the
      <guilabel>Include record extractor gem</guilabel> check box. This will
      create a gem that presents the data as a list of CAL records in addition
      to the default which is a ResultSet. Click <guilabel>Next</guilabel> and
      select the connection gem created above and the corresponding SQL
      builder gem for your database type. Click <guilabel>Next</guilabel> and
      select a table from the list displayed. Click <guilabel>Next</guilabel>
      and choose the table fields that you want to include. Click
      <guilabel>Next</guilabel> and select fields to use to sort the records,
      if desired. Click <guilabel>Next</guilabel> and you can review the SQL
      select statement that will be used to select data from your database.
      Click <guilabel>Next</guilabel> again and you will see a sample of the
      results obtained by running this query. Click
      <guilabel>Finish</guilabel> and two gems will be created in your current
      module. One will be of type ResultSet and the other will be a list of
      records.</para>
    </section>
  </chapter>

  <chapter xml:id="DocumentationGeneratorInGemCutter">
    <title>Using the Documentation Generator in the Gem Cutter</title>

    <para>The Quark Platform comes with a documentation generator for
    producing HTML documentation from CALDoc comments and metadata for the
    various entities in a CAL workspace. This generator can be accessed via a
    graphical interface in the Gem Cutter.</para>

    <para>To launch the graphical interface for the documentation generator,
    select <menuchoice>
        <guimenu>Generate</guimenu>

        <guimenuitem>CALDoc Documentation...</guimenuitem>
      </menuchoice> in the Gem Cutter.</para>

    <para>You should be presented with the dialog box in <xref
    linkend="FigureGenerateCALDocDocumentation" />:</para>

    <figure xml:id="FigureGenerateCALDocDocumentation">
      <title><guilabel>Generate CALDoc Documentation</guilabel> dialog
      box</title>

      <screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/GemCutterManual/generateCALDocDocumentation.png"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot>
    </figure>

    <para>This dialog box lists the options that can be specified for the
    generation of the documentation. Once the desired options have been
    specified, the generation process begins immediately upon clicking the
    <guibutton>OK</guibutton> button.</para>

    <section xml:id="CALDocGenerationOptions">
      <title>CALDoc Generation Options</title>

      <variablelist>
        <varlistentry>
          <term>Output Directory</term>

          <listitem>
            <figure xml:id="FigureOutputDirectory">
              <title><guilabel>Output Directory</guilabel> section</title>

              <screenshot>
                <mediaobject>
                  <imageobject>
                    <imagedata fileref="images/GemCutterManual/outputDirectory.png"></imagedata>
                  </imageobject>
                </mediaobject>
              </screenshot>
            </figure>

            <para>Specifies the output directory where the generator saves the
            generated HTML files. Leaving this option blank causes the files
            to be saved to the current directory. The directory can be
            absolute, or relative to the current working directory. The output
            directory is automatically created if it does not already
            exist.</para>

            <para>The <guibutton>Browse...</guibutton> button on the right
            launches a directory chooser for interactively selecting the
            output directory.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Scope</term>

          <listitem>
            <figure xml:id="FigureScope">
              <title><guilabel>Scope</guilabel> section</title>

              <screenshot>
                <mediaobject>
                  <imageobject>
                    <imagedata fileref="images/GemCutterManual/scope.png"></imagedata>
                  </imageobject>
                </mediaobject>
              </screenshot>
            </figure>

            <para>Specifies whether documentation should be generated for
            public entities only, or for all entities.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Filtering Options</term>

          <listitem>
            <figure xml:id="FigureFilteringOptions">
              <title>Filtering options section</title>

              <screenshot>
                <mediaobject>
                  <imageobject>
                    <imagedata fileref="images/GemCutterManual/filterOptions.png"></imagedata>
                  </imageobject>
                </mediaobject>
              </screenshot>
            </figure>

            <para>The five filtering options shown in <xref
            linkend="FigureFilteringOptions" /> provide the ability to control
            whether documentation should be generated for certain modules
            and/or certain entities. These filters can be applied in any
            combination.</para>

            <para>The first four filters are based on matching regular
            expressions. When the check box for one of these filters is
            selected, the corresponding field on the right is enabled to allow
            for specifying the regular expression to be used.</para>

            <para>The regular expressions are used in a case-sensitive manner
            by the filters.</para>

            <para>From top to bottom, these four filters are:</para>

            <itemizedlist>
              <listitem>
                <para><guilabel>Include only modules matching</guilabel>:
                <emphasis>(regular expression)</emphasis></para>

                <itemizedlist>
                  <listitem>
                    <para>The documentation generator will only generate
                    documentation for modules whose names match the specified
                    regular expression.</para>
                  </listitem>

                  <listitem>
                    <para>For example, specifying the regular expression
                    <code>File.*</code> would cause the generator to only
                    generate documentation for modules whose names begin with
                    the prefix <code>File</code>.</para>
                  </listitem>
                </itemizedlist>
              </listitem>

              <listitem>
                <para><guilabel>Exclude modules matching</guilabel>:
                <emphasis>(regular expression)</emphasis></para>

                <itemizedlist>
                  <listitem>
                    <para>The documentation generator will not generate
                    documentation for modules whose names match the specified
                    regular expression.</para>
                  </listitem>

                  <listitem>
                    <para>For example, specifying the regular expression
                    <code>.*_Tests</code> would cause the generator to exclude
                    from generation any module whose name ends with the suffix
                    <code>_Tests</code>.</para>
                  </listitem>
                </itemizedlist>
              </listitem>

              <listitem>
                <para><guilabel>Include only entities matching</guilabel>:
                <emphasis>(regular expression)</emphasis></para>

                <itemizedlist>
                  <listitem>
                    <para>The documentation generator will exclude from the
                    documentation any functions, data constructors, and class
                    methods whose names do not match the specified regular
                    expression.</para>
                  </listitem>
                </itemizedlist>
              </listitem>

              <listitem>
                <para><guilabel>Exclude entities matching</guilabel>:
                <emphasis>(regular expression)</emphasis></para>

                <itemizedlist>
                  <listitem>
                    <para>The documentation generator will exclude from the
                    documentation any functions, data constructors, and class
                    methods whose names match the specified regular
                    expression.</para>
                  </listitem>

                  <listitem>
                    <para>For example, specifying the regular expression
                    <code>(.*Example.*) | (.*example.*) | (.*test.*) |
                    (.*Test.*)</code> would cause the generator to exclude
                    entities whose names contain the string
                    <code>Example</code>, <code>example</code>,
                    <code>test</code>, or <code>Test</code>.</para>
                  </listitem>
                </itemizedlist>
              </listitem>
            </itemizedlist>

            <para>The fifth filtering option, <guilabel>Exclude test
            modules</guilabel>, indicates to the documentation generator that
            test modules are to be excluded from the generated documentation.
            A test module is defined to be a module whose source file has a
            directory named “test” as part of its path.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <simplesect>
        <title>Other Options</title>

        <variablelist>
          <varlistentry>
            <term>Include Metadata</term>

            <listitem>
              <para>This option selects whether or not to include CAL metadata
              in the generated documentation.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Hide CALDoc overridden by corresponding metadata</term>

            <listitem>
              <para>This option specifies that the CALDoc for a CAL entity
              should not be included in the documentation if the corresponding
              metadata is present. This option is only enabled if the
              <guilabel>Include Metadata</guilabel> option is selected.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Generate author info</term>

            <listitem>
              <para>Specifies that author information should be included in
              the generated documentation.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Generate version info</term>

            <listitem>
              <para>Specifies that version information should be included in
              the generated documentation.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Always display Prelude names unqualified</term>

            <listitem>
              <para>Specifies that the names of <package>Prelude</package>
              entities should always be shown in their unqualified form, e.g.
              displaying <type>Int</type> rather than <type>Prelude.Int</type>
              throughout the generated documentation.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Generate usage indices</term>

            <listitem>
              <para>Specifies that one usage page should be generated for each
              documented type and type class. The page describes which
              functions, data constructors, and class methods refer to the
              type/type class in their type signatures, as well as any
              associated class instances.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Separate instance documentation from main documentation
            pages</term>

            <listitem>
              <para>Specifies that documentation for instances should be
              generated as separate HTML pages, instead of being included with
              the main documentation pages.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Window title</term>

            <listitem>
              <para>Specifies the title to be placed in the HTML &lt;title&gt;
              tag. This appears in the window title and in any browser
              bookmarks (favorite places) that someone creates for this page.
              This title should not contain any HTML tags, as the browser will
              not properly interpret them.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Documentation title</term>

            <listitem>
              <para>Specifies the title to be placed near the top of the
              overview file. The title may contain HTML tags and white
              space.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Header text</term>

            <listitem>
              <para>Specifies the header text to be placed at the top of each
              output file. The header will be placed just below the upper
              navigation bar. The text may contain HTML tags and white
              space.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Footer text</term>

            <listitem>
              <para>Specifies the footer text to be placed at the bottom of
              each output file. The footer will be placed just above the lower
              navigation bar. The text may contain HTML tags and white
              space.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Bottom text</term>

            <listitem>
              <para>Specifies the fine-print text to be placed at the bottom
              of each output file. The text will be placed at the bottom of
              the page, below the lower navigation bar. The text may contain
              HTML tags and white space.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </simplesect>
    </section>
  </chapter>

  <chapter xml:id="GeneratingGemsFromJavaCode">
    <title>Generating Gems From Java Code</title>

    <para>The Gem Cutter has the ability to create Gems by importing Java
    classes, methods and fields.</para>

    <section xml:id="CreatingCALTypeFromJavaClass">
      <title>Creating a CAL Type From a Java Class</title>

      <para>The Gem Cutter provides an easy way to create a data type for an
      existing Java class. To import a single type into the current module in
      the Gem Cutter, select the open the “Generate” menu and select the “Java
      Data Type…” option. This will display the dialog in <xref
      linkend="FigureGenerateJavaDataTypeDialog" />:</para>

      <figure xml:id="FigureGenerateJavaDataTypeDialog">
        <title>Generate Java Data Type dialog box</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/generateJavaDataType.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The next step is to enter the name of the class to be imported. As
      characters are typed, the Gem Cutter searches for Java classes with
      names matching the typed string. For example, suppose we want to import
      the <classname>java.util.Stack</classname> class and create a data type
      for it in the Gem Cutter. Typing <userinput>Stack</userinput> in the
      <guilabel>Class Name</guilabel> box causes the program to display a
      drop-down list of the classes found, shown in <xref
      linkend="FigureSelectingClassToImport" />:</para>

      <figure xml:id="FigureSelectingClassToImport">
        <title>Selecting a class to import</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/importingClassName.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Selecting the desired class from the list updates the
      <guilabel>Members</guilabel> field with the available constructors for
      this data type. The Gem Cutter also suggests a name for the data type in
      the <guilabel>Type Name</guilabel> field, shown in <xref
      linkend="FigureSelectingStackClass" />:</para>

      <figure xml:id="FigureSelectingStackClass">
        <title>Selecting the <classname>java.util.Stack</classname>
        class</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/generateJavaDataTypeStack.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>A constructor must be chosen to use from this class. A Gem will be
      generated to represent this constructor in the Gem Cutter, taking
      whatever input arguments the constructor requires and outputting an
      object of the new type. In this case, only one constructor is available,
      so we select it. A short comment about this data type can also be added,
      as shown in <xref
      linkend="FigureSelectingConstructorAddingComment" />:</para>

      <figure xml:id="FigureSelectingConstructorAddingComment">
        <title>Selecting a constructor and adding a comment to an imported
        class</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/generateJavaDataTypeComplete.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Clicking “OK” will now import the data type and create a new Gem.
      In this case, a Gem named <function>makeJStack</function> has been
      created in the current module, displayed in <xref
      linkend="FigureGemBrowserNewMakeJStackGem" />.</para>

      <figure xml:id="FigureGemBrowserNewMakeJStackGem">
        <title>Gem Browser with newly created <function>makeJStack</function>
        Gem</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/gemBrowserMakeJStackGem.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>This Gem (in <xref linkend="FigureMakeJStackGem" />) represents
      the default constructor for the Stack class, which now has the type
      JStack in the Gem Cutter.</para>

      <figure xml:id="FigureMakeJStackGem">
        <title><function>makeJStack</function> Gem</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/makeJStackGem.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>
    </section>

    <section xml:id="ImportingJavaMethodsAndFields">
      <title>Importing Java Methods and Fields</title>

      <para>Importing methods and fields from Java classes is similar to
      importing classes into the Gem Cutter as types. To continue the previous
      example, suppose we want to import the method
      <function>empty()</function> in the
      <classname>java.util.Stack</classname> class. First, select <menuchoice>
          <guimenu>Generate</guimenu>

          <guimenuitem>Java Method or Field...</guimenuitem>
        </menuchoice> which will open the dialog box in <xref
      linkend="FigureGenerateJavaMethodOrFieldDialog" />:</para>

      <figure xml:id="FigureGenerateJavaMethodOrFieldDialog">
        <title>Generate Java Method or Field dialog box</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/generateJavaMethodOrField.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Entering <userinput>Stack</userinput> and selecting
      <classname>java.util.Stack</classname> in the <guilabel>Class
      Name</guilabel> field displays a list of the available methods and
      fields in the <guilabel>Members</guilabel> box. Scrolling down the list
      and clicking on the <function>empty()</function> method, we see that the
      Gem Cutter has created a default name for the Gem to be created, shown
      in <xref linkend="FigureGenerateJavaMethodStackEmpty" />:</para>

      <figure xml:id="FigureGenerateJavaMethodStackEmpty">
        <title>Importing the <function>empty()</function> method from
        <classname>java.util.Stack</classname></title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/generateJavaMethodOrFieldStackEmpty.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>Clicking the <guibutton>OK</guibutton> button will now create our
      Gem in the currently open module, as displayed in <xref
      linkend="FigureGemBrowserJUtilStackEmptyGem" />.</para>

      <figure xml:id="FigureGemBrowserJUtilStackEmptyGem">
        <title>Gem Browser with newly created
        <function>jUtilStack_empty</function> Gem</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/gemBrowserJUtilStack_empty.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The Gem looks like <xref
      linkend="FigureJUtilStackEmptyGem" />:</para>

      <figure xml:id="FigureJUtilStackEmptyGem">
        <title><function>jUtilStack_empty</function> Gem</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/jUtilStack_EmptyGem.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>There are now two Gems related to the <type>JStack</type> type in
      the current workspace. A simple thing to try now is creating a
      <type>JStack</type>, and then checking that it is empty. Placing a
      <function>makeJStack</function> Gem and a
      <function>jUtilStack_empty</function> Gem on the Table Top and
      connecting them as shown in <xref
      linkend="FigureTestingJUtilStackEmptyGem" />, we can run the resulting
      function and check that the new stack is in fact empty:</para>

      <figure xml:id="FigureTestingJUtilStackEmptyGem">
        <title>Testing the <function>jUtilStack_empty</function> Gem</title>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/GemCutterManual/testStackEmpty.png"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot>
      </figure>

      <para>The result is that the stack is empty, as expected.</para>
    </section>

    <section xml:id="GeneratingAForeignImportModule">
      <title>Generating a Foreign Import Module</title>

      <para>The Gem Cutter is capable of generating a new module from a
      collection of existing Java classes and their members.</para>

      &jfit;
    </section>
  </chapter>

  <chapter xml:id="UnderstandingTypeExpressions">
    <title>Understanding Type Expressions</title>

    <para>This section provides a basic overview of type expressions as they
    pertain to the CAL language in the Gem Cutter. For more information on
    type expressions, refer to the CAL User’s Guide document.</para>

    <para>Type expressions are fairly straightforward to decode. They describe
    a type in a concise textual form. For functions, Type Expressions deal
    with describing the 'type contract' of the function, which can be broken
    down into types for each input and the output. We have to be careful in
    our interpretation of how we assume a function will get evaluated from
    looking at its Type Expression.</para>

    <para>First of all, let’s consider the types of some simple values:</para>

    <informaltable>
      <tgroup cols="2">
        <thead>
          <row>
            <entry align="center">Type Expression</entry>

            <entry align="center">Meaning</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><type>Boolean</type></entry>

            <entry>A boolean value</entry>
          </row>

          <row>
            <entry><type>Char</type></entry>

            <entry>A character</entry>
          </row>

          <row>
            <entry><type>Double</type></entry>

            <entry>A double precision floating point number</entry>
          </row>

          <row>
            <entry><type>a</type></entry>

            <entry>A type variable, meaning 'any type'</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>These type expressions are simple examples and therefore easy to
    understand. These types, especially the first three, should look familiar.
    The first example, the type variable, may be unfamiliar however. Type
    variables are very powerful as they allow us to describe whole groups of
    types where all the type variables with the same letter can be replaced
    with any one type expression.</para>

    <para>The next examples of types are some built-in types with special
    syntax:</para>

    <informaltable>
      <tgroup cols="2">
        <thead>
          <row>
            <entry align="center">Type Expression</entry>

            <entry align="center">Meaning</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><type>[a]</type></entry>

            <entry>A list of values. Every value is of type
            <type>a</type></entry>
          </row>

          <row>
            <entry><type>(a,b)</type></entry>

            <entry>A pair of values. The first value is of type
            <type>a</type>, the second value is of type <type>b</type></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>These will often have their type variables set to actual types as we
    mentioned above. For instance, a list of <type>Boolean</type> values will
    be <type>[Boolean]</type>, and a pair of floating point values would be
    <type>(Double, Double)</type>.</para>

    <para>Types can include type class constraints. A type class is a set of
    types which conform to having certain functions defined over them. Gems
    are then defined that accept any type in a type class as input, and
    perform an operation which makes sense for every type that is a member of
    the type class. For example, the <type>Num</type> type class has instances
    <type>Int</type> and <type>Double</type> (among others) and has all the
    simple arithmetic functions defined. By using the <type>Num</type> type
    class we can provide a single <function>add</function> Gem which will
    accept as input any members of the <type>Num</type> type class, including
    <type>Int</type> and <type>Double</type>.</para>

    <para>Here are some examples of type class constrained type
    expressions:</para>

    <informaltable>
      <tgroup cols="2">
        <thead>
          <row>
            <entry align="center">Type Expression</entry>

            <entry align="center">Meaning</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><type>Num a =&gt; a</type></entry>

            <entry>A value which conforms to being a <type>Num</type>
            (number). Some examples of member types of <type>Num</type> are
            <type>Int</type> and <type>Double</type>, meaning that
            <type>a</type> can be an <type>Int</type> or a
            <type>Double</type>.</entry>
          </row>

          <row>
            <entry><type>Ord a =&gt; a</type></entry>

            <entry>A value which conforms to being an orderable type, meaning
            one that supports ordering functions. Some examples of member
            types of <type>Ord</type> are <type>Int</type>,
            <type>String</type> and <type>Time</type>.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>User defined types (and types for which there are no special
    syntactic treatments) are just described in type expressions by their type
    names. Here are some examples:</para>

    <informaltable>
      <tgroup cols="2">
        <thead>
          <row>
            <entry align="center">Type Expression</entry>

            <entry align="center">Meaning</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><type>Maybe a</type></entry>

            <entry>A <type>Maybe</type> type (from the standard
            <package>Prelude</package>).</entry>
          </row>

          <row>
            <entry><type>Ordering</type></entry>

            <entry>An enumeration of ordering relationships.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>Finally, functions are described by their type expressions. Here are
    some examples:</para>

    <informaltable>
      <tgroup cols="2">
        <thead>
          <row>
            <entry align="center">Type Expression</entry>

            <entry align="center">Meaning</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><type>Int -&gt; Int -&gt; Int</type></entry>

            <entry>A function which takes an integer, then another integer and
            produces an integer</entry>
          </row>

          <row>
            <entry><type>[Char] -&gt; Int -&gt; Char</type></entry>

            <entry>A function which takes a list of characters, then an
            integer and produces a character</entry>
          </row>

          <row>
            <entry><type>Ord a =&gt; a -&gt; a -&gt; a</type></entry>

            <entry>A function which takes two orderable values and returns an
            orderable value</entry>
          </row>

          <row>
            <entry><type>(a -&gt; Boolean) -&gt; [a] -&gt; [a]</type></entry>

            <entry>A function which takes a function (which takes any type and
            returns a boolean value) and a list of any type, and which returns
            a list of any type. All the 'any types' must be the same when this
            type is used.</entry>
          </row>

          <row>
            <entry><type>(a -&gt; b) -&gt; [a] -&gt; [b]</type></entry>

            <entry>A function which takes another function (which takes one
            'any type' and returns another 'any type') and a list of any type,
            and that returns a list of any type. Notice that in this case,
            whatever type the first argument of the provided function is must
            be the same type as the elements of the list in the second
            argument. Also, whatever type the second argument of the provided
            function is must be the same type as the elements of the returned
            list.</entry>
          </row>

          <row>
            <entry><type>(Ord a, Eq b) =&gt; (a,b) -&gt; [a] -&gt;
            b</type></entry>

            <entry>A function which takes a pair of values, the first of which
            is a member of the type class <type>Ord</type>, and the second is
            a member of the type class <type>Eq</type>. The function also
            takes a list of values whose type is the same as for the first
            value in the pair. The function returns a value typed the same as
            the second value in the pair.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
  </chapter>

  <glossary xml:id="Glossary">
    <glossdiv>
      <title>Terms</title>

      <glossentry xml:id="GlossaryArity">
        <glossterm>Arity</glossterm>

        <glossdef>
          <para>The number of arguments that this function will consume in
          order to fully evaluate.</para>
        </glossdef>
      </glossentry>

      <glossentry xml:id="GlossaryCAL">
        <glossterm>CAL</glossterm>

        <glossdef>
          <para>This is the native language used by Business Objects Gems. The
          language is a functional language. This means that every entity in
          the language is a function. Functions can be passed as arguments,
          and returned by other functions.</para>
        </glossdef>
      </glossentry>

      <glossentry xml:id="GlossaryCodeGem">
        <glossterm>Code Gem</glossterm>

        <glossdef>
          <para>A green Gem that allows the user to input CAL code to
          implement the functionality of the Gem.</para>

          <glossseealso otherterm="GlossaryGem">Gem</glossseealso>

          <glossseealso otherterm="GlossaryCAL">CAL</glossseealso>
        </glossdef>
      </glossentry>

      <glossentry xml:id="GlossaryCollector">
        <glossterm>Collector</glossterm>

        <glossdef>
          <para>A black Gem that receives a value and gives it a local name.
          This value can then be output to other Gems using Emitters.</para>

          <glossseealso otherterm="GlossaryEmitter">Emitter</glossseealso>

          <glossseealso otherterm="GlossaryGem">Gem</glossseealso>
        </glossdef>
      </glossentry>

      <glossentry xml:id="GlossaryConstructor">
        <glossterm>Constructor</glossterm>

        <glosssee otherterm="GlossaryDataConstructor">Data
        Constructor</glosssee>
      </glossentry>

      <glossentry xml:id="GlossaryDataConstructor">
        <glossterm>Data Constructor</glossterm>

        <glossdef>
          <para>A Data Constructor is an identifier which is used in CAL to
          build values of a specific type. Constructors behave like functions,
          usually taking some simpler typed values and creating an instance of
          a more abstract type (although there are many constructors taking no
          'arguments'). To differentiate them from functions, constructors
          have capitalised names.</para>

          <para>For example, to create a <type>Maybe</type> type representing
          a <type>Double</type> value that exists, the
          <function>Just</function> data constructor can be used in the
          following manner:</para>

          <para><code language="CAL">Just 5.4</code></para>

          <para>Data constructors are defined in data definitions in the CAL
          language.</para>

          <glossseealso otherterm="GlossaryCAL">CAL</glossseealso>

          <glossseealso otherterm="GlossaryFunction">Function</glossseealso>
        </glossdef>
      </glossentry>

      <glossentry xml:id="GlossaryEmitter">
        <glossterm>Emitter</glossterm>

        <glossdef>
          <para>A white Gem used to output the value represented by a local
          variable. A Collector must be placed on the Table Top before a
          corresponding Emitter can be created and used.</para>

          <glossseealso otherterm="GlossaryCollector">Collector</glossseealso>

          <glossseealso otherterm="GlossaryGem">Gem</glossseealso>
        </glossdef>
      </glossentry>

      <glossentry xml:id="GlossaryFunction">
        <glossterm>Function</glossterm>

        <glossdef>
          <para>A mathematical concept which maps a set of values onto another
          set. In standard programming languages functions are usually
          considered to be routines that perform some computation and return a
          value. CAL, being a functional language, takes a more pure approach
          to functions and is able to manipulate functions as data. In fact,
          conceptually, everything in the CAL language is a function and has
          the same treatment. This makes for a simple language, yet one with
          very powerful features for transforming data and describing
          analysis.</para>

          <glossseealso otherterm="GlossaryCAL">CAL</glossseealso>
        </glossdef>
      </glossentry>

      <glossentry xml:id="GlossaryGem">
        <glossterm>Gem</glossterm>

        <glossdef>
          <para>The representation of a CAL function. A Gem can represent a
          specific slice of data (possibly with a dynamic meaning), or some
          business logic without association to specific data. Gems can
          transform, filter or abstract data in any way. Gems are combinable
          in a completely 'type safe' manner. This means that it is not
          possible to produce abstractions that have invalid or ambiguous
          meanings in the way that they consume or produce data.</para>

          <glossseealso otherterm="GlossaryCAL">CAL</glossseealso>
        </glossdef>
      </glossentry>

      <glossentry xml:id="GlossaryGemBrowser">
        <glossterm>Gem Browser</glossterm>

        <glossdef>
          <para>The window allowing the user to browse for Gems in the current
          workspace. The Gem Browser allows Gems to be arranged in many
          different ways, and the user can also use it to search for Gems by
          name.</para>

          <glossseealso otherterm="GlossaryGem">Gem</glossseealso>
        </glossdef>
      </glossentry>

      <glossentry xml:id="GlossaryGemCutter">
        <glossterm>Gem Cutter</glossterm>

        <glossdef>
          <para>The graphical design tool for Gems.</para>

          <glossseealso otherterm="GlossaryGem">Gem</glossseealso>
        </glossdef>
      </glossentry>

      <glossentry xml:id="GlossaryIntelliCut">
        <glossterm>IntelliCut</glossterm>

        <glossdef>
          <para>A feature of the Gem Cutter designed to help the user find
          Gems and connections that are appropriate to make, based on the
          current state of the Table Top. Possible connections will be
          indicated to the user with dotted lines, and a list of connectible
          Gems will be displayed. The IntelliCut feature can be enabled or
          disabled via the <menuchoice>
              <guimenu>View</guimenu>

              <guimenuitem>Preferences</guimenuitem>
            </menuchoice> menu option.</para>
        </glossdef>
      </glossentry>

      <glossentry xml:id="GlossaryLocalFunction">
        <glossterm>Local Function</glossterm>

        <glossdef>
          <para>A named 'inner' function definition which is restricted in
          scope to the definition of a single function. Local function
          definitions are useful to break the definition of a complex function
          into smaller pieces. Local functions are defined by <code
          language="CAL">let</code> expressions in CAL.</para>

          <glossseealso otherterm="GlossaryCAL">CAL</glossseealso>
        </glossdef>
      </glossentry>

      <glossentry xml:id="GlossaryLocalVariable">
        <glossterm>Local Variable</glossterm>

        <glossdef>
          <para>A variable definition which is restricted in scope to the
          definition of a single function. Local variables are useful to break
          the definition of a complex function into smaller pieces. Local
          variables are defined by <code language="CAL">let</code> expressions
          in CAL, whereby a value is assigned to the variable identifier. Once
          assigned, local variables are immutable. Local variables are the
          only kind of variable in CAL, which has no concept of global,
          shared, or mutable variables.</para>

          <glossseealso otherterm="GlossaryCAL">CAL</glossseealso>
        </glossdef>
      </glossentry>

      <glossentry xml:id="GlossaryModule">
        <glossterm>Module</glossterm>

        <glossdef>
          <para>The organising principle for the CAL language. Similar to the
          concept of a package in other languages, a module is a collection of
          data types and functions that are designed for a particular purpose
          (or for which it makes sense to collect them together). The module
          also acts a boundary for scope and visibility, allowing items to be
          declared as private and thus only visible within the module itself.
          This greatly helps to avoid namespace pollution and in helping to
          establish an overt intent for the usage of items within the module.
          Modules can be imported into one another which permits the public
          members of the imported module to be visible within the importing
          module.</para>

          <glossseealso otherterm="GlossaryCAL">CAL</glossseealso>
        </glossdef>
      </glossentry>

      <glossentry xml:id="GlossaryOperator">
        <glossterm>Operator</glossterm>

        <glossdef>
          <para>An operator is a function which can be used inline in CAL
          syntax. Functions are normally applied with prefix fixity (i.e. the
          function name comes first, followed by its arguments). However, this
          is inconvenient in cases where the functions are usually written
          with different fixity, the most common case of which are the inline
          numeric operators (e.g. <code>+-/*</code>).</para>

          <glossseealso otherterm="GlossaryFunction">Function</glossseealso>

          <glossseealso otherterm="GlossaryCAL">CAL</glossseealso>
        </glossdef>
      </glossentry>

      <glossentry xml:id="GlossaryParametric">
        <glossterm>Parametric</glossterm>

        <glossdef>
          <para>An expression that is based on the value of a variable.
          Referring to type expressions, this implies that the type is
          generalised and can be made more specific by setting the value of
          the variable.</para>

          <para>For example:</para>

          <para><code language="CAL">data List a = Nil | Cons a (List
          a);</code></para>

          <para>This means that a <type>List</type> of 'a' is either the empty
          list (<varname>Nil</varname>) or a list construction consisting of
          an 'a' and a <type>List</type> of 'a's</para>

          <glossseealso otherterm="GlossaryTypeVariable">Type
          Variable</glossseealso>
        </glossdef>
      </glossentry>

      <glossentry xml:id="GlossaryPartialEvaluation">
        <glossterm>Partial Evaluation</glossterm>

        <glossdef>
          <para>CAL is a functional language which has the property of being
          able to partially evaluate functions and return other functions in
          the case where not all the input arguments are provided (i.e.
          applied arguments &lt; arity).</para>

          <glossseealso otherterm="GlossaryArity">Arity</glossseealso>

          <glossseealso otherterm="GlossaryFunction">Function</glossseealso>

          <glossseealso otherterm="GlossaryCAL">CAL</glossseealso>
        </glossdef>
      </glossentry>

      <glossentry xml:id="GlossaryPolymorphism">
        <glossterm>Polymorphism</glossterm>

        <glossdef>
          <para>Able to deal with multiple types. All functions in CAL (and
          hence Gems) are implicitly polymorphic. For example, the type
          expression of the function <function>length</function> is:</para>

          <para><code language="CAL">length :: [a] -&gt; Int; </code></para>

          <para>This tells us that <function>length</function> takes a list of
          'anything' and returns a <type>Double</type> (double precision
          floating point number). This implies that
          <function>length</function> will work on any list type.</para>

          <glossseealso otherterm="GlossaryFunction">Function</glossseealso>

          <glossseealso otherterm="GlossaryCAL">CAL</glossseealso>

          <glossseealso otherterm="GlossaryTypeExpression">Type
          Expression</glossseealso>
        </glossdef>
      </glossentry>

      <glossentry xml:id="GlossaryPrelude">
        <glossterm>Prelude</glossterm>

        <glossdef>
          <para>The fundamental standard library for CAL which provides data
          type and function primitives for writing CAL programs. The Prelude
          is included and compiled before other user CAL code and is the basis
          on which other code is commonly built. Other CAL libraries use the
          standard facilities offered by Prelude.</para>

          <glossseealso otherterm="GlossaryCAL">CAL</glossseealso>
        </glossdef>
      </glossentry>

      <glossentry>
        <glossterm>Record Creation Gem</glossterm>

        <glossdef>
          <para>A magenta triangular Gem used to create a record value.</para>

          <glossseealso otherterm="GlossaryGem">Gem</glossseealso>
        </glossdef>
      </glossentry>

      <glossentry>
        <glossterm>Record Field Selection Gem</glossterm>

        <glossdef>
          <para>A purple triangular Gem used to select a field from a
          record.</para>

          <glossseealso otherterm="GlossaryGem">Gem</glossseealso>
        </glossdef>
      </glossentry>

      <glossentry xml:id="GlossaryType">
        <glossterm>Type</glossterm>

        <glossdef>
          <para>A description of the kind of values that are legal for a
          variable. A type represents a set of values that, taken together,
          make up the type. For example, the <type>Integer</type> type
          represents the set of all integers. We can test whether types are
          compatible by checking if one set is a pure subset of the
          other.</para>

          <glossseealso otherterm="GlossaryTypeVariable">Type
          Variable</glossseealso>
        </glossdef>
      </glossentry>

      <glossentry xml:id="GlossaryTypeExpression">
        <glossterm>Type Expression</glossterm>

        <glossdef>
          <para>An expression formalism for describing types. For
          example:</para>

          <para><code>[Double]</code> A list of double precision floating
          point numbers</para>

          <para><code>(Season-&gt;Temp)</code> A function taking a
          <type>Season</type> and returning a <type>Temp</type></para>

          <glossseealso otherterm="GlossaryType">Type</glossseealso>
        </glossdef>
      </glossentry>

      <glossentry>
        <glossterm>Type Unification</glossterm>

        <glosssee otherterm="GlossaryUnification">Unification</glosssee>
      </glossentry>

      <glossentry xml:id="GlossaryTypeVariable">
        <glossterm>Type Variable</glossterm>

        <glossdef>
          <para>A variable used in a type expression. These are normally
          identified by single letter names (a,b,c...). They mean that any
          type can be used to substitute for their location, but when this
          happens, the same type must be used for all occurrences of the given
          variable in the single type expression.</para>

          <glossseealso otherterm="GlossaryType">Type</glossseealso>

          <glossseealso otherterm="GlossaryTypeExpression">Type
          Expression</glossseealso>
        </glossdef>
      </glossentry>

      <glossentry xml:id="GlossaryUnification">
        <glossterm>Unification</glossterm>

        <glossdef>
          <para>The act of merging two or more entities into a single entity
          which can represent all cases of the original set.</para>

          <para>Unification is the process by which two types are converted
          into one where the new type is compatible with both the original
          types. Incompatible types cannot be unified and this results in a
          typing error.</para>
        </glossdef>
      </glossentry>

      <glossentry xml:id="GlossaryValueGem">
        <glossterm>Value Gem</glossterm>

        <glossdef>
          <para>A blue Gem that defines a constant value.</para>

          <glossseealso otherterm="GlossaryGem">Gem</glossseealso>
        </glossdef>
      </glossentry>
    </glossdiv>
  </glossary>
</book>