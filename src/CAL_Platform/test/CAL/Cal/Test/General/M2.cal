/*
 * Copyright (c) 2007 BUSINESS OBJECTS SOFTWARE LIMITED
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *  
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *  
 *     * Neither the name of Business Objects nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *  
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


/*
 * M2.cal
 * Creation date: Feb 28, 2003.
 * By: Edward Lam
 */

/**
 * This module contains test cases for CAL. It was the second module written in CAL, and hence its 
 * glorious name M2.
 * 
 * Note: it is not intended to be "model" CAL code. In particular, there are many pathological examples
 * here mainly intended to test boundary cases, and a variety of commented out examples intended to test
 * that errors are caught and properly reported.
 *
 * @author Bo Ilic
 */
module Cal.Test.General.M2;
import Cal.Core.Prelude using
    function = remainder, id, seq, error, add, upFromTo, upFromThen, upFromThenTo, or, not, and, equals, 
        greaterThan, snd, compose, fst, upFrom, isEven, field3, compare, minBound, maxBound, max, min, 
        input, output;
    typeConstructor = Byte, Float, Short, Int, Double, String, Boolean, Maybe, Ordering, Char, Long, JObject, JList, CalValue;
    dataConstructor = Cons, True, False, Nothing, Just, LT, EQ, GT, Left, Right;
    typeClass = Eq, Ord, Num, Bounded, Enum, Typeable;
    function = abs, toDouble, typeOf, unsafeCoerce, assert, eager;    
    typeClass = Outputable, Inputable;
    
    typeConstructor = Integer, TypeRep;
    function = undefined, fromJust, 
        isListType, isRecordType, isDoubleType, deepSeq;
    ;
import Cal.Utilities.Math using
    function = sin, cos, sqrt;
    ;
import Cal.Core.Char;    
import Cal.Core.Dynamic using
    typeConstructor = Dynamic;
    function = appendRecord, appendDynamicRecord, insertRecordField, insertDynamicRecordField, recordFieldValue, dynamicRecordFieldValue;
    function = fromDynamic, dynamicRecordFieldValues, dynamicUnderlyingType, fromDynamicList, toDynamic;
    ;

import Cal.Collections.List using
    function = head, last, map, filter, replicate, sortBy, foldLeftStrict, foldRight, repeat, length, zip, 
        isElemBy, drop, take, partition, foldLeft, sum, unzip3, groupBy, unzip, subscript, concatMap;
    function = inputList, outputList;
    ;
import Cal.Core.String using
    function = toList;
    ;
import Cal.Core.Debug using
    typeClass = Show;
    function =
        show, trace, showInternal, showInternalGraph, internalValueStats, 
        setTracingEnabled, traceOnStdOut;
    ;
import Cal.Test.Core.Debug_Tests;    
import Cal.Test.General.M1;
import Cal.Test.General.Nofib;
import Cal.Test.General.GemScopeTestModule using
    function = regressionLine, regression, predictAt;
    ;
import Cal.Utilities.Decimal;
import Cal.Test.General.RecordTests;
import Cal.Test.General.LegacyTuple;
import Cal.Test.General.RuntimeRegression;
import Cal.Test.General.Shape_Tests;
import Cal.Test.General.InliningTests; 	
import Cal.Collections.Array using
    typeConstructor = Array;
    ;
import Cal.Test.Core.Prelude_Tests;
import Cal.Test.Core.String_Tests;
import Cal.Test.Collections.List_Tests;
import Cal.Test.Core.Array_Tests;
import Cal.Test.Core.Bits_Tests;
import Cal.Test.Core.Char_Tests;
import Cal.Test.Utilities.Decimal_Tests;
import Cal.Test.Utilities.QuickCheck_Tests;
import Cal.Test.Core.Dynamic_Tests;
import Cal.Test.Core.Memoize_Tests;
import Cal.Utilities.Random using
    function = randomInts;
    ;
import Cal.Test.Utilities.Random_Tests;    

import Cal.Test.JUnitSupport.DerivedInstanceFunctionGenerator_Test_Support using
    function =
        testOrdInstanceWithValuesInAccendingOrder, testBoundedInstanceWithValuesInAccendingOrder, testEnumInstanceWithValuesInAccendingOrder;
    ;

import Cal.Test.Collections.IntMap_Tests;
import Cal.Test.Collections.LongMap_Tests;
import Cal.Test.Collections.Map_Tests;
import Cal.Test.Collections.Set_Tests;
import Cal.Test.Core.Monad_Tests;
import Cal.Test.Core.Functor_Tests;
import Cal.Test.Core.System_Tests;
import Cal.Test.Utilities.Locale_Tests;
import Cal.Test.Utilities.MessageFormat_Tests;
import Cal.Test.Core.Exception_Tests;
import Cal.Test.Core.Record_Tests;

import Cal.Core.Exception using
    typeClass = Exception;
    function = catch;
    ;

//solves the quadratic equation a*x^2 + b*x + c = 0
quadraticEquationSolver a b c =
    let
        disc = sqrt (b*b - 4 * a *c);
    in
        ((-b + disc) / (2*a), (-b - disc) / (2 * a));

//an infinite list of ones.        
ones :: [Double];
ones = 1.0 : ones;
            
//the Fibonnacci numbers             
fibs :: [Int ];
fibs = 1 : 1 : List.zipWith Prelude.add fibs (List.tail fibs);
        
fib :: Int -> Int;        
fib n = List.subscript fibs n;

//test referring to the main test supercombinator of the Prelude
test1 = Prelude.testPreludeModule;

//test using unqualified Prelude scs, both built-in and not
test2 = Prelude.id 20.0 * Math.sqrt 9.0 == 60.0;

//test using qualified Prelude scs, both built-in and not
test3 = Prelude.id 20.0 * Math.sqrt 16.0 == 80.0;

//test overload resolution occurring for a function in M1.
test4 = M1.addThree 30.0 == 33;
test5 = M1.addThree 35.0 == 38;

//test use of literals within another module
test6 = List.length [('a', 10.0), ('b', 20.0), ('c', 30.0)] == 3;
test7 = (List.length ['t','h','i','s',' ','i','s',' ','a',' ','s','t','r','i','n','g'] == 16) && (List.length [('a', 10.0), ('b', 20.0), ('c', 30.0)] == 3);

//test lambda lifting in another module
testLambda4 = \x y z -> (\x y-> x + y) x z + (\y z ->2 * y + z) (y + 3 *z) (x * y);
test8 = testLambda4 1.0 2 3 == 28.0 &&
        M2.testLambda4 1.0 2 3 == 28.0 &&
        M1.testLambda4 1.0 2 3 == 28.0 &&
        M1.testLambda5 1.0 2 3 == 28.0;

//caused a problem for Edward
test9 = Prelude.equals (List.filter (\x0 -> Prelude.greaterThan x0 (1.0)) ([2.0, 1.0, 3.0, 2.2, 3.3])) [2.0, 3.0, 2.2, 3.3];

runTargetTest10 x0 x1 = (\a b -> Prelude.multiply a b) x0 x1;
//another one that caused a problem for Edward
test10 = (runTargetTest10 2.0 3.0) == 6.0;

//Answer is 34
testLet2 :: Int ;
testLet2 = 
    let
        mySum xs = case xs of
            []     -> 0;
            b : bs -> b + mySum bs;;
        myProd xs = case xs of
            []     -> 1;
            b : bs -> b * myProd bs;;
        oneToFour = List.take 4 (Prelude.upFrom 1);
    in (mySum oneToFour) + (myProd oneToFour);
test11 = testLet2 == 34;

//minus (along with the other basic arithmetic ops) are finally left associative
test12 = 1.0 - 7 - 5 == 0 - 11;

//test of unary minus
test13 = -1.0 - -7 -4 == 2;

//note these functions don't actually do what their CAL name suggests. This is just a test
//of the module system for foreign scs
foreign unsafe import jvm "static method java.lang.Math.min" private maxDoubleForeign :: Double -> Double -> Double;
foreign unsafe import jvm "static method java.lang.Math.min" private maxIntForeign :: Int -> Int -> Int ;

test14 =
    maxDoubleForeign 2.0 4.0 == 2.0
    && M1.maxDoubleForeign 2.0 4.0 == 4.0
    && maxIntForeign 10 20 == 10
    //&& Prelude.maxIntForeign 10 20 == 20 //FATAL: (line 2944): FreeVariableFinder: the identifier Prelude.maxIntForeign is not visible in M2.
    || Prelude.error "MainM2.test14 failed.";
    
//tests of functions with operator forms
test15 = 2.0 + 3.0 == 5.0 &&
    Prelude.add 6.0 3.0 == 9.0 &&
    Prelude.add (10 :: Int) 20 == 30 &&
    List.sum (List.map (Prelude.add 10) [100, 200, 300]) == (630 :: Int) &&
    (List.filter (Prelude.greaterThanEquals 'b') ['d','d','c','c','a','d','b','c','c']) == ['a','b'] &&
    Prelude.equals ("foo" ++ "bar") "foobar" &&
    Prelude.equals (Prelude.concat (List.map (Prelude.append ['z','a','p']) [['b','a','r'], ['f','o','o']])) ['z','a','p','b','a','r','z','a','p','f','o','o']
    || Prelude.error "MainM2.test15 (tests of functions with operator forms) failed.";
    
//tests use of type constructors and data constructors defined in a dependee module
//later within this stream.
test16Helper :: a -> Maybe a;
test16Helper x = Prelude.Just x;

test16 =
    (case test16Helper 'a' of Prelude.Just x -> x == 'a'; Prelude.Nothing -> Prelude.False;)
    || Prelude.error "MainM2.test16 failed.";

//hide the class method Prelude.divide with the function M2.divide
//test17 also has a local function divide with a different functionality from the class method or the top level function
divide x = List.map Char.toUpperCase x;
test17 =
    Prelude.equals (divide (let divide a b = Prelude.append a b; in divide ['A','B'] ['a','b'])) ['A','B','A','B']
    || Prelude.error "M2.test17 failed.";

//test18 has a local function subract which hides Prelude.subtract
test18 =
    Prelude.equals (divide (let subtract a b = Prelude.append a b; in subtract ['A','B'] ['a','b'])) ['A','B','A','B']
    || Prelude.error "M2.test17 failed.";
            

//factorial function
//todoBI this may not have the right space efficiency... At the moment it is mainly a test for
//the Integer type.
    
facAcc :: Prelude.Num a => a -> a -> a;
private facAcc a n = 
  if n == 0 then a
  else facAcc (n*a) (n-1);

factorial :: Prelude.Num a => a -> a;
factorial = facAcc 1;      

//tests of Num Integer
test19 = Prelude.equals (Prelude.integerToString (factorial (Prelude.fromInt 50))) "30414093201713378043612608166064768844377641568960512000000000000";
//tests using the Ord dictionary from Integer
test20 = Prelude.equals (Prelude.concat (List.map Prelude.integerToString (List.sort (([Prelude.fromInt 100, Prelude.fromInt 2, Prelude.fromInt 4, Prelude.fromInt 232]))))) "24100232";

//test defining a type class and instance entirely within a single module
class Musical a where
    toMusic :: a -> String;
    ;
    
instance Musical Int where
    toMusic = toMusicInt;
    ;

toMusicInt :: Int -> String;
toMusicInt i =
    if i == 0 then
        "A"
    else if i == 1 then
        "B flat"
    else
        "some other note";
    
test21 = Prelude.equals (toMusic (1 :: Int)) "B flat";

//start: tests of the deriving clause

data private MyMaybe a = 
    MyNothing | 
    MyJust 
        value   :: a 
    deriving Eq, Ord;

testMyMaybeDerivedInstances =
    MyJust 'a' == MyJust 'a'
    && MyNothing == (MyNothing :: MyMaybe Int)
    && MyJust 'a' != MyJust 'b'
    && MyNothing != (MyJust 2.0)
    && [MyNothing, MyJust "abc"] == [MyNothing, MyJust "abc"]
    && MyNothing != MyJust ((error "don't call this") :: String)
    && testOrdInstanceWithValuesInAccendingOrder [MyNothing, MyJust 'a', MyJust 'b']
    || error "M2.testMyMaybeDerivedInstances failed.";

data private MyTuple2 a b = 
    MyTuple2 
        #1      :: a 
        #2      :: b 
    deriving Eq, Ord;

testMyTuple2DerivedInstances =
    MyTuple2 "abc" True == MyTuple2 "abc" True
    && MyTuple2 2.0 "abc" != MyTuple2 2.0 "def"
    && MyTuple2 2.0 "abc" != MyTuple2 1.0 (error "don't call this")
    && MyTuple2 (MyJust 'a') Rameau == MyTuple2 (MyJust 'a') Rameau
    && MyTuple2 (MyJust 'a') Rameau != MyTuple2 (MyJust 'a') Bach
    && testOrdInstanceWithValuesInAccendingOrder [MyTuple2 0.0 "abc", MyTuple2 0.0 "def", MyTuple2 1.0 "abc", MyTuple2 1.0 "def", MyTuple2 2.0 ""]
    || error "M2.testMyTuple2DerivedInstances failed.";

//a typical enumerated type
data MyComposersEnum = Bach | Rameau | Handel | Purcell | Dowland deriving Eq, Ord, Bounded, Enum;

testMyComposersEnumDerivedInstances =
    List.group [Bach, Bach, Rameau, Handel, Purcell, Purcell, Dowland]
        == [[Bach, Bach], [Rameau], [Handel], [Purcell, Purcell], [Dowland]]
    && testOrdInstanceWithValuesInAccendingOrder [Bach, Rameau, Handel, Purcell, Dowland]
    && testBoundedInstanceWithValuesInAccendingOrder [Bach, Rameau, Handel, Purcell, Dowland]
    && testEnumInstanceWithValuesInAccendingOrder [Bach, Rameau, Handel, Purcell, Dowland]
    || error "M2.testMyComposersEnumDerivedInstances failed."; 

// More tests for derived Eq, Ord and Bounded instances:
// 1) a type with only one data constructor:
data private MyUnit = MyUnit deriving Eq, Ord, Bounded, Enum;

testMyUnitDerivedInstances =
    testOrdInstanceWithValuesInAccendingOrder [MyUnit]
    && testBoundedInstanceWithValuesInAccendingOrder [MyUnit]
    && testEnumInstanceWithValuesInAccendingOrder [MyUnit]
    || error "M2.testMyUnitDerivedInstances failed.";

// 2) a type with two nullary data constructors:
data private MyBoolean = MyFalse | MyTrue deriving Eq, Ord, Bounded, Enum;

testMyBooleanDerivedInstances =
    testOrdInstanceWithValuesInAccendingOrder [MyFalse, MyTrue]
    && testBoundedInstanceWithValuesInAccendingOrder [MyFalse, MyTrue]
    && testEnumInstanceWithValuesInAccendingOrder [MyFalse, MyTrue]
    || error "M2.testMyBooleanDerivedInstances failed.";

// 3) a type with one data constructor that takes just one argument:
data private MyWrap = 
    MyWrap 
        int     :: Int 
    deriving Eq, Ord;

testMyWrapDerivedInstances =
    testOrdInstanceWithValuesInAccendingOrder [MyWrap 0, MyWrap 1, MyWrap 2]
    || error "M2.testMyWrapDerivedInstances failed.";

// 4) a type with three nullary data constructors:
data private MyOrdering = MyLT | MyEQ | MyGT deriving Eq, Ord, Bounded, Enum;

testMyOrderingDerivedInstances =
    testOrdInstanceWithValuesInAccendingOrder [MyLT, MyEQ, MyGT]
    && testBoundedInstanceWithValuesInAccendingOrder [MyLT, MyEQ, MyGT]
    && testEnumInstanceWithValuesInAccendingOrder [MyLT, MyEQ, MyGT]
    || error "M2.testMyOrderingDerivedInstances failed.";

// 5) a type with 3 data constructors, the first and last being nullary, and the middle one taking an argument:
data private MyBottomMiddleTop a = 
    Bottom | 
    Middle 
        arg     :: a | 
    Top 
    deriving Eq, Ord;

testMyBottomMiddleTopDerivedInstances =
    testOrdInstanceWithValuesInAccendingOrder [Bottom, Middle 0.0, Middle 1.0, Middle 2.0, Top]
    || error "M2.testMyBottomMiddleTopDerivedInstances failed.";

// 6) a type with 7 nullary data constructors (for testing the grouping of the middle inner case alt with either the first 3 or the last 3)
data private MyABCDEFG = MyA | MyB | MyC | MyD | MyE | MyF | MyG deriving Eq, Ord, Bounded, Enum;

testMyABCDEFGDerivedInstances =
    testOrdInstanceWithValuesInAccendingOrder [MyA, MyB, MyC, MyD, MyE, MyF, MyG]
    && testBoundedInstanceWithValuesInAccendingOrder [MyA, MyB, MyC, MyD, MyE, MyF, MyG]
    && testEnumInstanceWithValuesInAccendingOrder [MyA, MyB, MyC, MyD, MyE, MyF, MyG]
    || error "M2.testMyABCDEFGDerivedInstances failed.";

// 7) a type with 3 data constructors, the first and last being taking an argument, and the middle one nullary:
//    (for testing the generation of wildcard variable patterns)
data private MyFooBarBaz a b = 
    MyFoo 
        arg     :: a | 
    MyBar | 
    MyBaz 
        arg     :: b 
    deriving Eq, Ord;

testMyFooBarBazDerivedInstances =
    testOrdInstanceWithValuesInAccendingOrder [MyFoo 0.0, MyFoo 1.0, MyFoo 2.0, MyBar, MyBaz "abc", MyBaz "def", MyBaz "ghi"]
    || error "M2.testMyFooBarBazDerivedInstances failed.";

// 8) a List-like recursive type:
data private MyList a = 
    MyNil | 
    MyCons 
        arg1    :: a 
        arg2    :: (MyList a) 
    deriving Eq, Ord;

testMyListDerivedInstances =
    let
        listToMyList lst =
            case lst of
            [] -> MyNil;
            x : xs -> MyCons x (listToMyList xs);
            ;
    in
        testOrdInstanceWithValuesInAccendingOrder [MyNil, listToMyList [1.0], listToMyList [1.0, 0.0], listToMyList [1.0, 0.0, 1.0], listToMyList [1.0, 1.0], listToMyList [2.0]]
        || error "M2.testMyListDerivedInstances failed.";

// 9) a 3-tuple type:
data private MyTuple3 a b c = 
    MyTuple3 
        #1      :: a 
        #2      :: b 
        #3      :: c 
    deriving Eq, Ord;

testMyTuple3DerivedInstances =
    testOrdInstanceWithValuesInAccendingOrder [MyTuple3 0.0 "abc" 0.0, MyTuple3 0.0 "abc" 1.0, MyTuple3 0.0 "def" 0.0, MyTuple3 1.0 "abc" 0.0, MyTuple3 1.0 "def" 0.0, MyTuple3 1.0 "def" 1.0, MyTuple3 2.0 "" 0.0]
    || error "M2.testMyTuple3DerivedInstances failed.";
    
//9b) a 3-tuple type with potential name collision for DeriviedInstanceFunctionGenerator:
data private MyTuple3B a b c = 
    MyTuple3B 
        #1       :: a 
        field1   :: b 
        field1_1 :: c 
    deriving Eq, Ord, Inputable, Outputable, Debug.Show;

testMyTuple3BDerivedInstances =
    testOrdInstanceWithValuesInAccendingOrder [MyTuple3B 0.0 "abc" 0.0, MyTuple3B 0.0 "abc" 1.0, MyTuple3B 0.0 "def" 0.0, MyTuple3B 1.0 "abc" 0.0, MyTuple3B 1.0 "def" 0.0, MyTuple3B 1.0 "def" 1.0, MyTuple3B 2.0 "" 0.0]
    || error "M2.testMyTuple3BDerivedInstances failed.";
    
// 10) name collision avoidance:
//     the derived instance code generator should not confuse the internal implementation of lessThanEquals for type MyT
//     and that of lessThan for type EqualsMyT
data private MyT = MyT deriving Eq, Ord;
data private EqualsMyT = EqualsMyT deriving Eq, Ord; // this should compile without problems

// 11) Prelude types:
testPreludeDerivedOrdInstances =
    testOrdInstanceWithValuesInAccendingOrder [[], [1.0], [1.0, 0.0], [1.0, 0.0, 1.0], [1.0, 1.0], [2.0]] // Prelude.List
    && testOrdInstanceWithValuesInAccendingOrder [Nothing, Just 'a', Just 'b']                            // Prelude.Maybe a
    && testOrdInstanceWithValuesInAccendingOrder [LT, EQ, GT]                                             // Prelude.Ordering
    && testBoundedInstanceWithValuesInAccendingOrder [LT, EQ, GT]
    && testEnumInstanceWithValuesInAccendingOrder [LT, EQ, GT]
    && testOrdInstanceWithValuesInAccendingOrder [Left 'a', Left 'b', Right 'a', Right 'b']               // Prelude.Either a b
    && testOrdInstanceWithValuesInAccendingOrder [False, True]                                            // Prelude.Boolean
    && testBoundedInstanceWithValuesInAccendingOrder [False, True]
    && testOrdInstanceWithValuesInAccendingOrder [()]                                                     // Prelude.Unit
    && testBoundedInstanceWithValuesInAccendingOrder [()]
    || error "M2.testPreludeDerivedOrdInstances failed.";

//a phantom type has a type variable on the left hand side that does not appear on the
//right hand side. In this case the derived Eq instance is for
//instance (Eq a, Eq b) => Eq (MyPhantomType1 a b) 
//i.e. there is a constraint for a to be in Eq (even though this is not strictly needed
//in the hand written instance declaration to make sense of it).
data MyPhantomType1 a b = 
    MyPhantom1 
        arg     :: b 
    deriving Eq;

testMyPhantomType1DerivedInstances =
    (MyPhantom1 "abc" :: MyPhantomType1 Int String) == MyPhantom1 "abc"
    && (MyPhantom1 2.0 :: MyPhantomType1 Int Double) != MyPhantom1 1.0
    || error "M2.testMyPhantomType1DerivedInstances failed.";

data MyPhantomType2 a =
    MyP1 |
    MyP2 |
    MyP3
    deriving Eq, Ord;

testMyPhantomType2DerivedInstances =
    MyP1 == (MyP1 :: MyPhantomType2 [Int])
    && MyP2 == (MyP2 :: MyPhantomType2 String)
    && MyP3 == (MyP3 :: MyPhantomType2 (MyPhantomType1 Int Char))
    && MyP1 != (MyP2 :: MyPhantomType2 [MyComposersEnum])
    && not (MyP3 != (MyP3 :: MyPhantomType2 [MyComposersEnum]))
    && testOrdInstanceWithValuesInAccendingOrder [MyP1, MyP2, MyP3 :: MyPhantomType2 MyUnit]
    || error "M2.testMyPhantomType2DerivedInstances failed."; 

//this data declaration produces a compilation error since a phantom type cannot be a derived Enum instance.
//Error: The type class Prelude.Enum in the deriving clause requires the data type to be non-polymorphic.
//data private MyPhantomType3 a = MyPT deriving Enum;

//in all these speed tests, the list is ordinal 1, ordinal 0, ordinal 2.
//this is a test of hand rolled enum instance functions versus delegation to Prelde.equalsOrdinalValue, Prelude.lessThanOrdinalValue
//etc. Currently we delegate to the general purpose instance functions for large enums (>= 10 data constructors).

enumInstanceSpeedTest1 :: Int -> Ordering;
enumInstanceSpeedTest1 n = List.last (List.sort (List.take n (List.cycle [EQ, LT, GT]))); 

enumInstanceSpeedTest2 :: Int -> MedEnum;
enumInstanceSpeedTest2 n = List.last (List.sort (List.take n (List.cycle [MedEnum2, MedEnum1, MedEnum3]))); 

enumInstanceSpeedTest3 :: Int -> MyOrdering;
enumInstanceSpeedTest3 n = List.last (List.sort (List.take n (List.cycle [MyEQ, MyLT, MyGT]))); 
                                         
data BigEnum =
     BigEnum1 | BigEnum2 | BigEnum3 | BigEnum4 | BigEnum5 | BigEnum6 | BigEnum7 | BigEnum8 | BigEnum9 | BigEnum10 |
     BigEnum11 | BigEnum12 | BigEnum13 | BigEnum14 | BigEnum15 | BigEnum16 | BigEnum17 | BigEnum18 | BigEnum19 | BigEnum20 |
     BigEnum21 | BigEnum22 | BigEnum23 | BigEnum24 | BigEnum25 | BigEnum26 | BigEnum27 | BigEnum28 | BigEnum29 | BigEnum30 |
     BigEnum31 | BigEnum32 | BigEnum33 | BigEnum34 | BigEnum35 | BigEnum36 | BigEnum37 | BigEnum38 | BigEnum39 | BigEnum40 |
     BigEnum41 | BigEnum42 | BigEnum43 | BigEnum44 | BigEnum45 | BigEnum46 | BigEnum47 | BigEnum48 | BigEnum49 | BigEnum50 |
     BigEnum51 | BigEnum52 | BigEnum53 | BigEnum54 | BigEnum55 | BigEnum56 | BigEnum57 | BigEnum58 | BigEnum59 | BigEnum60 |
     BigEnum61 | BigEnum62 | BigEnum63 | BigEnum64 | BigEnum65 | BigEnum66 | BigEnum67 | BigEnum68 | BigEnum69 | BigEnum70 |
     BigEnum71 | BigEnum72 | BigEnum73 | BigEnum74 | BigEnum75 | BigEnum76 | BigEnum77 | BigEnum78 | BigEnum79 | BigEnum80 |
     BigEnum81 | BigEnum82 | BigEnum83 | BigEnum84 | BigEnum85 | BigEnum86 | BigEnum87 | BigEnum88 | BigEnum89 | BigEnum90 |
     BigEnum91 | BigEnum92 | BigEnum93 | BigEnum94 | BigEnum95 | BigEnum96 | BigEnum97 | BigEnum98 | BigEnum99 | BigEnum100
     deriving Eq, Ord, Bounded, Enum, Show;

//unfortunately this test takes about 20seconds to run, so it is too slow for the M2.mainM2 regression suite.
testBigEnumDerivedInstances =
    let 
        list = 
            [
                BigEnum1, BigEnum2, BigEnum3, BigEnum4, BigEnum5, BigEnum6, BigEnum7, BigEnum8, BigEnum9, BigEnum10,
                BigEnum11, BigEnum12, BigEnum13, BigEnum14, BigEnum15, BigEnum16, BigEnum17, BigEnum18, BigEnum19, BigEnum20,
                BigEnum21, BigEnum22, BigEnum23, BigEnum24, BigEnum25, BigEnum26, BigEnum27, BigEnum28, BigEnum29, BigEnum30,
                BigEnum31, BigEnum32, BigEnum33, BigEnum34, BigEnum35, BigEnum36, BigEnum37, BigEnum38, BigEnum39, BigEnum40,
                BigEnum41, BigEnum42, BigEnum43, BigEnum44, BigEnum45, BigEnum46, BigEnum47, BigEnum48, BigEnum49, BigEnum50,
                BigEnum51, BigEnum52, BigEnum53, BigEnum54, BigEnum55, BigEnum56, BigEnum57, BigEnum58, BigEnum59, BigEnum60,
                BigEnum61, BigEnum62, BigEnum63, BigEnum64, BigEnum65, BigEnum66, BigEnum67, BigEnum68, BigEnum69, BigEnum70,
                BigEnum71, BigEnum72, BigEnum73, BigEnum74, BigEnum75, BigEnum76, BigEnum77, BigEnum78, BigEnum79, BigEnum80,
                BigEnum81, BigEnum82, BigEnum83, BigEnum84, BigEnum85, BigEnum86, BigEnum87, BigEnum88, BigEnum89, BigEnum90,
                BigEnum91, BigEnum92, BigEnum93, BigEnum94, BigEnum95, BigEnum96, BigEnum97, BigEnum98, BigEnum99, BigEnum100
            ];
    in     
        List.group [BigEnum1, BigEnum1, BigEnum5, BigEnum3, BigEnum3, BigEnum4, BigEnum2]
            == [[BigEnum1, BigEnum1], [BigEnum5], [BigEnum3, BigEnum3], [BigEnum4], [BigEnum2]]
        && testOrdInstanceWithValuesInAccendingOrder list
        && testBoundedInstanceWithValuesInAccendingOrder list
        && testEnumInstanceWithValuesInAccendingOrder list
        || error "M2.testBigEnumDerivedInstances failed."; 
    
data MedEnum =
     MedEnum1 | MedEnum2 | MedEnum3 | MedEnum4 | MedEnum5 | MedEnum6 | MedEnum7 | MedEnum8 | MedEnum9 | MedEnum10 |
     MedEnum11 | MedEnum12 | MedEnum13 | MedEnum14 | MedEnum15 | MedEnum16 | MedEnum17 | MedEnum18 | MedEnum19 | MedEnum20
     deriving Eq, Ord, Bounded, Enum, Show; 

testMedEnumDerivedInstances =
    let 
        list = 
            [
                MedEnum1, MedEnum2, MedEnum3, MedEnum4, MedEnum5, MedEnum6, MedEnum7, MedEnum8, MedEnum9, MedEnum10,
                MedEnum11, MedEnum12, MedEnum13, MedEnum14, MedEnum15, MedEnum16, MedEnum17, MedEnum18, MedEnum19, MedEnum20
            ];
    in     
        List.group [MedEnum1, MedEnum1, MedEnum5, MedEnum3, MedEnum3, MedEnum4, MedEnum2]
            == [[MedEnum1, MedEnum1], [MedEnum5], [MedEnum3, MedEnum3], [MedEnum4], [MedEnum2]]
        && testOrdInstanceWithValuesInAccendingOrder list
        && testBoundedInstanceWithValuesInAccendingOrder list
        && testEnumInstanceWithValuesInAccendingOrder list
        || error "M2.testMedEnumDerivedInstances failed."; 
 
 
//this data declaration produces a compilation error since Double -> Double cannot be a member of Eq.
//the problem is that the error doesn't have a line number, and it doesn't refer directly to the data declaration
//this will be fixed later.
//Error: Type error applying the operator "==" to its first argument. Caused by: Type clash: type Prelude.Double -> Prelude.Double is not a member of type class Prelude.Eq.
//data private MyFuncWrapper = MyFuncWrapper (Double -> Double) deriving Eq;

//tests of inputting and outputting foreign types mapped to primitive java types

data foreign unsafe import jvm "int" MyInt deriving Outputable, Inputable;
data foreign unsafe import jvm "long" MyLong deriving Outputable, Inputable;

data foreign unsafe import jvm "char" MyChar deriving Outputable, Inputable;
data foreign unsafe import jvm "byte" MyByte deriving Outputable, Inputable;
data foreign unsafe import jvm "short" MyShort deriving Outputable, Inputable;
data foreign unsafe import jvm "float" MyFloat deriving Outputable, Inputable;
data foreign unsafe import jvm "double" MyDouble deriving Outputable, Inputable;
                   
myIntToInt :: MyInt -> Int;
myIntToInt !x = unsafeCoerce x;

intToMyInt :: Int -> MyInt;
intToMyInt !x = unsafeCoerce x;

myLongToLong :: MyLong -> Long;
myLongToLong !x = unsafeCoerce x;

longToMyLong :: Long -> MyLong;
longToMyLong !x = unsafeCoerce x;

testOutThenInMyInt = 
   myIntToInt (Prelude.input (Prelude.output (intToMyInt 100)) :: MyInt) == 100
   || error "M2.testOutThenInMyInt failed.";

testOutThenInMyLong =
    myLongToLong (Prelude.input (Prelude.output (longToMyLong 200)) :: MyLong) == 200
    || error "M2.testOutThenInMyLong failed.";

//this should fail in a class cast exception since java.lang.Long cannot be cast to
//a java.lang.Integer
testOutThenIn3 = Prelude.input (Prelude.output (intToMyInt 300)) :: MyLong;

//this should fail in a class cast exception
testOutThenIn4 = Prelude.input (Prelude.output (longToMyLong 400)) :: MyInt;


data foreign unsafe import jvm "java.lang.String" MyString deriving Inputable, Outputable;
data foreign unsafe import jvm "java.lang.StringBuilder" MyStringBuilder deriving Inputable, Outputable;
data foreign unsafe import jvm "java.lang.Object" MyObject deriving Inputable, Outputable;

testMyString = ((Prelude.input (Prelude.output ((Prelude.input (Prelude.output "abc")) :: MyString))) :: String) == "abc";
//this test should fail in a class cast exception on Prelude.input since String cannot
//be cast to StringBuilder
testMyString2 = Prelude.output ((Prelude.input (Prelude.output "abc")) :: MyStringBuilder);
     
//end: tests of the deriving clause

//start: tests of the # operator
testComposeOpPrecedence =
    let
        l x = [x :: Int];
        
        isLHSApplicationGroupedBeforeComposeOp = (typeOf (map id # l)) == (typeOf ( (map  id) # l  ));
        isComposeOpGroupedBeforeLHSApplication = (typeOf (map id # l)) == (typeOf (  map (id  # l) ));
        
        a x = "a";
        b :: y -> Int -> String;
        b y z = "b";
        c = "c";
        
        isRHSApplicationGroupedBeforeComposeOp = (typeOf (a # b c)) == (typeOf (  a # (b  c) ));
        isComposeOpGroupedBeforeRHSApplication = (typeOf (a # b c)) == (typeOf ( (a #  b) c  ));
    in
        isLHSApplicationGroupedBeforeComposeOp && (not isComposeOpGroupedBeforeLHSApplication)    // lhs application has higher precedence
        && isRHSApplicationGroupedBeforeComposeOp && (not isComposeOpGroupedBeforeRHSApplication) // rhs application has higher precedence
        || error "M2.testComposeOpPrecedence failed.";
    
testComposeOpSemantics =
    let
        a x = "a(" ++ show x ++ ")";
        b x = "b(" ++ show x ++ ")";
        c x = "c(" ++ show x ++ ")";
    in
        ((a # b) 1.0) == a(b(1.0))
        && ((a # b # c) 1.0) == a(b(c(1.0)))
        || error "M2.testComposeOpSemantics failed.";
//end: tests of the # operator

//start: tests of the $ operator
testApplyOpAssociativity =
    let
        f :: a -> Int -> (Int, a);
        f a b = (b, a);
        g :: Int -> Int -> Int;
        g x y = x - y;
        
        isLeftAssociative  = (typeOf (f $ g 1 $ 2) == typeOf ( (f $  g 1) $ 2  ));
        isRightAssociative = (typeOf (f $ g 1 $ 2) == typeOf (  f $ (g 1  $ 2) ));
    in
        isRightAssociative && (not isLeftAssociative)
        || error "M2.testApplyOpAssociativity failed.";
    
testApplyOpPrecedence =
    let
        f x = True;
        g x = False;
    in
        (f $ "hello" :: Boolean)   // :: has lower precedence, and therefore this parses as (f $ "hello") :: Boolean
        && not (g $ False || True) // || has higher precedence, and therefore this parses as not (g $ (False || True))
        || error "M2.testApplyOpPrecedence failed.";
    
testApplyOpSemantics =
    (Prelude.pair 1.0 $ Prelude.pair 2.0 3.0) == (Prelude.pair 1.0 (Prelude.pair 2.0 3.0))
    && (Prelude.pair 1.0 $ Prelude.triple 2.0 3.0 $ Prelude.negate 4.0) == (Prelude.pair 1.0 (Prelude.triple 2.0 3.0 (Prelude.negate 4.0)))
    || error "M2.testApplyOpSemantics failed.";
//end: tests of the $ operator

 
//mainM2 = 1.0 - 7 - 5;
//mainM2 = -1.0 - -7 -4;

//mainM2  = List.filter (\x0 -> Prelude.greaterThan x0 (1.0)) ([2.0, 1.0, 3.0, 2.2, 3.3]);

//runTarget x0 x1 = (\a b -> multiply a b) x0 x1;

//mainM2 = runTarget 2.0 3.0;


isNull2 :: [a] -> Boolean;
//Returns True if the input list is empty. This function is called null in Haskell.
isNull2 xs =
    case xs of
    []     -> True;
    _ : _ -> Prelude.False;
    ;
    
/////////////////////////////////////////////////////
    
//the getNthPrime benchmark. This function (along with its dependees) was mostly written in the GemCutter and is a direct
//translation of a simple imperative program to calculate prime numbers. 
//Note that getNthPrime 0 = 2, getNthPrime 1 = 3, ...

nonMultiple :: Int -> Int -> Boolean;
private nonMultiple arg arg_1 = (Prelude.remainder arg arg_1) != (0 :: Int);

isPrime :: Int -> Boolean;
isPrime arg =
    let
          nToTest = arg;
    in
          List.andList (List.map (M2.nonMultiple nToTest) (Prelude.upFromTo (2 :: Int) (Prelude.round (Math.sqrt (Prelude.fromInt nToTest)))));

getNthPrime :: Int -> Int ;
getNthPrime n =
    if n == 0 then
        2
    else if n < 0 then
        Prelude.error "getNthPrime: n must be >= 0."
    else
        List.subscript (List.filter M2.isPrime (Prelude.upFromThen (3 :: Int) (5 :: Int))) (n - 1);

///////////////////////////////////////////////////////
//getNthPrime2
//-inlined let variable arg in isPrime (this will be done automatically by the compiler anyways)
//-replaced fromInt by toDouble (toDouble is a class method. fromInt is implemented in terms of a class method).

nonMultiple2 :: Int -> Int -> Boolean;
private nonMultiple2 arg arg_1 = (Prelude.remainder arg arg_1) != (0 :: Int);

isPrime2 :: Int -> Boolean;
isPrime2 nToTest =
   List.andList (List.map (M2.nonMultiple2 nToTest) (Prelude.upFromTo (2 :: Int) (Prelude.round (Math.sqrt (Prelude.toDouble nToTest)))));

getNthPrime2 :: Int -> Int ;
getNthPrime2 n =
    if n == 0 then
        2
    else if n < 0 then
        Prelude.error "getNthPrime2: n must be >= 0."
    else
        List.subscript (List.filter M2.isPrime2 (Prelude.upFromThen (3 :: Int) (5 :: Int))) (n - 1);


///////////////////////////////////////////////////////
//getNthPrime3
//-plinged arguments

nonMultiple3 :: Int -> Int -> Boolean;
private nonMultiple3 !arg !arg_1 = (Prelude.remainder arg arg_1) != (0 :: Int);

isPrime3 :: Int -> Boolean;
isPrime3 !nToTest =
   List.andList (List.map (M2.nonMultiple3 nToTest) (Prelude.upFromTo (2 :: Int) (Prelude.round (Math.sqrt (Prelude.toDouble nToTest)))));

getNthPrime3 :: Int -> Int ;
getNthPrime3 !n =
    if n == 0 then
        2
    else if n < 0 then
        Prelude.error "getNthPrime3: n must be >= 0."
    else
        List.subscript (List.filter M2.isPrime3 (Prelude.upFromThen (3 :: Int) (5 :: Int))) (n - 1);

///////////////////////////////////////////////////////
//getNthPrime4
//-in-line List.map (M2.nonMultiple4 nToTest)

//map :: (a -> b) -> [a] -> [b];
//map (M2.nonMultiple4 nToTest) !list =
//    case list of
//    []     -> [];
//    listHead : listTail -> (M2.nonMultiple4 nToTest) listHead : map (M2.nonMultiple4 nToTest) listTail;
//    ;
//    
//nonMultiple4 :: Int -> Int -> Boolean;
//private nonMultiple4 !arg !arg_1 = (Prelude.remainder arg arg_1) != (0 :: Int);    
    
private mapNonMultiple nToTest !list =
    case list of
    []     -> [];
    listHead : listTail -> (Prelude.remainder nToTest listHead != (0 :: Int)) : mapNonMultiple nToTest listTail;
    ;    

isPrime4 :: Int -> Boolean;
isPrime4 !nToTest =
   List.andList (mapNonMultiple nToTest (Prelude.upFromTo (2 :: Int) (Prelude.round (Math.sqrt (Prelude.toDouble nToTest)))));

getNthPrime4 :: Int -> Int ;
getNthPrime4 !n =
    if n == 0 then
        2
    else if n < 0 then
        Prelude.error "getNthPrime4: n must be >= 0."
    else
        List.subscript (List.filter M2.isPrime4 (Prelude.upFromThen (3 :: Int) (5 :: Int))) (n - 1);

///////////////////////////////////////////////////////
//getNthPrime5
//-partial un-inling to call nonMultiple in the defn of mapNonMultiple so that that a big lazy graph is not created
//  for the expression (Prelude.remainder nToTest listHead != (0 :: Int))

//map :: (a -> b) -> [a] -> [b];
//map (M2.nonMultiple4 nToTest) !list =
//    case list of
//    []     -> [];
//    listHead : listTail -> (M2.nonMultiple4 nToTest) listHead : map (M2.nonMultiple4 nToTest) listTail;
//    ;
//    
//nonMultiple4 :: Int -> Int -> Boolean;
//private nonMultiple4 !arg !arg_1 = (Prelude.remainder arg arg_1) != (0 :: Int);    
    
private mapNonMultiple5 nToTest !list =
    case list of
    []     -> [];
    listHead : listTail -> nonMultiple5 nToTest listHead : mapNonMultiple5 nToTest listTail;
    ; 
    
nonMultiple5 :: Int -> Int -> Boolean;
private nonMultiple5 !arg !arg_1 = (Prelude.remainder arg arg_1) != (0 :: Int);    

isPrime5 :: Int -> Boolean;
isPrime5 !nToTest =
   List.andList (mapNonMultiple5 nToTest (Prelude.upFromTo (2 :: Int) (Prelude.round (Math.sqrt (Prelude.toDouble nToTest)))));

getNthPrime5 :: Int -> Int ;
getNthPrime5 !n =
    if n == 0 then
        2
    else if n < 0 then
        Prelude.error "getNthPrime5: n must be >= 0."
    else
        List.subscript (List.filter M2.isPrime5 (Prelude.upFromThen (3 :: Int) (5 :: Int))) (n - 1);

///////////////////////////////////////////////////////
//getNthPrime6
//-inline mapNonMultiple6 into andList to form andListMapNonMupltiple6

//andList :: [Boolean] -> Boolean;
//andList !list =
//    case list of
//    [] -> True;
//    listHead : listTail -> listHead && andList listTail;
//    ;
//    
//andList (mapNonMultiple6 nToTest list) ===
//    case 
//        case list of
//        []     -> [];
//        listHead : listTail -> nonMultiple6 nToTest listHead : mapNonMultiple6 nToTest listTail;
//        ;
//    of
//    [] -> True;
//    listHead : listTail -> listHead && andList listTail;
//    ;    
//    ===
//    case list of       
//    [] -> [];
//    listHead : listTail -> (nonMultiple6 nToTest listHead) && andList (mapNonMultiple6 nToTest listTail);
//    ;

//mapNonMultiple6 :: Int -> [Int] -> [Int];    
//private mapNonMultiple6 nToTest !list =
//    case list of
//    []     -> [];
//    listHead : listTail -> nonMultiple6 nToTest listHead : mapNonMultiple6 nToTest listTail;
//    ; 

andListMapNonMultiple6 nToTest !list =
    case list of
    [] -> True;
    listHead : listTail -> (nonMultiple6 nToTest listHead) && (andListMapNonMultiple6 nToTest listTail);
    ;
           
nonMultiple6 :: Int -> Int -> Boolean;
private nonMultiple6 !arg !arg_1 = (Prelude.remainder arg arg_1) != (0 :: Int);    

isPrime6 :: Int -> Boolean;
isPrime6 !nToTest =
   andListMapNonMultiple6 nToTest (Prelude.upFromTo (2 :: Int) (Prelude.round (Math.sqrt (Prelude.toDouble nToTest))));

getNthPrime6 :: Int -> Int ;
getNthPrime6 !n =
    if n == 0 then
        2
    else if n < 0 then
        Prelude.error "getNthPrime6: n must be >= 0."
    else
        List.subscript (List.filter M2.isPrime6 (Prelude.upFromThen (3 :: Int) (5 :: Int))) (n - 1);

///////////////////////////////////////////////////////
//getNthPrime7
//-inline upFromToInt into andListMapNonMultiple to form andListMapNonMupltipleUpFromTo

//upFromToInt :: Int -> Int -> [Int];
//private upFromToInt !start !end = upFromByUpToInt start 1 end;
//
//upFromByUpToInt :: Int -> Int -> Int -> [Int];  
//private upFromByUpToInt !start !step !end =
//    if (start > end) then
//        []
//    else
//        let
//            next = start + step;
//        in
//            if (next > end || next < start) then
//            //assuming that step >= 0, the condition that next < start
//            //occurs only when start + step overflows the Int type.
//            //In this case, start is the last element of the sequence.
//            [start]
//        else
//            start : upFromByUpToInt next step end;
//
//andListMapNonMultiple7 nToTest !list =
//    case list of
//    [] -> True;
//    listHead : listTail -> (nonMultiple7 nToTest listHead) && (andListMapNonMultiple7 nToTest listTail);
//    ;
//    
//andListMapNonMultiple7 nToTest (Prelude.upFromTo start end)) ===
//andListMapNonMultiple7 nToTest (Prelude.upFromByUpToInt start 1 end) ===
//   case (Prelude.upFromByUpToInt start 1 end) of
//   [] -> True;
//   listHead : listTail -> (nonMultiple7 nToTest listHead) && (andListMapNonMultiple7 nToTest listTail);
//   ; 
//===
//   case 
//       if (start > end) then
//            []
//        else
//            let
//                next = start + step;
//            in
//                if (next > end || next < start) then
//                //assuming that step >= 0, the condition that next < start
//                //occurs only when start + step overflows the Int type.
//                //In this case, start is the last element of the sequence.
//                [start]
//            else
//                start : upFromByUpToInt next step end;
//   of
//   [] -> True;
//   listHead : listTail -> (nonMultiple7 nToTest listHead) && (andListMapNonMultiple7 nToTest listTail);
//   ;
//   
//===   
//    if (start > end) then
//        True
//    else
//        let
//            next = start + 1;
//        in
//            if (next > end || next < start) then            
//                (nonMultiple7 nToTest start) && (andListMapNonMultiple7 nToTest [])
//            else
//                (nonMultiple7 nToTest start) && (andListMapNonMultiple8 nToTest (upFromByUpToInt next 1 end);
//=== (inline andListMapNonMultiple another time, and simply x && True to x.
//    if (start > end) then
//        True
//    else
//        let
//            next = start + 1;
//        in
//            if (next > end || next < start) then            
//                (nonMultiple7 nToTest start)
//            else
//                (nonMultiple7 nToTest start) && (andListMapNonMultiple8 nToTest (upFromByUpToInt next 1 end);        

andListMapNonMultipleUpFromTo7 :: Int -> Int -> Int -> Boolean;
andListMapNonMultipleUpFromTo7 nToTest !start !end = 
    if (start > end) then
        True
    else
        let
            next = start + 1;
        in
            if (next > end || next < start) then            
                (nonMultiple7 nToTest start)
            else
                (nonMultiple7 nToTest start) && (andListMapNonMultipleUpFromTo7 nToTest next end);        
           
nonMultiple7 :: Int -> Int -> Boolean;
private nonMultiple7 !arg !arg_1 = (Prelude.remainder arg arg_1) != (0 :: Int);    

isPrime7 :: Int -> Boolean;
isPrime7 !nToTest =
   andListMapNonMultipleUpFromTo7 nToTest (2 :: Int) (Prelude.round (Math.sqrt (Prelude.toDouble nToTest)));

getNthPrime7 :: Int -> Int ;
getNthPrime7 !n =
    if n == 0 then
        2
    else if n < 0 then
        Prelude.error "getNthPrime7: n must be >= 0."
    else
        List.subscript (List.filter M2.isPrime7 (Prelude.upFromThen (3 :: Int) (5 :: Int))) (n - 1);
            

///////////////////////////////////////////////////////
//getNthPrime8
//-simplify upFromThen (3::Int) (5::Int)
//-inline the simplification of upFromThen into filter to form filterUpFromByUpTo


//upFromThenInt 3 5
//===
//    upFromThenToInt 3 5 (if 3 <= 5 then maxBound else minBound)
//=== (compile time simplification)
//    upFromThenToInt 3 5 maxBound
//==
//    if 3 <= 5 then
//        upFromByUpToInt 3 (5 - 3) maxBound    
//    else
//        upFromByDownToInt start (start - next) end;
//=== (compile-time simplification)
//    upFromByUpToInt 3 2 maxBound
//
//    
//
//upFromThenInt :: Int -> Int -> [Int];
//private upFromThenInt !start !next =
//    upFromThenToInt start next (if start <= next then maxBound else minBound);
//
//upFromThenToInt :: Int -> Int -> Int -> [Int];
//private upFromThenToInt !start !next !end  =
//    if start <= next then
//        upFromByUpToInt start (next - start) end    
//    else
//        upFromByDownToInt start (start - next) end;
//
//upFromByUpToInt :: Int -> Int -> Int -> [Int];  
//private upFromByUpToInt !start !step !end =
//    if (start > end) then
//        []
//    else
//        let
//            next = start + step;
//        in
//            if (next > end || next < start) then
//            //assuming that step >= 0, the condition that next < start
//            //occurs only when start + step overflows the Int type.
//            //In this case, start is the last element of the sequence.
//            [start]
//        else
//            start : upFromByUpToInt next step end;
//            
//filter :: (a -> Boolean) -> [a] -> [a];
//filter keepIfTrueFunction !list = 
//    case list of
//    []     -> [];
//    listHead : listTail ->
//        let
//            rest = filter keepIfTrueFunction listTail;
//        in
//            if keepIfTrueFunction listHead then
//                listHead : rest
//            else
//                rest;
//    ;
//    
//filter keepIfTrueFunction (upFromByUpToInt !start !step !end)
//=== (inlined the rest variable (to simplify this)
//    case (
//        if (start > end) then
//            []
//        else
//            let
//                next = start + step;
//            in
//                if (next > end || next < start) then                  
//                    [start]
//                else
//                    start : upFromByUpToInt next step end;)    
//    of
//    
//    []     -> [];
//    listHead : listTail ->        
//        if keepIfTrueFunction listHead then
//            listHead : filter keepIfTrueFunction listTail
//        else
//            filter keepIfTrueFunction listTail;
//    ;
//===
//    if (start > end) then
//        []
//    else
//        let
//            next = start + step;
//        in
//            if (next > end || next < start) then 
//                if (keepIfTrueFunction start) then
//                    start : filter keepIfTrueFunction []
//                else
//                    filter keepIfTrueFunction []
//            else
//                if (keepIfTrueFunction start) then
//                    start : filter keepIfTrueFunction (upFromByUpToInt next step end)
//                else
//                    filter keepIfTrueFunction (upFromByUpToInt next step end)   
//=== (inlining filter again)
//    if (start > end) then
//        []
//    else
//        let
//            next = start + step;
//        in
//            if (next > end || next < start) then 
//                if (keepIfTrueFunction start) then
//                    start : []
//                else
//                    []
//            else
//                if (keepIfTrueFunction start) then
//                    start : filter keepIfTrueFunction (upFromByUpToInt next step end)
//                else
//                    filter keepIfTrueFunction (upFromByUpToInt next step end)  

filterUpFromByUpToInt8 :: (Int -> Boolean) -> Int -> Int -> Int -> [Int];
filterUpFromByUpToInt8 keepIfTrueFunction !start !step !end =
    if (start > end) then
        []
    else
        let
            next = start + step;
        in
            if (next > end || next < start) then 
                if (keepIfTrueFunction start) then
                    start : []
                else
                    []
            else
                if (keepIfTrueFunction start) then
                    start : filterUpFromByUpToInt8 keepIfTrueFunction next step end
                else
                    filterUpFromByUpToInt8 keepIfTrueFunction next step end;  


andListMapNonMultipleUpFromTo8 :: Int -> Int -> Int -> Boolean;
andListMapNonMultipleUpFromTo8 nToTest !start !end = 
    if (start > end) then
        True
    else
        let
            next = start + 1;
        in
            if (next > end || next < start) then            
                (nonMultiple8 nToTest start)
            else
                (nonMultiple8 nToTest start) && (andListMapNonMultipleUpFromTo8 nToTest next end);        
           
nonMultiple8 :: Int -> Int -> Boolean;
private nonMultiple8 !arg !arg_1 = (Prelude.remainder arg arg_1) != (0 :: Int);    

isPrime8 :: Int -> Boolean;
isPrime8 !nToTest =
   andListMapNonMultipleUpFromTo8 nToTest (2 :: Int) (Prelude.round (Math.sqrt (Prelude.toDouble nToTest)));

getNthPrime8 :: Int -> Int ;
getNthPrime8 !n =
    if n == 0 then
        2
    else if n < 0 then
        Prelude.error "getNthPrime8: n must be >= 0."
    else
        List.subscript (filterUpFromByUpToInt8 M2.isPrime8 (3 :: Int) (2 :: Int) maxBound) (n - 1);

///////////////////////////////////////////////////////
//getNthPrime9
//-inline subscript into filter to form filterUpFromByUpTo9 to form subscriptFilterUpFromByUpTo9

//subscript :: [a] -> Int -> a;
//subscript !list !index =
//    case list of
//    listHead : listTail ->
//        if index == 0 then
//            listHead
//        else if index > 0 then
//            subscript listTail (index - 1)
//        else 
//            error "List.subscript: negative index.";
//    
//    [] -> error "List.subscript: index out of bounds.";
//    ;
//    
//subscript (filterUpFromByUpToInt9 keepIfTrueFunction !start !step !end) !index
//===
//case
//    if (start > end) then
//        []
//    else
//        let
//            next = start + step;
//        in
//            if (next > end || next < start) then 
//                if (keepIfTrueFunction start) then
//                    start : []
//                else
//                    []
//            else
//                if (keepIfTrueFunction start) then
//                    start : filterUpFromByUpToInt9 keepIfTrueFunction next step end
//                else
//                    filterUpFromByUpToInt9 keepIfTrueFunction next step end
//of
//    listHead : listTail ->
//        if index == 0 then
//            listHead
//        else if index > 0 then
//            subscript listTail (index - 1)
//        else 
//            error "List.subscript: negative index.";
//    
//    [] -> error "List.subscript: index out of bounds.";
//    ;    
//==== 
//case
//    if (start > end) then
//        error "List.subscript: index out of bounds."
//    else
//        let
//            next = start + step;
//        in
//            if (next > end || next < start) then 
//                if (keepIfTrueFunction start) then                      
//                     if index == 0 then
//                         []
//                     else if index > 0 then
//                         subscript [] (index - 1)
//                     else 
//                         error "List.subscript: negative index.";                                                        
//                else
//                    error "List.subscript: index out of bounds."
//            else
//                if (keepIfTrueFunction start) then                   
//                    if index == 0 then
//                        start
//                    else if index > 0 then
//                        subscript (filterUpFromByUpToInt9 keepIfTrueFunction next step end) (index - 1)
//                    else 
//                        error "List.subscript: negative index."                                       
//                else
//                    subscript (filterUpFromByUpToInt9 keepIfTrueFunction next step end) index
//==== (inlining subscript again)                    
//    if (start > end) then
//        error "List.subscript: index out of bounds."
//    else
//        let
//            next = start + step;
//        in
//            if (next > end || next < start) then 
//                if (keepIfTrueFunction start) then                      
//                     if index == 0 then
//                         start
//                     else if index > 0 then
//                         error "List.subscript: index out of bounds."
//                     else 
//                         error "List.subscript: negative index.";                                                        
//                else
//                    error "List.subscript: index out of bounds."
//            else
//                if (keepIfTrueFunction start) then                   
//                    if index == 0 then
//                        start
//                    else if index > 0 then
//                        subscript (filterUpFromByUpToInt9 keepIfTrueFunction next step end) (index - 1)
//                    else 
//                        error "List.subscript: negative index."                                       
//                else
//                    subscript (filterUpFromByUpToInt9 keepIfTrueFunction next step end) index                   
  
subscriptFilterUpFromByUpToInt9 :: (Int -> Boolean) -> Int -> Int -> Int -> Int -> Int;
subscriptFilterUpFromByUpToInt9 keepIfTrueFunction !start !step !end !index =
    if (start > end) then
        error "List.subscript: index out of bounds."
    else
        let
            next = start + step;
        in
            if (next > end || next < start) then 
                if (keepIfTrueFunction start) then                      
                     if index == 0 then
                         start
                     else if index > 0 then
                         error "List.subscript: index out of bounds."
                     else 
                         error "List.subscript: negative index."                                                       
                else
                    error "List.subscript: index out of bounds."
            else
                if (keepIfTrueFunction start) then                   
                    if index == 0 then
                        start
                    else if index > 0 then
                        subscriptFilterUpFromByUpToInt9 keepIfTrueFunction next step end (index - 1)
                    else 
                        error "List.subscript: negative index."                                       
                else
                    subscriptFilterUpFromByUpToInt9 keepIfTrueFunction next step end index;      

andListMapNonMultipleUpFromTo9 :: Int -> Int -> Int -> Boolean;
andListMapNonMultipleUpFromTo9 nToTest !start !end = 
    if (start > end) then
        True
    else
        let
            next = start + 1;
        in
            if (next > end || next < start) then            
                (nonMultiple9 nToTest start)
            else
                (nonMultiple9 nToTest start) && (andListMapNonMultipleUpFromTo9 nToTest next end);        
           
nonMultiple9 :: Int -> Int -> Boolean;
private nonMultiple9 !arg !arg_1 = (Prelude.remainder arg arg_1) != (0 :: Int);    

isPrime9 :: Int -> Boolean;
isPrime9 !nToTest =
   andListMapNonMultipleUpFromTo9 nToTest (2 :: Int) (Prelude.round (Math.sqrt (Prelude.toDouble nToTest)));

getNthPrime9 :: Int -> Int ;
getNthPrime9 !n =
    if n == 0 then
        2
    else if n < 0 then
        Prelude.error "getNthPrime9: n must be >= 0."
    else
        subscriptFilterUpFromByUpToInt9 M2.isPrime9 (3 :: Int) (2 :: Int) maxBound (n - 1);       


///////////////////////////////////////////////////////

//getNthPrimeClean is a "cleaned up" version of getNthPrime, removing some of the unneeded code produced by the GemCutter
getNthPrimeClean :: Int -> Int ;
getNthPrimeClean n =
    let
        nonMultiple :: Int -> Int -> Boolean;
        nonMultiple x y = (Prelude.remainder x y) != 0;

        isPrime :: Int -> Boolean;
        isPrime nToTest = 
            List.andList (List.map (nonMultiple nToTest) (Prelude.upFromTo 2 (Prelude.round (Math.sqrt (Prelude.fromInt nToTest)))));
    in    
        if n == 0 then
            2
        else if n > 0 then
            List.subscript (List.filter isPrime (Prelude.upFromThen 3 5)) (n - 1)
        else 
            Prelude.error "getNthPrime: n must be >= 0.";
        
data Simpson = Bart | Homer | Lisa | Maggie | Marge;

isBart :: Simpson -> Boolean;
isBart x =
    case x of
    Bart -> True;
    _ -> Prelude.False;
    ;

isSimpsonParent :: Simpson -> Boolean;
isSimpsonParent x =
    case x of
    Homer -> True;
    Marge -> True;
    _ -> Prelude.False;
    ;
    
//tests wildcard pattern matching in a simple case
test22 :: Boolean;
test22 = 
    isBart Bart
    && Prelude.not (isBart Marge)
    && Prelude.not (isBart Homer)
    && Prelude.not (isBart Lisa)
    && Prelude.not (isBart Maggie)
    && isSimpsonParent Homer
    && isSimpsonParent Marge
    && Prelude.not (isSimpsonParent Bart)
    && Prelude.not (isSimpsonParent Lisa)
    && Prelude.not (isSimpsonParent Maggie)
    || Prelude.error "M2.test22 failed.";
    
data NTuple a b c = 
    OneTuple 
        #1      :: a | 
    TwoTuple 
        #1      :: a 
        #2      :: b | 
    ThreeTuple 
        #1      :: a 
        #2      :: b 
        #3      :: c;

getThird :: NTuple a b c -> Maybe c;
getThird t = 
    case t of
    ThreeTuple x y z -> Prelude.Just z;
    _ -> Prelude.Nothing;
    ;
    
test23 :: Boolean;
test23 =
    Prelude.isJust (getThird (ThreeTuple 'a' "ab" 2.0)) 
    && Prelude.isNothing (getThird (TwoTuple "cd" 'c'))
    || Prelude.error "M2.test22 failed.";
    

//test the use of the wildcard for pattern bound variables
test24 :: Boolean;
test24 =
    (case ThreeTuple "abc" True 'z' of ThreeTuple _ _ v -> v == 'z';) &&
    (case ThreeTuple "abc" True 'z' of ThreeTuple t _ v -> v == 'z';) &&
    (case ThreeTuple "abc" True 'z' of ThreeTuple _ b _ -> b;) &&
    (case ThreeTuple "abc" True 'z' of ThreeTuple t b _ -> b;)
    || Prelude.error "M2.test24 failed.";
    
    
//tests the use of alphabetic as well as special syntax for data constructors
test25 :: Boolean;
test25 = 
    Prelude.equals (Prelude.Cons 'a' (Prelude.Cons 'b' (Prelude.Cons 'c' Prelude.Nil))) ['a','b','c'] &&
    Prelude.equals (Prelude.Cons 'd' (Prelude.Cons 'e' (Prelude.Cons 'f' []))) ['d','e','f'] &&
    Prelude.equals ('a', 2.0) (Prelude.tuple2 'a' 2.0) &&
    ((Prelude.id (case ['a','b','c'] of Prelude.Cons x xs -> x;)) == 'a') && //the id is needed because of the bug documented in test26
    ((Prelude.id (case [] of Prelude.Nil -> 'b';)) == 'b') &&
    (Prelude.equals (Prelude.field2 (Prelude.tuple3 'a' ['f','o','o','B','a','r'] 2.0)) ['f','o','o','B','a','r'])
    || Prelude.error "M2.test25 failed.";
    
//tests the use of alphabetic syntax for type constructors
test25_1 :: Prelude.List Double;
test25_1 = Prelude.Cons 1.0 (Prelude.Cons 2.0 Prelude.Nil);

test26 :: Boolean;
test26 = Char.toUpperCase (case ('b', True) of (x, y) -> x;) == 'B' 
    || Prelude.error "M2.test26 failed.";


//should return True
zap4 :: Boolean;
zap4 = zap3 == 436 || Prelude.error "M2.zap4 failed";

//should return 436
zap3 :: Int ;
zap3 = List.sum (List.map Char.toInt (Prelude.concat zap));

//should return ["ft", "ft"]
zap :: [[Prelude.Char]];
zap = List.map (zaptest 'r' Prelude.False 'b' True) ['x','y'];

zaptest :: Prelude.Char -> Boolean -> Prelude.Char -> Boolean -> Prelude.Char -> [Prelude.Char];
zaptest c1 b1 c2 b2 = zaplambdaLift c1 b1 c2 b2;

zaplambdaLift c1 b1 c2 b2 c3 =
[(zapeaselTest3 c3 c1 b1), (zapeaselTest3 c3 c2 b2)]; 


zapeaselTest3 :: Prelude.Char -> Prelude.Char -> Boolean -> Prelude.Char;
zapeaselTest3 c1 c2 b =
Prelude.iff b 't' 'f'
//(if b then 't' else 'f')
;

//todoBI the default text editor in Eclipse does not support Unicode. To see that
//CAL supports Unicode, run the function below in the GemCutter, and paste the text
//into a code gem. Run the code gem, and it will work.
//the characters 1/3 2/3 1/8 3/8 5/8 7/8    
unicodeCharactersInFile = "\u2153\u2154\u215b\u215c\u215d\u215e";

// The JLS allows an unlimited number of 'u' characters following the backslash
testUnicodeEscapeWithMoreThanOneU = 
    assert(equals "abc\uuuuuuu0053def" "abcSdef");

lazyTest = 
    lazyTest1 &&
    lazyTest2 &&
    lazyTest3 &&
    lazyTest4 && 
    lazyTest5 &&
    lazyTest6 &&  
    lazyTest7 == 2.0 &&
    lazyTest9 10 10000 == (Prelude.negate 1) && //takes a long time if laziness not working properly
    lazyTest10 100 0 == 30
    || Prelude.error "M2.lazyTest failed.";
        
lazyTest1 =
    List.length [(1 :: Int) / (0 :: Int), Prelude.error "M2.lazyTest1 failed"] == 2 ||
    Prelude.error "M2.lazyTest1 failed";

lazyTest2 =
    (
    case True of
    True -> True;
    Prelude.False -> Prelude.error "M2.lazyTest2 failed.";
    )
    || Prelude.error "M2.lazyTest2 failed."
    ;
    

lazyTest3 =
    (
    let
        x =
            case ['a','b'] of
            u : us -> u;
            [] -> Prelude.error "M2.lazyTest3 failed.";
            ;
    in
        x == 'a'
    )
    || Prelude.error "M2.lazyTest3 failed.";
        
lazyTest4 =
    (
    if Prelude.False then
        case (Debug.trace "M2.lazyTest4 failed.\n" Prelude.Nothing) of
        Prelude.Nothing -> Prelude.False;        
    else
        True
    )
    || Prelude.error "M2.lazyTest4 failed.";
    
errorIfWinter s = case s of
    M1.Winter -> Prelude.error "error, Winter selected";
    _ -> True;
    ;
    
lazyTest5 = Prelude.iff Prelude.False (errorIfWinter M1.Winter) (errorIfWinter M1.Summer)
    || Prelude.error "M2.lazyTest5 failed.";


//fails in the runtime. See Ray's doc on problems with lazy evaluation of switches in the Quark technical docs.
lazyTest6 =
    (Prelude.iff Prelude.False (case (Debug.trace "M2.lazyTest6 failed.\n" True) of True -> Prelude.False;) True)
    || Prelude.error "M2.lazyTest6 failed.";

//fails in the runtime if case lifting is not done. See Ray's doc on problems with lazy evaluation of switches in the Quark technical docs.
lazyTest7 = 
    let
        x = case y of
                True -> 1.0;
                Prelude.False -> 0.0;;
        y = (1.0 > 0.0);
    in
        2.0;

//even without case lifting, lazyTest8 10 1000 does not compute primes.
lazyTest8 :: Int -> Int -> Int;        
lazyTest8 n m =
    if n == 0 then
        case List.reverse (List.take m M1.allPrimes) of
        b : bs -> b;
        [] -> (Prelude.negate 1);
    else
        (Prelude.negate 1);
        
//if case lifting is not done, lazyTest9 10 1000 results in a long delay (computing primes)        
lazyTest9 :: Int -> Int -> Int ;        
lazyTest9 n m =
    Prelude.iff (n == 0 )
        ((case List.reverse (List.take m M1.allPrimes) of
        b : bs -> b;
        [] -> (Prelude.negate 1);) + 100)
        (Prelude.negate 1);    

//if case lifting is not done, lazyTest10 100 0 results in a division by 0        
lazyTest10 :: Int -> Int -> Int;        
lazyTest10 n m =
    Prelude.iff (m != 0)
        (case n / m == 5 of
        True -> 10 + n;
        Prelude.False -> 20 + n;) 
        30;
    

foo1 = Prelude.iff Prelude.False (case (Prelude.error "M2.foo1 failed.") of True -> 40.0;) 20.0;        
foo2 = Prelude.iff Prelude.False (let x = (case (Prelude.error "M2.foo2 failed.") of True -> 40.0;); in x) 20.0;      

//this works, and shows how to lift cases.
foo3 = Prelude.iff Prelude.False ((\x -> (case (Prelude.error "M2.foo3 failed.") of True -> 40.0;)) ()) 20.0;       

liftedCase = (case (Prelude.error "M2.foo4 failed.") of True -> 40.0;);        
foo4 = Prelude.iff Prelude.False liftedCase 20.0;

foo5 = Prelude.iff Prelude.False (if True then (case (Prelude.error "M2.foo5 failed.") of True -> 40.0;) else Prelude.error "no!") 20.0;

foo6 = Prelude.iff Prelude.False (case (let e = (Prelude.error "M2.foo6 failed."); in e) of True -> 40.0;) 20.0;      

foo7 = Prelude.iff Prelude.False (let x = Prelude.error "M2.foo7 failed."; in x) 20.0;

let1 = (let a = List.map; in a) Prelude.isEmpty;
letTest1 = (let1 [['a'], [], ['b']]) == ([Prelude.False, True, Prelude.False]);



//the following tests unification of constrained type variables to get a third constrained type variable
//with more stringent constraints.

/*
//todoBI this test was taken out because of the change in definition of the
//Enum type class. Restore a similar test.

//toEnum x has type Enum a => a. fromInt y has type Num a => a, so the unification has type (Enum a, Num a) => a.
typesTest1 x y = [Prelude.toEnum x, Prelude.fromInt y];
typesTest2 x y z = Prelude.toEnum x : List.sort [y, z];
//give a more specific type than the inferred type
//typesTest3 :: (Enum a, Num a) => Int -> a -> a -> [a];
typesTest3 x y z = Prelude.toEnum x : List.sort [y, z];
test27 :: Boolean;
test27 =
    (typesTest2 0 Prelude.GT Prelude.LT) == [Prelude.LT, Prelude.LT, Prelude.GT] &&
    (typesTest2 2 Prelude.EQ Prelude.EQ) == [Prelude.GT, Prelude.EQ, Prelude.EQ] 
    || Prelude.error "M2.test27 failed.";
*/    


ciTest1 :: Boolean;    
ciTest1 =
    (1.0, 'a') == (1.0, 'a') &&
    ([1.0, 2.0], ("abc", 5 :: Int)) == ([1.0, 2.0], ("abc", 5 :: Int)) &&
    List.take 5 M1.allPrimes == [2, 3, 5, 7, 11] &&
    [[[[['a']]]]] == [[[[['a']]]]] &&
    [[[[['a']]]]] <= [[[[['a']]]]] &&
    List.map (Prelude.equals []) [[], [1.0]] == [True, Prelude.False] &&
    [(1.0, 'a'), (2.0, 'b')] == [(1.0, 'a'), (2.0, 'b')] &&
    ((('a', 1.0), True), 5 :: Int) == ((('a', 1.0), True), 5 :: Int) &&
    List.sort [('z', 2.0), ('a', 3.0)] == List.reverse [('z', 2.0), ('a', 3.0)];    

ciTest2Helper :: Double -> Boolean;
ciTest2Helper x = (1.0, 'a') == (x, 'a');
ciTest2 = ciTest2Helper 1.0 && (Prelude.not (ciTest2Helper 2.0));

ciTest3Helper :: (Prelude.Eq a, Prelude.Ord b, Prelude.Appendable c) => a -> b -> c -> [a] -> [b] -> c -> (Boolean, (Boolean, c));
ciTest3Helper x y z xs ys zs = (xs == [x], ([y] < ys, z ++ zs));
ciTest3 =
    (ciTest3Helper 2.0 (5 :: Int) "abc" [2.0] [4 :: Int] "def") == (True, (Prelude.False, "abcdef")) &&
    (ciTest3Helper (2.0, 'a') [4, 5] "a" [(2.0, 'a')] [[4 :: Int, 6]] "d") == (True, (True, "ad"));

ciTest4 :: (Prelude.Ord a) => a -> a -> [a];
ciTest4 x y = if x > y then [x, y] else [y, x];

ciTest5 :: Prelude.Eq a => [a] -> [a] -> Boolean;
ciTest5 x y = True;


ciTest6Helper :: Prelude.Eq a => a -> a -> Boolean;
ciTest6Helper x y = Prelude.equals x y;

ciTest6 :: Prelude.Eq a => a -> a -> Boolean;
ciTest6 x y = ciTest6Helper [x] [y];

ciTest7 xs = List.sort xs == xs;

//ciTest7 (stringToCharacters "abc")




//this examples shows a parametric type (Maybe a) that is an instance of a type class. Normally this is not
//too interesting if you don't allow for constrained instances. However, it is not required!
class Music a where
    playMusic :: a -> [Prelude.Char];
    ;
      
instance Music (Maybe a) where
    playMusic = maybePlayMusic;
    ;
    
/*
Error:/CAL scripts/M2.cal: (line 561 column 5): The resolving function M2.maybePlayMusic for the instance method playMusic must have a type that can specialize to (a, b) -> [Char]. Instead it has type Maybe a -> [Char].
instance Music (Tuple2 a b) where
    playMusic = maybePlayMusic;
    ;
*/

maybePlayMusic :: Maybe a -> [Prelude.Char];
maybePlayMusic y = 
    case y of
    Prelude.Just x -> toList "tra la la - Just picked";
    Prelude.Nothing -> toList "tra la la - Nothing picked";
    ;
  
/*  
instance Eq a => Music (Maybe a) where
    playMusic = maybePlayMusic;
    ;
*/

class Person a where
    name :: a -> String;
    ;
    
class (Person a) => Programmer a where
    nComputers :: a -> Int;
    ;
    
//instance (Eq a, Enum a) => Person (Maybe a) where
//    name = nameMaybe;
//    ;

/*
//results in a complaint that this instance declaration doesn't satisfy the Enum a constraint of the above instance declaration.    
instance (Ord a) => Programmer (Maybe a) where
    nComputers = nComputersMaybe;
    ;
*/
    
nameMaybe :: Maybe a -> String;
nameMaybe x = "the function nameMaybe";
    
nComputersMaybe :: Maybe a -> Int;
nComputersMaybe x = 10;

    
music1 = playMusic (Prelude.Just 'a');
music2 = playMusic (Prelude.Just 'b');

class Appendable a where
    ap :: a -> a -> a;
    ;
    
appendString :: String -> String -> String;
appendString = Prelude.append;

instance Appendable String where
    ap = M2.appendString;
    ;
    
instance Appendable (Prelude.List a) where
    ap = appendList;
  ;
  
appendList :: [a] -> [a] -> [a];
appendList = Prelude.append;  
    
    
testAp1 x = ap x x;
testAp2 y = ap (List.head y : y) y;

//////////////////////////////////////////////////////////////////////
// generic zipWith defined without multi-parameter type classes with functional dependencies
// or dependent types. From a paper "Do we need dependent types?" by Fridlender and Indrika.

/*
Conclusions:
1. the "number" functions such as "three" are special to the zipWith family and certain highly related families.
Even though this approach can be adapted for other functions, such as curry, the number functions change.
Thus, this approach does not represent a clear improvement- it replaces a family of relatively simple
zipWith? definitions, with a similar family of numeral definitions that is arguably less clear, even if
it has some conceptual simplicity.

2. it is fairly awkward to use in the GemCutter, but demonstrates an interesting point: the possibility of a
gem getting extra arguments due to a connection. 
a. connect the two gem to the first argument of zipperWith and burn the first argument (out of 3) of two. This gives a gem where the
input types (in order) are [a], [b], a->b->c i.e. not in the order of zipWith3.
b. another way is to burn all arguments of two and connect to zipperWith. Then we need to connect 2 apply gems to the output in order to
"unburn". The reason for this is that without the apply gem, the output has type [a] -> [b] -> [c] i.e. is functional. We can imagine that 
instead, 2 arguments of type [a] and [c] are added to the end of zipperWith (the root gem). In other words, the gem gets extra
arguments. This sort of situation sometimes arises in code gems e.g. enter the code gem with text "add 1.0". It has 0 arguments but
has output type Double->Double, so there is an opportunity for "unburning".

3. One interesting point (made elsewhere as well)
zipWith0 = repeat, zipWith1 = map, zipWith2 = zipWith.
It is probably useful to recognize these degenerate cases and provide the synonyms in the CAL prelude.
This can help people in understanding the functionality of the whole zipWith family when they understand a special case, such as map.
*/

applyPointwise :: [a -> b] -> [a] -> [b];
private applyPointwise fs xs =
    case fs of
    fs_head : fs_tail ->
        case xs of
        xs_head : xs_tail -> (fs_head xs_head) : applyPointwise fs_tail xs_tail;
        [] -> [];
        ;        
    [] -> [];
    ;

succ :: ([b] -> c) -> [a -> b] -> [a] -> c;
private succ n fs bs = n (applyPointwise fs bs);

zero :: [a] -> [a];
zero x = x;

one :: [a -> b] -> [a] -> [b];
one = succ zero;

two :: [a -> b -> c] -> [a] -> [b] -> [c];
two = succ one;

three :: [a -> b -> c -> d] -> [a] -> [b] -> [c] -> [d];
three = succ two;

four :: [a -> b -> c -> d -> e] -> [a] -> [b] -> [c] -> [d] -> [e];
four = succ three;

zipperWith :: ([a] -> b) -> a -> b;
zipperWith n f = n (List.repeat f);

//this shows how "zipperWith three" is equivalent to "zipWith3"
private testZipperWith = 
    zipperWith three Prelude.tuple3 (toList "abc") [1.0, 10.0, 100.0] [Prelude.LT, Prelude.GT, Prelude.EQ] ==
    [('a', 1.0, Prelude.LT), ('b', 10.0, Prelude.GT), ('c', 100.0, Prelude.EQ)] ||
    Prelude.error "testZipperWith failed.";

//////////////////////////////////////////////////////////////////////

//an example of a recursive algebraic data type.
data Feeling =
    Vaguely 
        feeling         :: Feeling |
    Mixed 
        feeling1        :: Feeling 
        feeling2        :: Feeling  |
    Love 
        object          :: String |
    Hate 
        object          :: String |
    Happy |
    Depressed;    
feelingValue = Vaguely (Mixed (Love "pleasure") (Hate "pain"));
feelingEntry x = Prelude.asTypeOf x feelingValue;
    
//a parameteric recursive algebraic data type.
data Feeling2 a b =
    Vaguely2 
        feeling         :: (Feeling2 a b) |
    Mixed2 
        feeling1        :: (Feeling2 a b) 
        feeling2        :: (Feeling2 a b)  |
    Love2 
        object          :: a |
    Hate2 
        object          :: b |
    Happy2 |
    Depressed2;
feeling2Value = Mixed2 (Vaguely2 Happy2) (Love2 "wake up in the morning");
feeling2Entry x = Prelude.asTypeOf feeling2Value;
    
//an enumerated type, from the perspective of any module.
data Fruit =
    Orange |
    Apple |
    Pear |
    Cherry;
fruitValue = Cherry;
fruitEntry x = Prelude.asTypeOf x fruitValue;
    
//an enumerated type only from the perspective of the M2 module. From any other module, no data constructors
//are visible and so a value of type Fruit2 can't be constructed.
data Fruit2 =
    private Orange2 |
    private Apple2 |
    private Pear2 |
    private Cherry2;
fruit2Value = Cherry2;
fruit2Entry x = Prelude.asTypeOf x fruit2Value;    
    
//an enumerated type from the point of view of a module importing M2. Not an enumerated type from the point of
//view of M2.    
data Fruit3 =
    Orange3 |
    Apple3 |
    private OtherFruit3 
        name            :: String |
    Pear3 |
    Cherry3;
fruit3Value = Cherry3;
fruit3Entry x = Prelude.asTypeOf x fruit3Value;    

//can't enter values for this type except from module M2.
data Fruit4 a =
    private Orange4 |
    private Apple4 |
    private OtherFruit4 
        name            :: a |
    private Pear4 |
    private Cherry4;
fruit4Value = Cherry4;
fruit4Entry x = Prelude.asTypeOf x fruit4Value;        

/*
a type T is said to be an enumerated type with respect to a module M if:
    -the type T is visible in module M
    -there is at least one data constructor of T visible in module M    
    -all the data constructors of T that are visible in module M have arity 0    
*/

//tests the ability of entering a value of a non-parametric type where the single data constructor takes arguments.
data Type1 = 
    DataCons1 
        arg1    :: Prelude.Char 
        arg2    :: Int 
        arg3    :: Boolean;
type1Value = DataCons1 'a' 10 True;
type1Entry x = Prelude.asTypeOf x type1Value;

//tests the ability of entering a value of a non-parametric type where the single data constructor takes 
//more complicated arguments.
data Type2 = 
    DataCons2 
        arg1    :: [Prelude.Char] 
        arg2    :: (Int, Double) 
        arg3    :: (Maybe Prelude.Ordering);
type2Value = DataCons2 (toList "Hello module M2") (10, 20) (Prelude.Just Prelude.GT);
type2Entry x = Prelude.asTypeOf x type2Value;

//the classic "almost sum" data type
data Type3 =
    DataCons3_1 
        arg1    :: Int |
    DataCons3_2 
        arg2    :: Prelude.Char |
    DataCons3_3 
        arg3    :: Boolean;    
type3Value = DataCons3_2 'a';
type3Entry x = Prelude.asTypeOf x type3Value;

//this is pretty well the simplest almost-sum recursive non-parametric data type.
//todoBI The GemCutter hangs running simpleChainEntry.
data SimpleChain = 
    SimpleChain 
        restOfChain     :: SimpleChain | 
    EndChain;
simpleChainValue = SimpleChain (SimpleChain (SimpleChain EndChain));
simpleChainEntry x = Prelude.asTypeOf x simpleChainValue;

data OrdList = 
    OrdCons 
        head            :: Prelude.Ordering 
        tail            :: OrdList | 
    OrdNil;
ordListValue = OrdCons Prelude.LT (OrdCons Prelude.EQ OrdNil);
ordListEntry x = Prelude.asTypeOf x ordListValue;

//
// These are Frank's tests for calculation of providability of value editors in recursive cases (change 76988).
// Work / not work comments are with respect to a workspace in which the current module imports M2
//   (ie. M2 is not the current module).
//

// this should work
data Chain = 
    Link         rest    :: Chain | 
    End;

// this shouldn't, it's cyclic from the viewport of another module
data Chain2 = 
    Link2        rest    :: Chain2 | 
    private End2;

// should work
data Chain3 = 
    Link3        rest    :: Chain3 | 
    Token3       special :: Special3;
data Special3 = 
    Special3     special :: Special3 | 
    End3;

// should not work
data Chain4 = 
    Link4        rest    :: Chain4 | 
    Token4       special :: Special4;
data Special4 = 
    Special4     special :: Special4 | 
    private End4;

// should not work
data Chain5 = 
    Link5        rest    :: Chain5 | 
    Token5       special :: Special5;
data private Special5 = 
    private Special5    special :: Special5 | 
    private End5;

// should work
data Chain6 = 
    Link6        rest    :: Chain6 | 
    OtherLink6   more    :: BigChain6 | 
    Token6       special :: Special6;
data Special6 = 
    Special6     special :: Special6 | 
    End6;
data BigChain6 = 
    BigLink6     rest    :: BigChain6 | 
    private BigEnd6;


/////////////////////////////////////////////////////////////////////////////////////////////////////////
//GHC has some alternative implementations of Prelude functions which are conditionally defined under
//the USE_REPORT_PRELUDE macro. 

oldLast :: [a] -> a;
//Returns the last element of its input list. This function is O(n) where n is the length of the list.
oldLast !xs =
    case xs of
    b : bs -> if Prelude.isEmpty bs then b else oldLast bs;
    []     -> Prelude.error "M2.oldLast: empty list.";
    ; 

//like oldLast, but does not use the built-in isNull, but rather the explicitly defined isNull2.    
oldLast2 :: [a] -> a;
oldLast2 xs =
    case xs of
    b : bs -> if isNull2 bs then b else oldLast2 bs;
    []     -> Prelude.error "M2.oldLast2: empty list.";
    ;

/*
Note that the lambda lifted newLast is:

transfer' transfer element list =
    case list of
    [] -> element;
    list_head : list_tail -> transfer list_head list_tail;
    ;
newLast' list =         
    case list of
    [] ->
        error "M2.newLast: empty list.";
    list_head : list_tail ->
        let
            transfer = transfer' transfer;                
        in
            transfer list_head list_tail;
    ;
*/    
    
newLast :: [a] -> a;
newLast !list =
    case list of
    list_head : list_tail ->
        let
            transfer :: a -> [a] -> a;
            transfer element !list =
                case list of
                [] -> element;
                list_head : list_tail -> transfer list_head list_tail;
                ;
        in
            transfer list_head list_tail;
    [] ->
        Prelude.error "M2.newLast: empty list.";

    ;


//newLast2 is like newLast except that we have done a more efficient lambda lift of the local function transfer than is done by
//the compiler. We recognize that transfer is not really a local function since it refers only to itself and its arguments, and
//so can just be lifted to the top level
newLast2 :: [a] -> a;
newLast2 !list =
    case list of
    list_head : list_tail ->
        transferForNewLast2 list_head list_tail;
    [] ->
        Prelude.error "M2.newLast: empty list.";

    ;
transferForNewLast2 :: a -> [a] -> a;
transferForNewLast2 element !list =
    case list of
    [] -> element;
    list_head : list_tail -> transferForNewLast2 list_head list_tail;
    ;            

/*
update Aug 12, 2004:
adding strictness annotations, and using the current lecc,
oldLast is 46% faster than newLast
newLast2 is 16% faster than oldLast

Implementation note: With lecc2 as of Nov 26, 2003, oldLast is 34% faster than newLast. newLast2 is 4% faster than
oldLast. In general, newLast and newLast2 do case analysis only once for each element of the list. oldLast does case
analysis twice. The main recursive function of newLast (the lifted transfer) has 3 arguments. The main recursive function
of newLast2 has 2 arguments. The main recursive function of oldLast has 1 argument. Note: even though oldLast and newLast2
show the same (reductions, method calls, data instances) triple, this is somewhat misleading because isNull is built-in
and so is not counted in the method calls. Looking at olLast2 gives an indication of why oldLast is slower than newLast2- it
actually makes more method calls.

Debug>:pt (perfTestLast oldLast)
First Run:  total time = 6516, execution time = 6516, unwind time = 0
Summary:    total time = 6552, execution time = 6552, unwind time = 0
  Reductions:     Total: 12000005 (1831502/s)  Exec: 12000005 (1831502/s)
  Methods Calls:  Total: 12000005 (1831502/s)  Exec: 12000005 (1831502/s)
  Data Instances: Total: 3000001 (457875/s)  Exec: 3000001 (457875/s)
standard deviation of runs = 32.06ms or 0.48% of average


Debug>:pt (perfTestLast oldLast2)
First Run:  total time = 6843, execution time = 6843, unwind time = 0
Summary:    total time = 7046, execution time = 7046, unwind time = 0
  Reductions:     Total: 12000005 (1703094/s)  Exec: 12000005 (1703094/s)
  Methods Calls:  Total: 15000005 (2128868/s)  Exec: 15000005 (2128868/s)
  Data Instances: Total: 3000001 (425773/s)  Exec: 3000001 (425773/s)
standard deviation of runs = 143.92ms or 2.04% of average

Debug>:pt perfTestLast newLast
First Run:  total time = 9844, execution time = 9844, unwind time = 0
Summary:    total time = 9896, execution time = 9896, unwind time = 0
  Reductions:     Total: 12000006 (1212611/s)  Exec: 12000006 (1212611/s)
  Methods Calls:  Total: 12000006 (1212611/s)  Exec: 12000006 (1212611/s)
  Data Instances: Total: 3000001 (303152/s)  Exec: 3000001 (303152/s)
standard deviation of runs = 73.53ms or 0.74% of average

Debug>:pt (perfTestLast newLast2)
First Run:  total time = 6282, execution time = 6282, unwind time = 0
Summary:    total time = 6276, execution time = 6276, unwind time = 0
  Reductions:     Total: 12000006 (1912046/s)  Exec: 12000006 (1912046/s)
  Methods Calls:  Total: 12000006 (1912046/s)  Exec: 12000006 (1912046/s)
  Data Instances: Total: 3000001 (478011/s)  Exec: 3000001 (478011/s)
standard deviation of runs = 7.32ms or 0.11% of average

*/

perfTestLast :: ([Prelude.Char] -> Prelude.Char) -> Prelude.Char;    
perfTestLast lastFunction = lastFunction (List.replicate 3000000 'a');


oldReverse :: [a] -> [a];    
oldReverse = List.foldLeft (Prelude.flip Prelude.Cons) [];  

newReverse :: [a] -> [a];
newReverse !list =
    let
        transfer !sourceList resultList =
            case sourceList of
            [] ->
                resultList;
            headSourceList : tailSourceList ->
                transfer tailSourceList (headSourceList : resultList);
            ;
    in
        transfer list [];

newReverse2 :: [a] -> [a];
newReverse2 !list = transferForNewReverse2 list [];
transferForNewReverse2 :: [a] -> [a] -> [a];
transferForNewReverse2 !sourceList resultList =
    case sourceList of
    [] ->
        resultList;
    headSourceList : tailSourceList ->
        transferForNewReverse2 tailSourceList (headSourceList : resultList);
    ;        

/*
update: Aug 12, 2004

perfTestReverse:
oldReverse 1.587s
newReverse 1.810s
newReverse2 1.144s
newReverse2 is 28% faster than oldReverse

perfTest2Reverse
oldReverse 4.252s
newReverse 2.958s
newReverse2 2.22s
newReverse2 is 48% faster than oldReverse


Implementation note: the perfTestReverse benchmark makes interesting use of memory. It involves linearly increasing space requirements, and then
it frees its space when the head of the list is taken. When run with default settings for initial and maximum heap, the time requirements for
successive runs (of perfTestReverse newReverse, for example) cycle between 6 and 12 seconds! The current theory is that this is due to the fact that
the size of the program is such that garbage collection always happens during each second run, and so the amortized cost (with these heap settings)
is fairly set at 9s.

oldReverse and newReverse2 perform essentially the same for perfTestReverse, however newReverse2 is substantially faster than oldReverse on
perfTest2Reverse. In other words, newReverse2 is better overall at reversing lists, irrespective of how much of the reversed list you want to
use in a subsequent calculation (a little of it, as in the case of perfTestReverse, or all of it, as in the case of perfTest2Reverse).

The reason that perfTestReverse oldReverse has fewer data instances is that the list isn't actually evaluated in this test!

Executing 5 runs of: "perfTestReverse oldReverse"
First Run:  total time = 5610, execution time = 5610, unwind time = 0
Summary:    total time = 5578, execution time = 5578, unwind time = 0
  Reductions:     Total: 4500022 (806744/s)  Exec: 4500022 (806744/s)
  Methods Calls:  Total: 5500025 (986020/s)  Exec: 5500025 (986020/s)
  Data Instances: Total: 1000002 (179276/s)  Exec: 1000002 (179276/s)
standard deviation of runs = 25.72ms or 0.46% of average

Executing 5 runs of: "(perfTestReverse newReverse2)"
First Run:  total time = 5531, execution time = 5531, unwind time = 0
Summary:    total time = 5531, execution time = 5531, unwind time = 0
  Reductions:     Total: 4500020 (813599/s)  Exec: 4500020 (813599/s)
  Methods Calls:  Total: 5500024 (994399/s)  Exec: 5500024 (994399/s)
  Data Instances: Total: 1500001 (271198/s)  Exec: 1500001 (271198/s)
standard deviation of runs = 25.31ms or 0.45% of average

Executing 5 runs of: "(perfTest2Reverse oldReverse)"
First Run:  total time = 8000, execution time = 8000, unwind time = 0
Summary:    total time = 7906, execution time = 7906, unwind time = 0
  Reductions:     Total: 6000019 (758919/s)  Exec: 6000019 (758919/s)
  Methods Calls:  Total: 6500023 (822163/s)  Exec: 6500023 (822163/s)
  Data Instances: Total: 1500001 (189729/s)  Exec: 1500001 (189729/s)
standard deviation of runs = 67.43ms or 0.85% of average

Executing 5 runs of: "(perfTest2Reverse newReverse2)"
First Run:  total time = 5734, execution time = 5734, unwind time = 0
Summary:    total time = 5765, execution time = 5765, unwind time = 0
  Reductions:     Total: 5000019 (867305/s)  Exec: 5000019 (867305/s)
  Methods Calls:  Total: 6000023 (1040767/s)  Exec: 6000023 (1040767/s)
  Data Instances: Total: 1500001 (260190/s)  Exec: 1500001 (260190/s)
standard deviation of runs = 22.15ms or 0.38% of average
*/

perfTestReverse :: ([Int] -> [Int]) -> Int;        
perfTestReverse    reverseFunction = List.head (reverseFunction (Prelude.upFromTo 1 500000));

perfTest2Reverse :: ([Int] -> [Int]) -> Int;        
perfTest2Reverse reverseFunction = List.last (reverseFunction (Prelude.upFromTo 1 500000));        
        
testAlternativeImplementationsOfPreludeFunctions = 
    newLast (Prelude.upFromTo (1 :: Int) (5 :: Int)) == oldLast (Prelude.upFromTo (1 :: Int) (5 :: Int)) &&
    newLast2 (toList "abcdefg") == oldLast (toList "abcdefg") &&
    newReverse (Prelude.upFromTo (1 :: Int) (8 :: Int)) == oldReverse (Prelude.upFromTo (1 :: Int) (8 :: Int)) &&
    newReverse2 (toList "foo bar") == oldReverse (toList "foo bar");
    

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// A couple of benchmarks from The Great Computer Language Shootout (created by Doug Bagley)
// http://www.bagley.org/~doug/shootout/
    
        
// Ackerman's function
ack :: Int -> Int -> Int;
ack m n =
  if m == 0 then
    n + 1
  else if n == 0 then
    ack (m - 1) 1
  else
    ack (m - 1) (ack m (n - 1))
  ;
/*
ack 0 n = n+1
ack m 0 = ack (m-1) 1
ack m n = ack (m-1) (ack m (n-1));
*/


// Linear congruential random number generator.
randloop :: Int -> Int -> Double -> Double -> Double;
randloop n seed r max =
  if n == 0 then
    r
  else
    let
      normalize x max = (Prelude.fromInt x) * (max / imd);
      newseed         = Prelude.remainder (seed * ia + ic) im;
      newrand         = normalize newseed max;
      im              = 139968;
      imd             = Prelude.fromInt im;
      ia              = 3877;
      ic              = 29573;
    in
      randloop (n-1) newseed newrand max;

randTest = randloop 1000 42 0 1000;
/*
randloop :: Int -> Int -> Double -> Double -> Double
randloop 0 seed r max = r
randloop n seed r max = randloop (n-1) newseed newrand max
    where normalize x max = (fromIntegral x) * (max / imd)
          newseed         = (seed * ia + ic) `remainder` im
          newrand         = normalize newseed max
      im              = 139968
      imd             = fromIntegral im
      ia              = 3877
      ic              = 29573
*/

testListOutput :: Int -> Prelude.JObject;    
testListOutput n = Prelude.output (Prelude.upFromTo (1 :: Int) n);

tripleDataSource :: Int -> [(Int, Int, Int)];
tripleDataSource n = List.zip3 (Prelude.upFromTo (1 :: Int) n) (Prelude.upFromThen (1 :: Int) 3) (Prelude.upFromThen (1 :: Int) 4);
        

// Some tests of variations on boolean case statements.
data RData = DC1 | DC2 | DC3 | DC4;

testBooleanCaseStatements = 
    (
    (rtest1 DC1) == True
    &&
    (rtest1 DC3) == Prelude.False
    &&
    (rtest1 DC4) == True
    &&
    (rtest2 DC1) == True 
    &&
    (rtest2 DC3) == Prelude.False
    &&
    (rtest2 DC4) == Prelude.False
    &&
    (rtest3 DC2) == True
    &&
    (rtest4 DC2) == True
    &&
    (rtest4 DC1) == Prelude.False
    &&
    (rtest5 DC2) == Prelude.False
    &&
    (rtest5 DC1) == True
    &&
    (rtest8 DC2) == True
    &&
    (rtest9 DC2) == Prelude.False
    )
    ||
    (Prelude.error "Failed M2.testBooleanCaseStatements")
    ;
    
    
rtest1 x = 
    case x of
    DC1 -> True;
    DC2 -> True;
    DC3 -> Prelude.False;
    _ -> True;
    ;
    
rtest2 x = 
    case x of
    DC1 -> True;
    DC2 -> True;
    DC3 -> Prelude.False;
    _ -> Prelude.False;
    ;
    
rtest3 x =
    case x of
    DC1 -> True;
    _ -> True;
;

rtest4 x =
    case x of
    DC1 -> Prelude.False;
    _ -> True;
;

rtest5 x =
    case x of
    DC1 -> True;
    _ -> Prelude.False;
;


rtest8 x = 
    case x of
    DC1 -> True;
    DC2 -> True;
    ;

rtest9 x = 
    case x of
    DC1 -> Prelude.False;
    DC2 -> Prelude.False;
    ;
    

/*
The following are some type declarations that *should* cause errors (and as of when this
comment was written, April 19, 2004, do.

//guard against record or row variables in the type declaration being specialized
//guard against setInstance being called on a record or row variable where it is being passed.

CAL: Compilation unsuccessful because of errors:
  Error:/CAL scripts/M2.cal: (line 1367 column 15): The declared type of the function 'abcFunction' is not compatible with its inferred type a\abc => {a | } -> {a | abc :: Prelude.String}. caused by: Attempt to instantiate a record variable from the declared type.
  Error:/CAL scripts/M2.cal: (line 1358 column 14): The declared type of the function 'funnyFelix' is not compatible with its inferred type a\felix => {a | felix :: b} -> b. caused by: Attempt to instantiate a type variable from the declared type.
  Error:/CAL scripts/M2.cal: (line 1361 column 11): The declared type of the function 'funnyHead' is not compatible with its inferred type [a] -> a. caused by: Attempt to instantiate a type variable from the declared type.
  Error:/CAL scripts/M2.cal: (line 1364 column 9): The declared type of the function 'funnyId' is not compatible with its inferred type a -> a. caused by: Attempt to instantiate a type variable from the declared type.
  Error:/CAL scripts/M2.cal: (line 1355 column 10): The declared type of the function 'arthur' is not compatible with its inferred type a\felix => {a | felix :: b} -> b. caused by: Attempt to instantiate a type variable from the declared type.
CAL: Finished compiling in 25312ms

arthur :: r\felix => {r | felix :: a} -> Prelude.Char;
arthur r = r.felix;

funnyFelix :: r\felix => {r | felix :: a} -> {r | };
funnyFelix r = r.felix;

funnyHead :: [a] -> Prelude.Char;
funnyHead = List.head;

funnyId :: a -> b;
funnyId = Prelude.id;

abcFunction :: (r\abc) => {r | } -> {abc :: Prelude.String};
abcFunction x = {x | abc = "abc"};
*/

charlie x =
    let
        wonka :: a -> a -> [a]; 
        wonka y z = [y, z];
    in
        (wonka 2.0 3.0, wonka x 'a');
        
charlie2 x =
    let
        wonka :: a -> Prelude.Maybe a -> [Prelude.Maybe a];
        wonka y z = [Prelude.Just y, z];
        
        willy :: Prelude.Maybe a -> a -> [Prelude.Maybe a];
        willy z y = [z, Prelude.Just y, z];
    in
        (wonka 2.0 (Prelude.Just 3.0), wonka x (Prelude.Just 'a'));        
        


// A test of interdependent let variables 
// this tests for a bug in lecc that caused an NPE
letVarTest =
    let
        a = b;
        c = d;
        e = f;
        b = c;
        d = e;
        f = 1.0;
    in
        (a + b + c + d + e + f) == 6.0;
        
badgem  x0 x1 x3 = List.take x0 (List.map (\x2 -> predictAt (regression x1) x2) (Prelude.upFrom x3));
badgem2 x1 x3 = List.map (\x2 -> predictAt (regression x1) x2) (Prelude.upFrom x3);
badgem3 x3 = List.map (\x2 -> predictAt (regression [1.0, 2.0]) x2) (Prelude.upFrom x3);
badgemtest = (List.last(badgem 20 (regressionLine 20) 20.0)) == 39.0;
        
///////////////////////////////////////////////////////////////////////////////////////////////
//tests on strictness annotations for data constructors

data Foo a b c = 
    Foo 
        #1      :: !a 
        #2      :: !b 
        #3      :: !c;

//terminates in an "arg1" error in GHC and Hugs. Should do the same in CAL.
testFoo :: Int;
testFoo =
    case (Foo (error "arg1") (error "arg2") (error "arg3")) of
    Foo x y z -> error "after unpack";
    ;  

data Foo2 a b c = 
    Foo2
        #1      :: a 
        #2      :: b 
        #3      :: c;
foo2Strict = \x y z -> seq x ((seq y ((seq z (Foo2 x)) y)) z);
//in Haskell, using the infix function notation, this can be written more cleanly as:
//foo2Strict = \x y z -> x `seq` y `seq` z `seq` Foo2 x y z

//terminates in an "arg1" error in GHC and Hugs
testFoo2Strict :: Int;
testFoo2Strict =
    case (foo2Strict (error "arg1") (error "arg2") (error "arg3")) of
    Foo2 x y z -> error "after unpack";
    ;

//terminates in an "after unpack" error in GHC and Hugs
testFoo2 :: Int;
testFoo2 =
    case (Foo2 (error "arg1") (error "arg2") (error "arg3")) of
    Foo2 x y z -> error "after unpack";
    ;

//returns 3
testPartialAppsOfFoo = List.length (List.map (Foo 'a' 'b') [error "elem1", error "elem2", error "elem3"]);


testFooUnpacking =
    case (Foo "arg1 OK" (error "arg2") (error "arg3")) of
    Foo x y z -> x;
    ;
    
testEmbeddedIf1 x =
    ((if x > 0 then "gt" else "le") ++ (if x == 0 then " eq" else " ne"), " zaphod");
    
testEmbeddedIf2 x =
    case (case Prelude.Just ['a'] of  Prelude.Just xs -> xs; Prelude.Nothing -> [];) of
    y : ys -> y;
    [] -> 'z';
    ;
    
//Wrong number of type constructor arguments
//the examples below if uncommented give helpful compile-time errors indicating that
//the wrong number of type constructor arguments were given
    
/*    
data WrongNTypeConsArgs1 = WrongNTypeConsArgs1 Prelude.Maybe Prelude.Int;
data WrongNTypeConsArgs2 = WrongNTypeConsArgs2 (Prelude.Either Prelude.Char) Prelude.Int;
data WrongNTypeConsArgs3 = WrongNTypeConsArgs3 (Prelude.Char Prelude.Int) Prelude.Int;

wrongNTypeConsArgs1 :: Prelude.Maybe -> Prelude.Int;
wrongNTypeConsArgs1 = Prelude.undefined;

wrongNTypeConsArgs2 :: Prelude.Int -> [Prelude.Either Prelude.Char];
wrongNTypeConsArgs2 = Prelude.undefined;

wrongNTypeConsArgs3 :: Prelude.Int -> [Prelude.Either Prelude.Char Prelude.Int Prelude.Boolean];
wrongNTypeConsArgs3 = Prelude.undefined;
*/    
    

// Foreign declarations for a class that accumulates strings
data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.M2.StringAccumulator" JStringAccumulator;    
foreign unsafe import jvm "constructor" makeJStringAccumulator :: JStringAccumulator;
foreign unsafe import jvm "method addString" private jStringAccumulator_AddString :: JStringAccumulator -> String -> String;
foreign unsafe import jvm "method getStrings"
    private jStringAccumulator_getStrings :: JStringAccumulator -> String;

// Test the order of evaluation of nested seq applications using the string accumulator.
private accumulateSeq = 
    let
        accumulator = makeJStringAccumulator;
    in
        Prelude.seq (Prelude.seq (Prelude.seq (jStringAccumulator_AddString accumulator "a") (jStringAccumulator_AddString accumulator "b")) (jStringAccumulator_AddString accumulator "c")) (jStringAccumulator_getStrings accumulator);

// Check proper evaluation of second argument of seq
private seqArg2 = if (seq 1.0 (1.0 > 0.0)) then "true" else "false";

// Some tests of seq
private testSeq = ((accumulateSeq == "a, b, c") && 
           (seqArg2 == "true")
          ) || (Prelude.error "M2.testSeq failed");

// testSeq2 and testSeq2Helper are designed to exercise the case where a top level application 
// of Prelude.seq has a primitive operation of type boolean which evluates to falsefor the 
// first argument and the second argument contains local variable declarations.
private testSeq2 = (testSeq2Helper False) == 3.5015368232671564;

testSeq2Helper :: Prelude.Boolean -> Prelude.Double;
private testSeq2Helper z = 
    let
        x = True;
        y = False;
    in
        seq (x && y && z) (let a = sin 1.0; b = sin 2.0; in a + b + a + b);

// Some tests of strictly annotated data constructors.
data SD = 
    SD2 
        arg1    :: !Prelude.Int 
        arg2    :: Prelude.Boolean 
        arg3    :: !Prelude.String 
    deriving Outputable;
        

strictDCTest1 :: SD -> Prelude.String;
strictDCTest1 x = "true";

// Running strictDCTest2 should produce output of "".
strictDCTest2 :: Prelude.String;
strictDCTest2 = 
    let
        accumulator = makeJStringAccumulator;
        result = strictDCTest1 (SD2 (Prelude.seq (jStringAccumulator_AddString accumulator "intArg") 1) (Prelude.seq (jStringAccumulator_AddString accumulator "boolArg") Prelude.True) (Prelude.seq (jStringAccumulator_AddString accumulator "stringArg") "stringval"));
    in
        Prelude.seq (Prelude.output result) (jStringAccumulator_getStrings accumulator);

// Running strictDCTest3 should produce output of "intArg, stringArg, boolArg".
strictDCTest3 :: String;
strictDCTest3 = 
    let
        accumulator = makeJStringAccumulator;
        result = SD2 (Prelude.seq (jStringAccumulator_AddString accumulator "intArg") 1) (Prelude.seq (jStringAccumulator_AddString accumulator "boolArg") Prelude.True) (Prelude.seq (jStringAccumulator_AddString accumulator "stringArg") "stringval");
    in
        Prelude.seq (Prelude.output result) (jStringAccumulator_getStrings accumulator);
        

// Running strictDCTest4 should produce output of "intArg, stringArg1, boolArg, stringArg2".
// This tests partial application of a data constructor with strictly annotated arguments.
strictDCTest4 :: String;
strictDCTest4 =
    let
        accumulator = makeJStringAccumulator;    
        partialDC = SD2 (Prelude.seq (jStringAccumulator_AddString accumulator "intArg") 1) (Prelude.seq (jStringAccumulator_AddString accumulator "boolArg") Prelude.True);
        fullDCs = List.map partialDC [(Prelude.seq (jStringAccumulator_AddString accumulator "stringArg1") "stringval1"), (Prelude.seq (jStringAccumulator_AddString accumulator "stringArg2") "stringval2")];
    in
        Prelude.seq (Prelude.output fullDCs) (jStringAccumulator_getStrings accumulator);
        
        
strictDCTest5 accumulator x = Prelude.seq (jStringAccumulator_AddString accumulator "blah") (x);

// Running strictDCTest6 should produce output of "blah, intArg, stringArg, boolArg".
// This tests a fully saturated application of a data constructor in a lazy context.
strictDCTest6 = 
    let
        accumulator = makeJStringAccumulator;
        result = strictDCTest5 accumulator (SD2 (Prelude.seq (jStringAccumulator_AddString accumulator "intArg") 1) (Prelude.seq (jStringAccumulator_AddString accumulator "boolArg") Prelude.True) (Prelude.seq (jStringAccumulator_AddString accumulator "stringArg") "stringval"));
    in
        Prelude.seq (Prelude.output result) (jStringAccumulator_getStrings accumulator);

// strictDCTest7 should produce trace output of "intArg boolArg stringArg "       
strictDCTest7 = 
    let
        accumulator = makeJStringAccumulator;
    in
        SD2 (Debug.trace "intArg " 1) (Debug.trace "boolArg " Prelude.True) (Debug.trace "stringArg " "stringval");
       
testStrictDataConstructors =
    ((strictDCTest2 == "")
     &&
     (strictDCTest3 == "intArg, stringArg, boolArg")
     &&
     (strictDCTest4 == "intArg, stringArg1, boolArg, stringArg2")
     &&
     (strictDCTest6 == "blah, intArg, stringArg, boolArg")
    ) || (Prelude.error "Failed in M2.testStrictDataConstructors");    
    
    
strictFunction1 :: Prelude.Int -> Prelude.Boolean -> Prelude.String -> Prelude.String;    
strictFunction1 !x y !z = "true";    

// testStrictFunction1 should return the string "intArg, stringArg", indicating that the first/last arguments
// to strictFunction1 were evaluated, even thought they arent' actually used.
testStrictFunction1 = 
    let
        accumulator = makeJStringAccumulator;
        result = strictFunction1 (Prelude.seq (jStringAccumulator_AddString accumulator "intArg") 1) (Prelude.seq (jStringAccumulator_AddString accumulator "boolArg") Prelude.True) (Prelude.seq (jStringAccumulator_AddString accumulator "stringArg") "stringval");
    in
        Prelude.seq (Prelude.output result) (jStringAccumulator_getStrings accumulator);

strictFunction2 ::  Prelude.Int -> Prelude.Boolean -> Prelude.String -> Prelude.Int;    
strictFunction2 !x y !z = 
    Prelude.seq y (Prelude.seq z x);

// testStrictFunction2 should return "intArg, stringArg, booleanArg", showing that the arguments
// marked as strict are evaluated in order before any non-strict arguments, regardless of the
// order of evaluation in the body of the function.
testStrictFunction2 = 
    let
        accumulator = makeJStringAccumulator;
        result = strictFunction2 (Prelude.seq (jStringAccumulator_AddString accumulator "intArg") 1) (Prelude.seq (jStringAccumulator_AddString accumulator "boolArg") Prelude.True) (Prelude.seq (jStringAccumulator_AddString accumulator "stringArg") "stringval");
    in
        Prelude.seq (Prelude.output result) (jStringAccumulator_getStrings accumulator);

// testStrictFunction3 should return "intArg, stringArg1, boolArg, stringArg2".
testStrictFunction3 = 
    let
        accumulator = makeJStringAccumulator;    
        partialAp = strictFunction2 (Prelude.seq (jStringAccumulator_AddString accumulator "intArg") 1) (Prelude.seq (jStringAccumulator_AddString accumulator "boolArg") Prelude.True);
        fullAps = List.map partialAp [(Prelude.seq (jStringAccumulator_AddString accumulator "stringArg1") "stringval1"), (Prelude.seq (jStringAccumulator_AddString accumulator "stringArg2") "stringval2")];
    in
        Prelude.seq (Prelude.output fullAps) (jStringAccumulator_getStrings accumulator);

intFunc :: Prelude.Int -> Prelude.Int -> Prelude.Int;
intFunc x y = if (Prelude.True) then x else y;

testStrictFunction4 = 
    let
        accumulator = makeJStringAccumulator;
        result = strictFunction2 (Prelude.seq (jStringAccumulator_AddString accumulator "intArg") 1) (Prelude.seq (jStringAccumulator_AddString accumulator "boolArg") Prelude.True) (Prelude.seq (jStringAccumulator_AddString accumulator "stringArg") "stringval");
    in
       Prelude.seq (Prelude.output (intFunc 1 result)) (jStringAccumulator_getStrings accumulator);

testStrictFunctions = 
    (
        (testStrictFunction1 == "intArg, stringArg")
        &&
        (testStrictFunction2 == "intArg, stringArg, boolArg")
        &&
        (testStrictFunction3 == "intArg, stringArg1, boolArg, stringArg2")
        &&
        (testStrictFunction4 == "")
    ) || Prelude.error "error in testStrictFunctions";
    
//comparison of using the class method max with non class method max

//testMax1 10000000 --- 31 seconds
//testMax2 10000000 --- 46 seconds
//conclusion: max as a class method is 33% faster than
//max implemented as a function in this case.

nOnes :: Int -> [Int];
nOnes n = replicate n 1;

testMax1 n = List.maximum (nOnes n);

testMax2 n = maximum2 (nOnes n);

//previously, this was how Prelude.max was implemented.
max2 :: Ord a => a -> a -> a;
max2 !x !y = if x <= y then y else x;

maximum2 :: Ord a => [a] -> a;
maximum2 = List.foldLeft1Strict max2;

//comparison of using the class method compare via a non class method compare

//testCompare1 1000000 --- 11 seconds
//testCompare2 1000000 --- 15 seconds
//conclusion: compare as a class method is 27% faster than
//compare implemented as a function in this case.

testCompare1 n = List.head (List.sort (nOnes n));

testCompare2 n = List.head (sort2 (nOnes n));

sort2 :: (Ord a) => [a] -> [a];
sort2 = sortBy compare2;

//previously, this was how Prelude.compare was implemented.
compare2 :: (Ord a) => a -> a -> Ordering;
compare2 !x !y =
    if x < y then LT
    else if x == y then EQ
    else GT; 

//////////////////////////////////////////////////////////////////////
// sum function benchmarks 

/*
Benchmark results (sumBenchmark1) with Aug 16, 2004 lecc   
sumOld 31.5s
sumOldLong 28.2s
sumNew 29.2s
sumNewLong 12.2s

Conclusion: specialization of overloaded functions for a particular type does not give
a significant performance improvement if the function is written in a very "higher order" way.
i.e. The difference between sumOldLong and sumOld.
However, if the function is written in a direct style that explicitly facilitates our unboxing
optimizations, then the performance gain is substantial i.e. the difference between sumNew and sumNewLong.

How can we incorporate the sumNewLong advantage in CAL?
option 1) add sum as a class method to Num.
option 2) add a specialization construct to use a special version of sum if we can guarantee that sum is
    being applied on a Long.

*/
    
//the official, and old, implementation of List.sum 
sumOld :: (Num a) => [a] -> a;
sumOld = foldLeftStrict add 0;

sumOldLong :: [Long] -> Long;
sumOldLong = foldLeftStrict add 0; 

//a more direct implementation of sum

sumNew :: (Num a) => [a] -> a;
sumNew !list = sumNewHelper list 0;

sumNewHelper :: (Num a) => [a] -> a -> a;
private sumNewHelper !list !acc =
    case list of
    [] -> acc;
    listHead : listTail -> sumNewHelper listTail (acc + listHead);
    ;
    
sumNewLong :: [Long] -> Long;
sumNewLong !list = sumNewLongHelper list 0;

sumNewLongHelper :: [Long] -> Long -> Long;
private sumNewLongHelper !list !acc =
    case list of
    [] -> acc;
    listHead : listTail -> sumNewLongHelper listTail (acc + listHead);
    ;    

sumBenchmark1 :: ([Long] -> Long) -> Long;    
sumBenchmark1 sum = sum (upFromTo 1 10000000);    

testSum =
    sumOld (upFromTo ((1 :: Int)) 10) == 55
    && sumNew (upFromTo ((1 :: Int)) 10) == 55
    && sumOld (upFromTo 1.0 10) == 55.0
    && sumNew (upFromTo 1.0 10) == 55.0
    || error "M2.testSum failed.";

/***********************************************
Test backquoted infix operators
************************************************/

private class BackquotedTestClass a where
    nonAssociativeOpDouble :: a -> a -> a;
    ;

instance BackquotedTestClass String where
    nonAssociativeOpDouble = backquotedNonAssociativeFunction;
    ;
    
backquotedNonAssociativeFunction s1 s2 = "a(" ++ s1 ++ ")b(" ++ s2 ++ ")";    

data BackquotedTestData = 
    BackquotedTestData #1::Int #2::Int;
instance Eq (BackquotedTestData) where
    equals = backquotedTestData_equals;
    notEquals = backquotedTestData_notEquals;
;

backquotedTestData_equals :: (BackquotedTestData) -> (BackquotedTestData) -> Boolean;
backquotedTestData_equals v1 v2 =
    case v1 of
    BackquotedTestData v1_a1 v1_a2 ->
    case v2 of
    BackquotedTestData v2_a1 v2_a2 ->
        v1_a1 == v2_a1 && v1_a2 == v2_a2;
    ;;

backquotedTestData_notEquals v1 v2 =
    not (backquotedTestData_equals v1 v2);

testBackquotedOperators = 

    // priority higher than unary minus and fully qualified name
    
    (10::Int) ` remainder ` 2 + 3 == (10 `Prelude.remainder` 2) + 3 &&
    (3::Int) + 10 `remainder` 2 == 3 + (10 `Prelude.remainder` 2) &&
    (3::Int) + 10 `Prelude.remainder` 2 * 1 == 3 + ((10 `Prelude.remainder` 2) * 2) &&
    - 10 `Prelude.remainder` (2::Int) == -(10 `Prelude.remainder` 2) &&

    // priority lower than function application
    
    (\x -> "a(" ++ x ++ ")") "b" `nonAssociativeOpDouble` "c" == "a(a(b))b(c)" &&
    
    // try using a class
    "1" `nonAssociativeOpDouble` "2" `nonAssociativeOpDouble` "3" == "a(a(1)b(2))b(3)" &&
    
        // try using a class
    "1" `M2.nonAssociativeOpDouble` "2" ` M2  . nonAssociativeOpDouble ` "3" == "a(a(1)b(2))b(3)" && 
    
    'a' `Prelude.Cons ` [] == (Cons 'a' []) &&
    
    'a' `Prelude. Cons` [] == (Cons 'a' []) &&
    
    1 `BackquotedTestData` 2 == (BackquotedTestData 1 2) &&
    
    1 `M2 . BackquotedTestData` 2 == (BackquotedTestData 1 2)
    
    || error "M2.testBackquotedOperators failed.";    
        
    
//////////////////////////////////////////////////////
//optimized implementation of orList
    
orListOld = foldRight or False;
/*
//this is the new optimized version in the Prelude.
orList !list =
    case list of
    [] -> False;
    listHead : listTail -> listHead || orList listTail;
    ;
*/
    
orListOldExamples :: Boolean;    
private orListOldExamples =
    not (orListOld [])
    && orListOld [True]
    && orListOld [False, False, False, True]
    && not (orListOld [False])
    && orListOld [True, True, True]
    && orListOld (repeat True)    
    && not (orListOld (replicate 100000 False)) //this is a test of proper stack usage
    || error "M2.orListOldExamples failed.";    

//////////////////////////////////////////////////////
//optimized implementation of andList
    
//:pt M2.getNthPrime 5000 with the lecc and the client jvm
//andListOld ---> 5.548 seconds
//andList ---> 3.640 seconds    
    
//andList xs returns True if every element of the list xs is True (and the list is finite). 
andListOld :: [Boolean] -> Boolean;
andListOld = foldRight and True;

/*
//this is the new optimized version in the Prelude
andList !list =
    case list of
    [] -> True;
    listHead : listTail -> listHead && andList listTail;
    ;
*/    

andListOldExamples :: Boolean;    
private andListOldExamples =
    andListOld []
    && andListOld [True]
    && not (andListOld [False])
    && andListOld [True, True, True]
    && not (andListOld (repeat False))
    && not (andListOld (True : False : repeat True))
    && andListOld (replicate 100000 True) //this is a test of proper stack usage
    || error "M2.andListOldExamples failed.";    
    
//////////////////////////////////////////////////////
//optimized implementation of any

//:pt benchmarkAny M2.anyOld 2000000 with the lecc and the client jvm takes 6.640 seconds
//:pt benchmarkAny List.any 2000000 with the lecc and the client jvm takes 5.337 seconds
//so there is a 20% speedup on this benchmark

anyOld :: (a -> Boolean) -> [a] -> Boolean;
anyOld p = Prelude.compose List.orList (List.map p);    

/*
//this is the new optimized version in the Prelude
any :: (a -> Boolean) -> [a] -> Boolean;
any p !list =
    case list of
    [] -> False;
    listHead : listTail -> p listHead || any p listTail;
    ;
*/

anyOldExamples :: Boolean;
private anyOldExamples = 
    anyOld (equals 1.0) [2.0, 3.0, 1.0]
    && anyOld (equals "apple") ["pear", "cherry", "peach", "apple", "strawberry"]
    && not (anyOld (equals 1.0) [2.0, 3.0, 5.0])
    && not (anyOld (equals 1.0) [])
    && not (anyOld (greaterThan (0 :: Int)) (upFromTo 1 100)) //the predicate is True for negative numbers
    && anyOld (greaterThan (0 :: Int)) ((upFromTo 1 100) ++ [-1])
    && anyOld (equals (200000 :: Long)) (upFromTo 1 200000) //this is a test of proper stack usage. 
    || error "M2.anyOldExamples failed.";    

benchmarkAny :: ((Long -> Boolean) -> [Long] -> Boolean) -> Long -> Boolean;
benchmarkAny anyFunc n = anyFunc (Prelude.equals n) (upFromTo 1 n);

//////////////////////////////////////////////////////
//optimized implementation of all

allOld :: (a -> Boolean) -> [a] -> Boolean;
allOld p = Prelude.compose List.andList (List.map p);

/*
//this is the optimized implementation in the Prelude.
all :: (a -> Boolean) -> [a] -> Boolean;
all p !list =
    case list of
    [] -> True;
    listHead : listTail -> p listHead && all p listTail;
    ;
*/    

allOldExamples :: Boolean;
private allOldExamples =
    allOld (equals 7.0) [7.0, 7.0, 7.0]
    && allOld (equals 2.0) []
    && allOld (equals "apple") ["apple", "apple"]
    && allOld (equals 1.0) (replicate 100000 1.0) //this is a test of proper stack usage
    || error "Prelude.allOldExamples failed."
    ;
    
//////////////////////////////////////////////////////
//optimized implementation of isElem

/*
:pt M2.isElemOld (2000000 :: Long) (Prelude.upFromTo 1 2000000) 
with lecc client took 6.234 seconds

:pt M2.isElemNew (2000000 :: Long) (Prelude.upFromTo 1 2000000) 
with lecc client took 6.246 seconds

This benchmark was done using the new optimized version of List.any.
So pretty much isElemOld is the same, or even a little faster than isElemNew.

What this means is that it mostly pays to write direct, non-higher order implementations
for the very basic recursive primitives but this is not needed at the next level of
abstraction. This is good news.
*/

isElemOld :: Eq a => a -> [a] -> Boolean;
isElemOld = Prelude.compose List.any Prelude.equals;    

isElemNew :: Eq a => a -> [a] -> Boolean;
isElemNew elem !list =
    case list of
    [] -> False;
    listHead : listTail -> 
        elem == listHead || isElemNew elem listTail;
    ;
    
//////////////////////////////////////////////////////
//optimized implementation of length

/*
using lecc client
:pt lengthOld (Prelude.upFromTo 1 (2000000 :: Long)) takes 5.580 seconds
:pt lengthNew (Prelude.upFromTo 1 (2000000 :: Long)) takes 2.433 seconds

So a 56% improvement.
*/

//Returns the length of its input list.
lengthOld :: [a] -> Int;
lengthOld = List.foldLeftStrict (\n x -> n + 1) 0;


lengthNew :: [a] -> Int;
lengthNew !list = lengthNewHelper 0 list;

lengthNewHelper :: Int -> [a] -> Int;
private lengthNewHelper !acc !list =
    case list of
    [] -> acc;
    listHead : listTail -> lengthNewHelper (acc + 1) listTail;
    ;
    
testLength =
    lengthOld (Prelude.upFromTo 1 (50000 :: Long)) == 50000
    && lengthNew (Prelude.upFromTo 1 (50000 :: Long)) == 50000
    || error "M2.testLength failed.";

//////////////////////////////////////////////////////
    
mAnd :: Prelude.Int -> Prelude.Int -> Prelude.Int;
mAnd !x y = 0; 
 
verificationError = mAnd 1 1; 
    
ternaryTest vals = 
    case vals of
    [] -> [];
    v : vs ->
        let
            z  = if (v > 0.0) then [] 
                 else [v];
        in
            z ++ (ternaryTest vs);
    ;
    
//////////////////////////////////////////////////////
//optimized implementation of findIndices

/*
benchmarked Aug 19, 2004 using lecc client
:pt List.length (M2.findIndicesOld Prelude.isEven (Prelude.upFromTo 1 (Prelude.(1 :: Int)00000)))
6.566 seconds

:pt List.length (M2.findIndicesNew Prelude.isEven (Prelude.upFromTo 1 (Prelude.(1 :: Int)00000)))
1.757 seconds

73% improvement
*/

findIndicesOld :: (a -> Boolean) -> [a] -> [Int];
findIndicesOld p xs = map snd (filter (compose p fst) (zip xs (upFrom 0)));    

findIndicesNew :: (a -> Boolean) -> [a] -> [Int];    
findIndicesNew p !list = findIndicesHelper p 0 list;

findIndicesHelper :: (a -> Boolean) -> Int -> [a] -> [Int];
private findIndicesHelper p !currentIndex !list =
    case list of
    [] -> [];
    listHead : listTail ->
        if p listHead then
            currentIndex : findIndicesHelper p (currentIndex + 1) listTail
        else
            findIndicesHelper p (currentIndex + 1) listTail;
    ;
    
testFindIndices =
    findIndicesOld isEven [(1 :: Int), 1, 4, 1, 2, 1, 1, 6] == [2, 4, 7]
    && findIndicesNew isEven [(1 :: Int), 1, 4, 1, 2, 1, 1, 6] == [2, 4, 7]
    && List.length (M2.findIndicesOld Prelude.isEven (Prelude.upFromTo 1 (10000 :: Int))) == 5000
    && List.length (M2.findIndicesNew Prelude.isEven (Prelude.upFromTo 1 (10000 :: Int))) == 5000
    || error "M2.testFindIndices failed.";

//////////////////////////////////////////////////////
//optimized implementation of removeDuplicates

/*

a test on removing duplicates for a list with no repetition

:pt List.length (removeDuplicatesByOld Prelude.equals (Prelude.upFromTo (1 :: Long) 500))
time = 3.248 seconds

:pt List.length (removeDuplicatesByNew Prelude.equals (Prelude.upFromTo (1 :: Long) 500))
time = 1.595 seconds

51% improvement


a test on removing duplicates for a list with maximal repetition 

:pt List.length (removeDuplicatesByOld Prelude.equals (List.replicate 200000 'a'))
time = 5.896 seconds

:pt List.length (removeDuplicatesByNew Prelude.equals (List.replicate 200000 'a'))
time = 4.568 seconds

23% improvement

*/

removeDuplicatesByNew :: (a -> a -> Boolean) -> [a] -> [a];
removeDuplicatesByNew eq !list = removeDuplicatesByNewHelper eq list [];

removeDuplicatesByNewHelper :: (a -> a -> Boolean) -> [a] -> [a] -> [a];
private removeDuplicatesByNewHelper eq !list accList =    
    case list of
    [] -> [];
    listHead : listTail ->
        if (isElemBy eq listHead accList) then
            removeDuplicatesByNewHelper eq listTail accList
        else
            listHead : removeDuplicatesByNewHelper eq listTail (listHead : accList);
    ;

//removeDuplicatesBy eq xs = the sublist of xs with duplicates (as determined by eq) removed. Ordering is preserved.
//e.g. removeDuplicatesBy equals [3, 3, 1, 1, 3, 4, 1] = [3, 1, 4]
removeDuplicatesByOld :: (a -> a -> Boolean) -> [a] -> [a];
removeDuplicatesByOld eq !xs =
    let
        notEq eq x y = not (eq x y);
    in
        case xs of
        [] -> [];
        xs_head : xs_tail -> xs_head : removeDuplicatesByOld eq (filter (notEq eq xs_head) xs_tail);
        ;        

private removeDuplicatesByOldExamples =
    removeDuplicatesByOld Prelude.equals [3.0, 3, 1, 1, 3, 4, 1] == [3, 1, 4]
    && removeDuplicatesByOld Prelude.equals (toList "delete = deleteBy equals;") == toList "delt =Byquas;"
    && length (removeDuplicatesByOld Prelude.equals (Prelude.upFromTo (1 :: Long) 50)) == 50
    && length (removeDuplicatesByOld Prelude.equals (List.replicate 10000 'a')) == 1
    || error "M2.removeDuplicatesOldExamples failed.";

//////////////////////////////////////////////////////
//sumUp

sumUp :: Long -> Long;    
sumUp !n = sumUpHelper n 0;

sumUpHelper :: Long -> Long -> Long;
sumUpHelper !n !acc = 
    if n == 0 then
        acc
    else
        sumUpHelper (n-1) (acc + n);
        
        
//////////////////////////////////////////////////////

//letters is an example of a large recursive let block that cannot be lifted
letters :: [Char];
letters =
    let
        abcde = 'a'    : bcdea;
        bcdea = 'b' : cdeab;
        cdeab = 'c' : deabc;
        deabc = 'd' : eabcd;
        eabcd = 'e' : abcde;
    in
        abcde;
        
//letters2 is similar to letters, but we've scrambled the order of the bindings
//just to show that we can do this!
letters2 :: [Char];
letters2 =
    let
        bcdea = 'B' : cdeab;
        deabc = 'D' : eabcd;
        eabcd = 'E' : abcde;
        abcde = 'A'    : bcdea;        
        cdeab = 'C' : deabc;
    in
        abcde;        
        
        
testLetters =    
    drop 99994 (take 100000 letters) == ['e', 'a', 'b', 'c', 'd', 'e']
    && drop 99994 (take 100000 letters2) == ['E', 'A', 'B', 'C', 'D', 'E']
    || error "M2.testLetters failed.";
    
testLiftTests =
    liftTest1 1 == (9, 29)
    && liftTest2 7 == 17
    && liftTest3 50 100 == (200, 150)
    && liftTest4 "hello" == 50
    && liftTest5 9 99 == [-509, -507, -502]
    && liftTest5_1 9 99 == [-509, -507, -502]
    && liftTest5_2 9 99 == [-509, -507, -502]
    && lifter 10 == 135
    && lifter2 100 1 == 5050
    || error "M2.testLiftTests failed.";    

//the local function liftTest1 has exactly the same name as the top-level function.
//this can cause a problem for a Johnsson-style lambda lifter.    
liftTest1 x =
    let
        liftTest1 u v = u*v - x;
    in
        (liftTest1 2.0 5.0, liftTest1 5.0 6.0);

//it is not illegal for an argument to have the same name as the function
//this example carries things to extremes        
liftTest2 liftTest2 =    
    (
    let
        liftTest2 liftTest2 v = liftTest2 * v;
    in
        liftTest2 5.0 2.0
    ) + liftTest2;
    
liftTest3 :: Int -> Int -> (Int, Int);    
liftTest3 u v =
    let
        //u is free in f
        f v = 
            if v == 0 then
                v
            else
                u + g (v - 1);
        //v is free in u
        g u =
            if u == 0 then
                u
            else
                v + f (u - 1);
    in
        (f 3, g 2);

//this is a tricky test for the Johnsson-style lambda lifter.
//the functions f and g need to be lifted to the top level with the free variable
//in f, str, added as an extra argument to g, so that it can be passed at the f
//call site in the definition of g. The problem is that this will result in
//g str str, which will cause a problem. This is a subtle kind of name clash problem.        
liftTest4 :: String -> Int;    
liftTest4 str =
    let
        //str is free in f and of String type
        f x = String.length str + g (x - 1);
        //str is bound, and of Int type
        g str =
            if str == 0 then
                str
            else
                f (str - 0);
    in
        g 10;
        
        
//a comparison of lifting approaches...
liftTest5 :: Int -> Int -> [Int];
liftTest5 x y =
    let
        g u v = u - 2*x + 3*v - 5*y;
    in
        [g 1 1, g 3 1, g 2 3];
        
//usual lambda lifting
liftTest5_1 :: Int -> Int -> [Int];
liftTest5_1 x y =
    let
        g = liftTest5_1_helper x y;
    in
        [g 1 1, g 3 1, g 2 3];
        
liftTest5_1_helper x y u v = u - 2*x + 3*v - 5*y;

//Johnsson-style lambda lifting
liftTest5_2 :: Int -> Int -> [Int];
liftTest5_2 x y =    
    [liftTest5_2_helper x y 1 1, liftTest5_2_helper x y 3 1, liftTest5_2_helper x y 2 3];

liftTest5_2_helper x y u v = u - 2*x + 3*v - 5*y;

//this is from SPJ/Lester pg 244
//there is a mutual dependecy between g, h, k. g and h are functions and lifted, but not k.
liftTest6 x y =
    let
        g p = h p + x;
        h q = k + y + q;
        k = g y;
    in
        g 4.0;
       
liftTest6_1 x y =
    let
        k = liftTest6_g x y k y;
    in
        liftTest6_g x y k 4.0;        

liftTest6_g x y k p = liftTest6_h x y k p + x;
liftTest6_h x y k q = k + y + q;

//x is not used in liftTest6_h so it would be better if this was:
//liftTest6_g x y k p = liftTest6_h y k p + x;
//liftTest6_h y k q = k + y + q;        
        
/////////////////////////////////////////////////////////
                
data Stuff = 
    Stuff       stuff   :: Prelude.Integer;

instance Eq Stuff where
    equals = equalsStuff;
    notEquals = notEqualsStuff;
    ;

private equalsStuff s1 s2 = 
    case s1 of
    Stuff v1 ->
        case s2 of
        Stuff v2 -> v1 == v2;
        ;
    ;

private notEqualsStuff s1 s2 = not (equalsStuff s1 s2);

//the potential problem here is that the equals in testStuff resolves to the instance method equalsStuff. This is a potential
//clash with the local function equalsStuff. Indeed it used to cause non-termination.
testStuff = not (
    let
        equalsStuff :: Stuff -> Stuff -> Boolean;
        equalsStuff calc1 calc2 = (equals calc1 calc2);
    in
       equalsStuff (Stuff 1) (Stuff 2));

//////////////////////////////////////////////    

//a version of sum written using a local functions
sum2 :: [Long] -> Long;
sum2 !list =
    let
        sum2Helper :: [Long] -> Long -> Long;
        sum2Helper !list !acc =
            case list of
            [] -> acc;
            listHead : listTail -> sum2Helper listTail (acc + listHead);
        ;    
    in
        sum2Helper list 0;

//the traditionally lambda lifted version of sum2
//notice that the defining expression of the lifted function, and the in part 
//of the let remain unchanged from their corresponding parts in sum2.
sum2LiftedTraditionally :: [Long] -> Long;        
sum2LiftedTraditionally !list =
    let
        sum2Helper :: [Long] -> Long -> Long;
        sum2Helper = sum2HelperLiftedTraditionally sum2Helper;
    in
        sum2Helper list 0;

sum2HelperLiftedTraditionally :: ([Long] -> Long -> Long) -> [Long] -> Long -> Long;
sum2HelperLiftedTraditionally sum2Helper !list !acc =
    case list of
    [] -> acc;
    listHead : listTail -> sum2Helper listTail (acc + listHead);
    ;    
    
//the Johnsson lambda lifted version of sum2. Notice that the lifted function
//is tail recursive.
sum2JohnssonLifted :: [Long] -> Long;
sum2JohnssonLifted !list = sum2HelperJohnssonLifted list 0;

sum2HelperJohnssonLifted :: [Long] -> Long -> Long;
private sum2HelperJohnssonLifted !list !acc =
    case list of
    [] -> acc;
    listHead : listTail -> sum2HelperJohnssonLifted listTail (acc + listHead);
    ;    

lifter :: Int -> Int;    
lifter !x =
    let
        f y =
            let
                g z =
                    let
                        h w = x + 2*y + 3*z + 4*w;
                    in
                        h (z + 3);
            in
                g (y + 2);
    in
        f (x + 1);
        
lifter2 :: Int -> Int -> Int;
lifter2    n w =
    let
        f x =
            let
                g y =
                    let
                        h z =
                            if z == 0 then
                                0
                            else
                                f (x-w) + z;
                    in
                        h y;
            in
                g x;
    in
        f n;

testArgTypeLifting :: Prelude.Char -> [Prelude.Char] -> Prelude.Boolean -> Prelude.Int -> Prelude.Double;
testArgTypeLifting charArg !strictListCharArg boolArg !strictIntArg =
    let         
        f localDouble !strictLocalInteger localMaybeInt =
            (strictIntArg, charArg, strictListCharArg, boolArg, Math.sin localDouble, [strictLocalInteger, 2 :: Prelude.Integer], [localMaybeInt, Prelude.Just (2 :: Int)]);
    in
        2.0;
                
equalsFunny = Prelude.equals;    


//the old less optimal version of List.outputListWith
//Note that both of the main recursive function (foldlStrict in the old version and 
//outputListHelper in the new take the same number of arguments, and have the tail
//recursion optimization apply. outputListHelper can take advantage of an unboxed
//JList argument, and its implementation is a little simpler than foldlStrict.

outputListWithOld :: [a] -> (a -> JObject) -> JList;
outputListWithOld !list elementMappingFunction =
    let
        //type type variable a is non-generic so can't actually have this type declaration
        //foldFunction :: JList -> a -> JList;
        foldFunction !javaList element =
            if jList_add javaList (elementMappingFunction element) then
                javaList
            else
                error "List.outputListWith: adding an element to a Java list failed.";
    in
        foldLeftStrict foldFunction jArrayList_new list;        
                          
foreign unsafe import jvm "constructor java.util.ArrayList" private jArrayList_new :: JList;
foreign unsafe import jvm "method add" private jList_add :: JList -> JObject -> Boolean;
foreign unsafe import jvm "method size" private jList_size :: JList -> Int;
foreign unsafe import jvm "method get" private jList_get :: JList -> Int -> JObject;

foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.M2.Cast.objectToList"
     cast_JObjectToJList :: JObject -> JList;

testOutputListWithOld =
    Prelude.input (Prelude.output (outputListWithOld (upFromTo 1.0 5.0) Prelude.output)) == [1.0, 2.0, 3.0, 4.0, 5.0]
    && Prelude.input (Prelude.output (outputListWithOld (upFromTo LT GT) Prelude.output)) == [LT, EQ, GT];
    
inputListWithOld :: JList -> (JObject -> a) -> [a];
inputListWithOld !javaList elementMappingFunction =
    map (compose elementMappingFunction (jList_get javaList)) (take (jList_size javaList) (upFrom 0));        
                    
testInputListWithOld = 
    List.sum (inputListWithOld (cast_JObjectToJList (Prelude.output (upFromTo ((1 :: Int)) 1000))) Prelude.input) + (0 :: Int) == 500500;            

////////////////////////////////////////////////////////////////////
//Basic comparison of the cost of certain record operations compared to
//the corresponding operations with tuples

/*
unzip3 :: [(a,b,c)] -> ([a],[b],[c]);                  
unzip3 !list =
    case list of
    [] -> ([], [], []);
    x : xs ->    
        let
            //ys :: ([a], [b], [c]);
            ys = unzip3 xs;            
        in
            case x of
            (x1, x2, x3) ->
                //do not do a "case" on the ys, since this makes unzip3 strictly evaluate the list!
                (x1 : field1 ys, x2 : field2 ys, x3 : field3 ys);
            ;
    ;
*/

recUnzip3 :: [{field1 :: a, field2 :: b, field3 :: c}] -> {field1 :: [a], field2 :: [b], field3 :: [c]};
recUnzip3 !list =
    case list of
    [] -> {field1 = [], field2 = [], field3 = []};
    x : xs ->    
        let            
            ys = recUnzip3 xs;            
        in
            case x of
            {field1 = x1, field2 = x2, field3 = x3} ->
                //do not do a "case" on the ys, since this makes unzip3 strictly evaluate the list!
                {field1 = x1 : ys.field1, field2 = x2 : ys.field2, field3 = x3 : ys.field3};
            ;
    ;
    
tupRecUnzip3 :: [{#1 :: a, #2 :: b, #3 :: c}] -> {#1 :: [a], #2 :: [b], #3 :: [c]};
tupRecUnzip3 !list =
    case list of
    [] -> {#1 = [], #2 = [], #3 = []};
    x : xs ->    
        let            
            ys = tupRecUnzip3 xs;            
        in
            case x of
            {#1 = x1, #2 = x2, #3 = x3} ->
                //do not do a "case" on the ys, since this makes unzip3 strictly evaluate the list!
                {#1 = x1 : ys.#1, #2 = x2 : ys.#2, #3 = x3 : ys.#3};
            ;
    ;    

tupleData :: Int -> [(String, Int, Int)];
tupleData !n =
    let
        tupleDataHelper !i =
            if (i == n) then
                []
            else
                ("Anton", i, n - i) : tupleDataHelper (i + 1);
    in
        tupleDataHelper 0;   
    
recData :: Int -> [{field1 :: String, field2 :: Int, field3 :: Int}];
recData !n =
    let
        recDataHelper !i =
            if (i == n) then
                []
            else
                {field1 = "Anton", field2 = i, field3 = n - i} : recDataHelper (i + 1);
    in
        recDataHelper 0;
    
tupRecData :: Int -> [{#1 :: String, #2 :: Int, #3 :: Int}];
tupRecData !n =
    let
        recDataHelper !i =
            if (i == n) then
                []
            else
                {#1 = "Anton", #2 = i, #3 = n - i} : recDataHelper (i + 1);
    in
        recDataHelper 0;     
    
tupleSumLast :: Int -> Int;
tupleSumLast n = sum (map field3 (tupleData n));

fieldNamedField3 !x = x.field3;

recSumLast :: Int -> Int;
recSumLast n = sum (map fieldNamedField3 (recData n));

tupRecField3 !x = x.#3;

tupRecSumLast :: Int -> Int;
tupRecSumLast n = sum (map tupRecField3 (tupRecData n));

//benchmark run around Sept 22-28, 2004
//
//running: tupleSumLast 500000
//Summary:    time = 3,771
//
//running: recSumLast 500000
//Summary:    time = 6,166
//
//tuples are 38.8% faster than records for this benchmark

tupleSort :: Int -> Int;
tupleSort n = field3 (last (sortBy (\x y -> (compare (field3 x) (field3 y))) (tupleData n)));

recSort :: Int -> Int;
recSort n = (last (sortBy (\x y -> (compare x.field3 y.field3)) (recData n))).field3;

tupRecSort :: Int -> Int;
tupRecSort n = (last (sortBy (\x y -> (compare x.#3 y.#3)) (tupRecData n))).#3;

//benchmark run around Sept 22-28, 2004
//
//running: tupleSort 100000
//Summary:    time = 6,088
//
//running: recSort 100000
//Summary:    time = 6,604
//
//tuples are 7.8% faster than records for this benchmark

//benchmark run around Sept 22-28, 2004
//
//this benchmark shows the overhead of using Eq type class methods. With records, the fields must be sorted 
//alphabetically at runtime, which is probably a big cause of the overhead below.
//
//running: List.length (List.group (tupleData 500000))
//Summary:    time = 6,671
//
//List.length (List.group (recData 500000))
//Summary:    time = 11,219
//
//tuples are 40.5% faster than records for this benchmark

tupleUnzip :: Int -> Int;
tupleUnzip n = length (field3 (unzip3 (tupleData n)));

recUnzip :: Int -> Int;
recUnzip n = length ((recUnzip3 (recData n)).field3);

tupRecUnzip :: Int -> Int;
tupRecUnzip n = length ((tupRecUnzip3 (tupRecData n)).#3);

//benchmark run around Sept 22-28, 2004
//
//running: tupleUnzip 800000
//Summary:    time = 3,437
//
//running: recUnzip 800000
//Summary:    time = 6,099
//
//tuples are 43.6% faster than records for this benchmark

workbookTupleData :: Int -> [(String, Int)];
workbookTupleData n = 
    List.take n (List.zip (List.cycle ["Minuet", "Waltz", "Sarabande", "Courante", "Gigue"]) (Prelude.upFrom (1 :: Int)));

workbookBenchmark4TupleSimulation :: Int -> [([(String, Int)], Int)];
workbookBenchmark4TupleSimulation n =
    let
        primaryChannel = workbookTupleData n;
        sortedData = sortBy (\x y -> compare (fst x) (fst y)) primaryChannel;
        groupedData :: [[(String, Int)]];
        groupedData = groupBy (\x y -> (fst x) == (fst y)) sortedData;
        summary :: [Int];
        summary = map (\listOfPairs -> sum (snd (unzip listOfPairs))) groupedData;
    in
        zip groupedData summary;

//benchmark run around Sept 22-28, 2004
//
//this shows that the reason EaselBenchmarks.workbookBenchmark4 10000 takes about 25 seconds
//is not related to the data processing part of things...
//running: workbookBenchmark4TupleSimulation 10000
//Summary:    time = 1,203
    
recZip :: [a] -> [b] -> [{field1 :: a, field2 :: b}];
recZip !list1 list2 =
    case list1 of
    x : xs ->
        case list2 of
        y : ys -> {field1 = x, field2 = y} : recZip xs ys;
        [] -> [];
        ;
    [] -> [];
    ;    

recUnzip2 :: [{field1 :: a, field2 :: b}] -> {field1 :: [a], field2 :: [b]};
recUnzip2 !list =
    case list of
    [] -> {field1 = [], field2 = []};
    x : xs ->    
        let            
            ys = recUnzip2 xs;            
        in
            case x of
            {field1 = x1, field2 = x2} ->
                //do not do a "case" on the ys, since this makes unzip3 strictly evaluate the list!
                {field1 = x1 : ys.field1, field2 = x2 : ys.field2};
            ;
    ;
    
workbookRecData :: Int -> [{field1 :: String, field2 :: Int}];
workbookRecData n = 
    List.take n (recZip (List.cycle ["Minuet", "Waltz", "Sarabande", "Courante", "Gigue"]) (Prelude.upFrom (1 :: Int)));

workbookBenchmark4RecSimulation :: Int -> [([{field1 :: String, field2 :: Int}], Int)];
workbookBenchmark4RecSimulation n =
    let
        primaryChannel = workbookRecData n;
        sortedData = sortBy (\x y -> compare x.field1 y.field1) primaryChannel;
        groupedData :: [[{field1 :: String, field2 :: Int}]];
        groupedData = groupBy (\x y -> x.field1 == y.field1) sortedData;
        summary :: [Int];
        summary = map (\listOfRecs -> sum ((recUnzip2 listOfRecs).field2)) groupedData;
    in
        zip groupedData summary;
    
tupRecZip :: [a] -> [b] -> [{#1 :: a, #2 :: b}];
tupRecZip !list1 list2 =
    case list1 of
    x : xs ->
        case list2 of
        y : ys -> {#1 = x, #2 = y} : tupRecZip xs ys;
        [] -> [];
        ;
    [] -> [];
    ;    

tupRecUnzip2 :: [{#1 :: a, #2 :: b}] -> {#1 :: [a], #2 :: [b]};
tupRecUnzip2 !list =
    case list of
    [] -> {#1 = [], #2 = []};
    x : xs ->    
        let            
            ys = tupRecUnzip2 xs;            
        in
            case x of
            {#1 = x1, #2 = x2} ->
                //do not do a "case" on the ys, since this makes unzip3 strictly evaluate the list!
                {#1 = x1 : ys.#1, #2 = x2 : ys.#2};
            ;
    ;
    
workbookTupRecData :: Int -> [{#1 :: String, #2 :: Int}];
workbookTupRecData n = 
    List.take n (tupRecZip (List.cycle ["Minuet", "Waltz", "Sarabande", "Courante", "Gigue"]) (Prelude.upFrom (1 :: Int)));

workbookBenchmark4TupRecSimulation :: Int -> [([{#1 :: String, #2 :: Int}], Int)];
workbookBenchmark4TupRecSimulation n =
    let
        primaryChannel = workbookTupRecData n;
        sortedData = sortBy (\x y -> compare x.#1 y.#1) primaryChannel;
        groupedData :: [[{#1 :: String, #2 :: Int}]];
        groupedData = groupBy (\x y -> x.#1 == y.#1) sortedData;
        summary :: [Int];
        summary = map (\listOfRecs -> sum ((tupRecUnzip2 listOfRecs).#2)) groupedData;
    in
        zip groupedData summary;    
    
    
//benchmark run around Sept 22-28, 2004
//    
//running: workbookBenchmark4TupleSimulation 30000
//Summary:    time = 4,156    
//
//running: workbookBenchmark4RecSimulation 30000
//Summary:    time = 4,645
//
//tuples are 10.5% faster than records for this benchmark
    
bigTupleData :: Int -> [(String, Int, Int, Int, Int, Int, Int)];
bigTupleData !n =
    let
        tupleDataHelper !i =
            if (i == n) then
                []
            else
                ("Anton", i, n - i, 40, 50, 60, 70) : tupleDataHelper (i + 1);
    in
        tupleDataHelper 0;   
    
bigRecData :: Int -> [{field1 :: String, field2 :: Int, field3 :: Int, field4 :: Int, field5 :: Int, field6 :: Int, field7 :: Int}];
bigRecData !n =
    let
        recDataHelper !i =
            if (i == n) then
                []
            else
                {field1 = "Anton", field2 = i, field3 = n - i, field4 = 40, field5 = 50, field6 = 60, field7 = 70} : recDataHelper (i + 1);
    in
        recDataHelper 0; 
    
bigTupRecData :: Int -> [{#1 :: String, #2 :: Int, #3 :: Int, #4 :: Int, #5 :: Int, #6 :: Int, #7 :: Int}];
bigTupRecData !n =
    let
        recDataHelper !i =
            if (i == n) then
                []
            else
                {#1 = "Anton", #2 = i, #3 = n - i, #4 = 40, #5 = 50, #6 = 60, #7 = 70} : recDataHelper (i + 1);
    in
        recDataHelper 0;     

//benchmark run around Sept 22-28, 2004
//remember to suppress output when running the benchmark in ICE
//    
//running: bigTupleData 200000
//Summary:    time = 8,885 
//
//running: bigRecData 200000
//Summary:    time = 12,109
//
//tuples are 26.6% faster than records for this benchmark   
    
//////////////////////////////////////////////////////////////////////
//some explicit uses of textual forms of type constructors.
    
textualUnit :: Prelude.Unit;    
textualUnit = ();

textualTuple :: {#1 :: Double, #2 :: Char};
textualTuple = (2.0, 'a');

textualFunction :: Prelude.Function a a;
textualFunction = Prelude.id;

textualList :: Prelude.List a -> a;
textualList = List.head;

textualList2 :: Prelude.Function (Prelude.List a) a;
textualList2 = List.head;

//data foreign unsafe import jvm private "int" MyInt;

//////////////////////////////////////////////////////////////////////
//tests of expression type signatures

testExpressionTypeSignatures =
    (1 :: Int) == 1
    && (let myFst = Prelude.fst :: ([Int], Char) -> [Prelude.Int]; in myFst ([], 'a')) == []
    && (let myFst2 = Prelude.fst :: ([a], a) -> [a]; in myFst2 ([], 'a')) == []
    && (let myFst3 = Prelude.fst :: Num a => (a, a) -> a; in myFst3 (2, 5 :: Int)) == 2
    || error "M2.testExpressionTypeSignatures failed.";
                                                                              

//////////////////////////////////////////////////////////////////////
//tests of add hoc record instances

//create an alternative class inheritence hierarchy to the similar classes in the Prelude.
//Unlike the Prelude version, we have a diamond shaped inheritence hierarchy. This is also intended to
//test ad-hoc record instances without bumping into generic record instances.

class EqAlt a => OrdAlt a where
    lessThanAlt :: a -> a -> Boolean;
    minAlt :: a -> a -> a;
    ;

class EqAlt a where
    equalsAlt :: a -> a -> Boolean;
    notEqualsAlt :: a -> a -> Boolean;
    ;
    
class EqAlt a => NumAlt a where
    addAlt :: a -> a -> a;
    subtractAlt :: a -> a -> a;
    ;

class (OrdAlt a, NumAlt a, BoundedAlt a) => EnumAlt a where
    upFromToAlt :: a -> a -> [a];
    ;
    
class BoundedAlt a where
    minBoundAlt :: a;
    maxBoundAlt :: a;
    ;
    
class ShowAlt a where
    showAlt :: a -> String;
    ;
    
instance EqAlt Int where
    equalsAlt = equalsAltInt;
    notEqualsAlt = notEqualsAltInt;
    ;

equalsAltInt :: Int -> Int -> Boolean;   
equalsAltInt = Prelude.equals;

notEqualsAltInt :: Int -> Int -> Boolean;
notEqualsAltInt = Prelude.notEquals;

instance OrdAlt Int where
    lessThanAlt = lessThanAltInt;
    minAlt = minAltInt;
    ;

lessThanAltInt :: Int -> Int -> Boolean;
lessThanAltInt = Prelude.lessThan;

minAltInt :: Int -> Int -> Int;
minAltInt = Prelude.min;

instance NumAlt Int where
    addAlt = addAltInt;
    subtractAlt = subtractAltInt;
    ;
    
addAltInt :: Int -> Int -> Int;
addAltInt = Prelude.add;

subtractAltInt :: Int -> Int -> Int;
subtractAltInt = Prelude.subtract;

instance EnumAlt Int where
    upFromToAlt = upFromToAltInt;
    ;
    
upFromToAltInt :: Int -> Int -> [Int];
upFromToAltInt = Prelude.upFromTo;

instance BoundedAlt Int where
    minBoundAlt = minBoundAltInt;
    maxBoundAlt = maxBoundAltInt;
    ;
    
minBoundAltInt :: Int;
minBoundAltInt = Prelude.minBound;

maxBoundAltInt :: Int;
maxBoundAltInt = Prelude.maxBound;

instance ShowAlt Int where
    showAlt = showAltInt;
    ;
    
showAltInt :: Int -> String;
showAltInt = Prelude.intToString;



instance (EqAlt a) => EqAlt (Maybe a) where
    equalsAlt = equalsAltMaybe;
    notEqualsAlt = notEqualsAltMaybe;
    ;

equalsAltMaybe :: (EqAlt a) => Maybe a -> Maybe a -> Boolean;   
private equalsAltMaybe !m1 !m2 =
    case m1 of
    Nothing ->
        case m2 of    
        Nothing -> True;
        Just x2 -> False;
        ;
    Just x1 ->
        case m2 of
        Nothing -> False;
        Just x2 -> equalsAlt x1 x2;
        ;
    ;

notEqualsAltMaybe :: (EqAlt a) => Maybe a -> Maybe a -> Boolean;
notEqualsAltMaybe !m1 !m2 = Prelude.not (equalsAlt m1 m2);

instance (OrdAlt a) => OrdAlt (Maybe a) where
    lessThanAlt = lessThanAltMaybe;
    minAlt = minAltMaybe;
    ;

lessThanAltMaybe :: (OrdAlt a) => Maybe a -> Maybe a -> Boolean;
private lessThanAltMaybe !m1 !m2 =
    case m1 of
    Nothing ->
        case m2 of
        Nothing -> False;
        Just x2 -> True;
        ;    
    Just x1 ->
        case m2 of
        Nothing -> False;
        Just x2 -> lessThanAlt x1 x2;
        ;
    ;    

minAltMaybe :: (OrdAlt a) => Maybe a -> Maybe a -> Maybe a;
private minAltMaybe !x !y = if lessThanAlt x y then x else y;

instance NumAlt a => NumAlt (Maybe a) where
    addAlt = addAltMaybe;
    subtractAlt = subtractAltMaybe;
    ;
    
addAltMaybe :: NumAlt a => Maybe a -> Maybe a -> Maybe a;
addAltMaybe !m1 !m2 =
    case m1 of
    Nothing -> Nothing;
    Just x1 ->
        case m2 of
        Nothing -> Nothing;
        Just x2 -> Just (addAlt x1 x2);
        ;
    ;    

subtractAltMaybe :: NumAlt a => Maybe a -> Maybe a -> Maybe a;
subtractAltMaybe  !m1 !m2 =
    case m1 of
    Nothing -> Nothing;
    Just x1 ->
        case m2 of
        Nothing -> Nothing;
        Just x2 -> Just (subtractAlt x1 x2);
        ;
    ;    

instance (EnumAlt a) => EnumAlt (Maybe a) where
    upFromToAlt = upFromToAltMaybe;
    ;
    
upFromToAltMaybe :: (EnumAlt a) => Maybe a -> Maybe a -> [Maybe a];
upFromToAltMaybe  !m1 !m2 =
    case m1 of
    Nothing -> 
        case m2 of
        Nothing -> [Nothing];
        Just x2 -> Nothing : (map Just (upFromToAlt minBoundAlt x2));
        ;       
    Just x1 ->
        case m2 of
        Nothing -> [];
        Just x2 -> map Just (upFromToAlt x1 x2);
        ;
    ;    

instance (BoundedAlt a) => BoundedAlt (Maybe a) where
    minBoundAlt = minBoundAltMaybe;
    maxBoundAlt = maxBoundAltMaybe;
    ;
    
minBoundAltMaybe :: (BoundedAlt a) => Maybe a;
minBoundAltMaybe = Nothing;

maxBoundAltMaybe :: (BoundedAlt a) => Maybe a;
maxBoundAltMaybe  = Just maxBoundAlt;

instance (ShowAlt a) => ShowAlt (Maybe a) where
    showAlt = showAltMaybe;
    ;
    
showAltMaybe :: (ShowAlt a) => Maybe a -> String;
showAltMaybe !m =
    case m of
    Nothing -> "Nothing";
    Just x -> "(Just " ++ showAlt x ++ ")";
    ;
    
/*    
instance (EqAlt a, EqAlt b) => EqAlt {#1 :: a, #2 :: b} where
    equalsAlt = equalsAltTupRec2;
    notEqualsAlt = notEqualsAltTupRec2;
    ;

equalsAltTupRec2 :: (EqAlt a, EqAlt b) => {#1 :: a, #2 :: b} -> {#1 :: a, #2 :: b} -> Boolean;   
equalsAltTupRec2 !r1 !r2 = (equalsAlt r1.#1 r2.#1) && (equalsAlt r1.#2 r2.#2);

notEqualsAltTupRec2 :: (EqAlt a, EqAlt b) => {#1 :: a, #2 :: b} -> {#1 :: a, #2 :: b} -> Boolean;
notEqualsAltTupRec2 !r1 !r2 = (notEqualsAlt r1.#1 r2.#1) || (notEqualsAlt r1.#2 r2.#2);

instance (OrdAlt a, OrdAlt b) => OrdAlt {#1 :: a, #2 :: b} where
    lessThanAlt = lessThanAltTupRec2;
    minAlt = minAltTupRec2;
    ;

lessThanAltTupRec2 :: (OrdAlt a, OrdAlt b) => {#1 :: a, #2 :: b} -> {#1 :: a, #2 :: b} -> Boolean;
lessThanAltTupRec2 !r1 !r2 = (lessThanAlt r1.#1 r2.#1) || (equalsAlt r1.#1 r2.#1 && (lessThanAlt r1.#2 r2.#2));

minAltTupRec2 :: (OrdAlt a, OrdAlt b) => {#1 :: a, #2 :: b} -> {#1 :: a, #2 :: b} -> {#1 :: a, #2 :: b};
minAltTupRec2 !x !y = if lessThanAlt x y then x else y;

instance (NumAlt a, NumAlt b) => NumAlt {#1 :: a, #2 :: b} where
    addAlt = addAltTupRec2;
    subtractAlt = subtractAltTupRec2;
    ;
    
addAltTupRec2 :: (NumAlt a, NumAlt b) => {#1 :: a, #2 :: b} -> {#1 :: a, #2 :: b} -> {#1 :: a, #2 :: b};
addAltTupRec2 !r1 !r2 = {#1 = addAlt r1.#1 r2.#1, #2 = addAlt r1.#2 r2.#2};

subtractAltTupRec2 :: (NumAlt a, NumAlt b) => {#1 :: a, #2 :: b} -> {#1 :: a, #2 :: b} -> {#1 :: a, #2 :: b};
subtractAltTupRec2 !r1 !r2 = {#1 = subtractAlt r1.#1 r2.#1, #2 = subtractAlt r1.#2 r2.#2};

instance (EnumAlt a, EnumAlt b) => EnumAlt {#1 :: a, #2 :: b} where
    upFromToAlt = upFromToAltTupRec2;
    ;
    
upFromToAltTupRec2 :: (EnumAlt a, EnumAlt b) => {#1 :: a, #2 :: b} -> {#1 :: a, #2 :: b} -> [{#1 :: a, #2 :: b}];
upFromToAltTupRec2 !r1 !r2 = 
    let
        list1 = upFromToAlt r1.#1 r2.#1;
        list2 = upFromToAlt r2.#1 r2.#2;
        f x = map  (\y -> {#1 = x, #2 = y}) list2;
    in
        List.concatMap f list1;
               
instance (BoundedAlt a, BoundedAlt b) => BoundedAlt {#1 :: a, #2 :: b} where
    minBoundAlt = minBoundAltTupRec2;
    maxBoundAlt = maxBoundAltTupRec2;
    ;
    
minBoundAltTupRec2 :: (BoundedAlt a, BoundedAlt b) => {#1 :: a, #2 :: b};
minBoundAltTupRec2 = {#1 = minBoundAlt, #2 = minBoundAlt};

maxBoundAltTupRec2 :: (BoundedAlt a, BoundedAlt b) => {#1 :: a, #2 :: b};
maxBoundAltTupRec2 = {#1 = maxBoundAlt, #2 = maxBoundAlt};

instance ShowAlt {#1 :: a, #2 :: b} where
    showAlt = showAltTupRec2;
    ;
    
showAltTupRec2 :: (ShowAlt a, ShowAlt b) => {#1 :: a, #2 :: b} -> String;
showAltTupRec2 !r = "{#1 = " ++ showAlt r.#1 ++ ", #2 = " ++ showAlt r.#2 ++ "}";  
*/    
    
    
    
//alt instances test function
ai1 :: (EnumAlt a, ShowAlt a) => a -> a -> ([Boolean], [a], [a], String, String);  
ai1 x y = ([equalsAlt x y, notEqualsAlt x y, lessThanAlt x y],
           [minAlt x y, addAlt x y, subtractAlt x y, minBoundAlt, maxBoundAlt],
           upFromToAlt x y, showAlt x, showAlt y); 

ai2 :: (EnumAlt a, ShowAlt a) => a -> a -> (a, Boolean, a);  
ai2 x y = ai2Helper x y;

ai2Helper :: (NumAlt a, OrdAlt a, BoundedAlt b) => a -> a -> (b, Boolean, a);
ai2Helper x y = (maxBoundAlt, lessThanAlt x y, subtractAlt x y);


    
testAltInstances =
    ai1 (5 :: Int) 7 == ([False, True, True], [5, 12, -2, Prelude.minBound, Prelude.maxBound], [5, 6, 7], "5", "7")
    && ai1 (Just (5 :: Int)) (Just 7) == ([False, True, True], [Just 5, Just 12, Just (-2), Nothing, Just Prelude.maxBound], [Just 5, Just 6, Just 7], "(Just 5)", "(Just 7)")
    && ai1 (Nothing :: Maybe (Maybe Int)) Nothing == ([True, False, False], [Nothing, Nothing, Nothing, Nothing, Just (Just Prelude.maxBound)], [Nothing], "Nothing", "Nothing")
    && ai2 (9 :: Int) 20 == (Prelude.maxBound, True, -11)
    && ai2 (Just (9 :: Int)) (Just 20) == (Just (Prelude.maxBound), True, Just (-11))
    && ai2 (Nothing :: Maybe (Maybe (Maybe Int))) Nothing == ((Just (Just (Just Prelude.maxBound))), False, Nothing) 
    || error "M2.testAltInstances failed.";
    

capsTest = 1.0;
capstest = 2.0;
lpt1 = 3.0;
lPt1 = 4.0;
aux = 5.0;
aUx = 6.0;

data CapsTestType1 = CTT1A | CTT1a | Ctt1a;
data Capstesttype1 = CTt1A | CtT1a | CtT1A;

capsData1Test x = 
    case x of
    CTT1A -> "CTT1A";
    CTT1a -> "CTT1a";
    Ctt1a -> "Ctt1a";
    ;
capsData2Test x =
    case x of
        CTt1A -> "CTt1A";
        CtT1a -> "CtT1a";
        CtT1A -> "CtT1A";
        ;
        
class CapsShow f where
    sHOw :: f -> Prelude.String;
    ;
class Capsshow f where
    shOw :: f -> Prelude.String;
    ;
instance CapsShow CapsTestType1 where
    sHOw = sHOwCapsTestType1;
    ;
instance Capsshow CapsTestType1 where
    shOw = shOwCapsTestType1;
    ;
instance CapsShow Capstesttype1 where
    sHOw = sHOwCapstesttype1;
    ;
instance Capsshow Capstesttype1 where
    shOw = shOwCapstesttype1;
    ;
sHOwCapsTestType1 x = "sHOwCapsTestType1" ++ (capsData1Test x);
shOwCapsTestType1 x = "shOwCapsTestType1" ++ (capsData1Test x);
sHOwCapstesttype1 x = "sHOwCapstesttype1" ++ (capsData2Test x);
shOwCapstesttype1 x = "shOwCapstesttype1" ++ (capsData2Test x);

instanceShow1 :: (CapsShow a) => a -> String;            
instanceShow1 a = sHOw a;

instanceShow2 :: (Capsshow a) => a -> String;            
instanceShow2 a = shOw a;

capsArgs :: Prelude.Double -> Prelude.Double -> Prelude.Double;
capsArgs arg aRg = arg - aRg;

capsLets :: Prelude.Double -> Prelude.Double -> Prelude.Double;
capsLets arg aRg =
    let 
        foo = arg;
        foO = aRg;
    in
        (foo + foo) - (foO + foO);
        
// Test for problems with function names that differ only in case and
// function names that collide with windows reserved file names.
caseTest = (capsTest == 1.0) && 
           (capstest == 2.0) && 
           (lpt1 == 3.0) && 
           (lPt1 == 4.0) &&
           (aux == 5.0) &&
           (aUx == 6.0) &&
           ((capsData1Test CTT1A) == "CTT1A") &&
           ((capsData1Test CTT1a) == "CTT1a") &&
           ((capsData1Test Ctt1a) == "Ctt1a") &&
           ((capsData2Test CTt1A) == "CTt1A") &&
           ((capsData2Test CtT1a) == "CtT1a") &&
           ((capsData2Test CtT1A) == "CtT1A") &&
           (instanceShow1 CTt1A == "sHOwCapstesttype1CTt1A") &&
           (instanceShow1 CTT1A == "sHOwCapsTestType1CTT1A") &&
           ((capsArgs 5.0 3.0) == 2.0) &&
           ((capsLets 5.0 3.0) == 4.0); 
   
// These functions won't actually execute (i.e. they don't terminate) but we
// want to make sure that they compiler correctly.
aliasTest1 :: Prelude.Double -> Prelude.Double -> Prelude.Double;
aliasTest1 x y = aliasTest2 x y;

aliasTest2 :: Prelude.Double -> Prelude.Double -> Prelude.Double;
aliasTest2 x y = aliasTest3 x y;

aliasTest3 :: Prelude.Double -> Prelude.Double -> Prelude.Double;
aliasTest3 x y = aliasTest1 x y;
        
testInlinedLetInTailRecursion x y =
    let
        pair = (x, y);
        fp = Prelude.fst pair;
        sp = Prelude.snd pair;
    in
        if (fp > 0.0) then Prelude.False else (testInlinedLetInTailRecursion (x - 1) sp);
    
data RE =
    RDC1
    ;

equalsRE :: RE -> RE -> Prelude.Boolean;
private equalsRE !x !y = 
    case x of
    RDC1 -> 
        case y of
        RDC1 -> Prelude.True;
        _ -> Prelude.False;
        ;
    ;
    
        

/////////////////////////////////////////////////////////////////////////////////

//optimize combinations

// Returns a list of all the combinations of the items in the specified lists.
// For example, for the input lists [[A, B, C], [1, 2, 3, 4]] then the combinations would be:
//     [[A, 1], [A, 2], [A, 3], [A, 4], [B, 1], [B, 2], [B, 3], [B, 4], [C, 1], [C, 2], [C, 3], [C, 4]]
// (Of course the values would all need to be of the same type.)
combinations :: [[a]] -> [[a]];
combinations !valuesLists = 
    let
        comboHelper newValues currentCombos = 
            foldRight (\newVal cur -> (map (Prelude.Cons newVal) currentCombos) ++ cur) [] newValues;
    in
        if (Prelude.isEmpty valuesLists) then []
        else foldRight comboHelper (map List.list1 (last valuesLists)) (List.init valuesLists);
 
//combinations2 is actually a little slower than combinations in the g-machine but is a little faster in lecc!    
combinations2 :: [[a]] -> [[a]];
combinations2 !listOfValues =
    let 
        //for example, combine ['a', 'b', 'c'] [['1', '2'], ['3', '4']] == 
        //  [['a', '1', '2'], ['a', '3', '4'], ['b', '1', '2'], ['b', '3', '4'], ['c', '1', '2'], ['c', '3', '4']]  
        combine :: [a] -> [[a]] -> [[a]];
        combine xs yss =
            case xs of
            [] -> [];
            xs_head : xs_tail ->
                (scalarCombine xs_head yss) ++ combine xs_tail yss;
            ;
        
        //for example, scalarCombine 'c' [['1', '2'], ['3', '4']] == [['c', '1', '2'], ['c', '3', '4']]
        //scalarCombine x yss = map (Cons x) yss;        
        scalarCombine :: a -> [[a]] -> [[a]];    
        scalarCombine x !yss =
            case yss of
            [] -> [];
            ys : yss_tail -> (x : ys) : scalarCombine x yss_tail;
            ;                             
        
        //for example, combine1 ['a', 'b', 'c'] == [['a'], ['b'], ['c']]      
        //combine1 xs = map list1 xs;
        combine1 :: [a] -> [[a]];
        combine1 !xs =
            case xs of
            [] -> [];
            x : xs_tail -> [x] : combine1 xs_tail;
            ;        
            
    in    
        case listOfValues of
        [] -> [];
        listOfValues_head : listOfValues_tail ->
            if (Prelude.isEmpty listOfValues_tail) then
                combine1 listOfValues_head
            else
                combine listOfValues_head (combinations2 listOfValues_tail);
        ;
    
cft combinations listOfValues =
   let
       listOfValues = [countryDimension, productsDimension, timeDimension, measuresDimension];
    in
    
   Prelude.seq (Prelude.output (combinations listOfValues)) "done";

comboFunctionalityTest comboFunction = 
    comboFunction [] == ([] :: [[Char]])
    && comboFunction [['a']] == [['a']]
    && comboFunction [['a', 'b', 'c']] == [['a'], ['b'], ['c']]
    && comboFunction [[], ['a', 'b', 'c']] == []
    && comboFunction [['a', 'b', 'c'], []] == []
    && comboFunction [['a', 'b', 'c'], ['1', '2']] == [['a', '1'], ['a', '2'], ['b', '1'], ['b', '2'], ['c', '1'], ['c', '2']]  
    && comboFunction [['a'], ['b'], ['c']] == [['a', 'b', 'c']]                                                         
    || error "M2.comboFunctionalityTest failed.";                
                       
    
comboTest1 comboFunction =
    last (comboFunction [countryDimension, productsDimension, timeDimension, measuresDimension]);

comboTest2 comboFunction =
    length (comboFunction [countryDimension, productsDimension, timeDimension, measuresDimension]);
            
comboTest3 comboFunction =
    sum (map length (comboFunction [countryDimension, productsDimension, timeDimension, measuresDimension]));


 

countryDimension  = ["Canada", "USA", "Mexico", "France", "UK", "Spain", "Italy", "Germany", "Portugal", "Denmark"];
productsDimension = map (\!i -> "Products" ++ Prelude.intToString i) (upFromTo 1 100);
timeDimension     = map (\!i -> "Time" ++ Prelude.intToString i) (upFromTo 1 100);
measuresDimension = ["Sales", "Costs", "Profit"];   

outputCharTest = Prelude.output 'c';

// Helper: Group the tuples by the first element, using the comparison function given.
groupByFirst :: (a -> a -> Boolean) -> [(a, b)] -> [(a, [b])];
groupByFirst eq tuples =
    case tuples of
    [] -> [];
    tuples_head : tuples_tail ->
        let
            comparisonTarget = fst tuples_head;
            partitionedTuples = partition (\x -> eq comparisonTarget (fst x)) tuples_tail;
            eqTuples = tuples_head : (fst partitionedTuples);
            eqCombinedTuple = (comparisonTarget, (map snd eqTuples));
            notEqTuples = snd partitionedTuples;
        in
            eqCombinedTuple : groupByFirst eq notEqTuples;
    ;

//I was concerned about the efficiency of all the partitioning since we need to support large lists.  So, I wrote a version that uses foldl:

// Version 2: Group the tuples by the first element, using the comparison function given.  Implemented 
// with foldLeft instead of recursive partitioning 
groupByFirst2 :: (a -> a -> Boolean) -> [(a, b)] -> [(a, [b])];
groupByFirst2 eqFunc !lst = 
    let   
        groupByFirstHelper :: (a -> a -> Boolean) -> [(a, [b])] -> (a, b) -> [(a, [b])];
        groupByFirstHelper eqFunc !tuples nextTuple = 
            case tuples of
            [] -> [(fst nextTuple, [snd nextTuple])];
            tuples_head : tuples_tail ->        
                let            
                    key = fst tuples_head; 
                    values = snd tuples_head;
                    nextKey = fst nextTuple;
                    nextValue = snd nextTuple;
                in
                    if (eqFunc key nextKey) then
                        (key, (nextValue : values)) : tuples_tail             
                    else                 
                        tuples_head : groupByFirstHelper eqFunc tuples_tail nextTuple;
            ;
    in
        foldLeft (groupByFirstHelper eqFunc) [] lst;    

//And then I created a test gem to produce the worst case list of tuples, where all are unique:

testTupleListWorst :: Int -> [(Int,Int)];
testTupleListWorst n =
    let 
        keys = upFrom 1;
        values = List.repeat 0; 
    in
        take n (zip keys values);
    
testGroupFirsts n = groupByFirst2 equals (testTupleListWorst n);


groupByFirsts3 :: (a -> a -> Ordering) -> [(a, b)] -> [(a, [b])];
groupByFirsts3 compare list =
    let
        compareFunction p1 p2 = compare (fst p1) (fst p2);
        eqFunction p1 p2 = compareFunction p1 p2 == EQ;
        sortThenGroupByFirsts = List.groupBy eqFunction (List.sortBy compareFunction list);
        collapse listOfPairs = 
            let
                pairOfLists = unzip listOfPairs;
            in
                (List.head (fst pairOfLists), snd pairOfLists);
    in
        map collapse sortThenGroupByFirsts;
            

//a helper function for partition
//select p x tfs appends x to the first list if p x is True, and to the second list otherwise.
select2 :: (a -> Boolean) -> a -> ([a], [a]) -> ([a], [a]);
private select2 !p x tfs =
    if (p x) then (x : fst tfs, snd tfs)
    else (fst tfs, x : snd tfs);

//e.g. partition isEven [3, 1, 4, 1, 5, 9, 2, 6] = ([4, 2, 6], [3, 1, 1, 5, 9])
//Note that this implementation applies the predicate p at most once to each element of xs
partition2 :: (a -> Boolean) -> [a] -> ([a], [a]);
partition2 p xs = 
    foldRight (select2 p) ([], []) xs;

// GroupAllBy
// Groups all elements in a list.  The List.groupBy function will only group adjacent items in the list.  
// Since calculations are not orderable we can't sort and then call groupBy.  Instead we need a function 
// to group all items in a list regardless of whether they are adjacent.
//
// TODO:  This function, or a similar function, should probably be part of the Prelude.        
groupAllBy :: (a -> a -> Boolean) -> [a] -> [[a]];
groupAllBy eqFunc !lst =
    let
        groupValue :: (a -> a -> Boolean) -> [[a]] -> a -> [[a]];
        groupValue eqFunc groups value =
        case groups of
        [] -> [[value]];
        x : xs -> if (eqFunc value (head x)) then
            ((value : x) : xs) 
            else
            (x : (groupValue eqFunc xs value));
        ;
    in
        foldLeft (groupValue eqFunc) [] lst;

//M2>testGroupAllBy 10000
//
//running: testGroupAllBy 10000
//Error while executing: The java virtual machine encountered an error.
//Caused by: java.lang.StackOverflowError,  Detail: null
testGroupAllBy n = groupAllBy equals (upFromTo (1 :: Int) n);

groupAllBy2 :: (a -> a -> Boolean) -> [a] -> [[a]];
groupAllBy2 eqFunc !lst =
    let
        groupValue :: (a -> a -> Boolean) -> a -> [[a]] -> [[a]];
        groupValue eqFunc value !groups =
        case groups of
        [] -> [[value]];
        x : xs -> if (eqFunc value (head x)) then
            ((value : x) : xs) 
            else
            (x : (groupValue eqFunc value xs));
        ;
    in
        foldRight (groupValue eqFunc) [] lst;
    
testGroupAllBy2 n = groupAllBy2 equals (upFromTo (1 :: Int) n);   

groupAllBy3 :: (a -> a -> Boolean) -> [a] -> [[a]];
groupAllBy3 eq list =
    case list of
    [] -> [];
    headList : tailList ->    
        case partition (eq headList) tailList of
        (fstEquivClass, restOfList) ->
            (headList : fstEquivClass) : groupAllBy3 eq restOfList;
        ;
    ;
  
testGroupAllBy3 n = groupAllBy3 equals (upFromTo (1 :: Int) n);    
    
groupAllBy4 :: (a -> a -> Boolean) -> [a] -> [[a]];
groupAllBy4 eqFunc !lst =
    let
        groupValue :: (a -> a -> Boolean) -> [[a]] -> a -> [[a]] -> [[a]];
        groupValue eqFunc groups value !remainingGroups =
        case remainingGroups of
        [] -> [value] : groups;
        x : xs -> if (eqFunc value (head x)) then
            ((value : x) : xs) 
            else
            (x : (groupValue eqFunc groups value xs));
        ;
    in
        foldRight (groupValue eqFunc []) [] lst; 
    
testGroupAllBy4 n = groupAllBy4 equals (upFromTo (1 :: Int) n);   

    
groupAllBy5 :: (a -> a -> Boolean) -> [a] -> [[a]];
groupAllBy5 eqFunc list =
    let
    
        groupAllByHelper :: (a -> a -> Boolean) -> [a] -> [[a]] -> [[a]];
        groupAllByHelper eq !list equivClassesOfLists =
            case list of
            [] -> equivClassesOfLists;
            listHead : listTail ->
                groupAllByHelper eq listTail (groupValue eq listHead equivClassesOfLists);
            ;
            
        groupValue :: (a -> a -> Boolean) -> a -> [[a]] -> [[a]];
        groupValue eq value !list =
            case list of
            [] -> [[value]];
            listHead : listTail ->
                if (eq value (head listHead)) then
                    (value : listHead) : listTail
                else
                    listHead : (groupValue eq value listTail);
            ;
     
    in        
        groupAllByHelper eqFunc list [];

testGroupAllBy5 n = groupAllBy5 equals (upFromTo (1 :: Int) n);       

 
//finds the sublist of elements of list that are equivalent to the first element of the list.    
equivalentToHead :: (a -> a -> Boolean) -> [a] -> [a];
equivalentToHead eq list =
    case list of
    [] -> [];
    listHead : listTail -> listHead : filter (eq listHead) listTail;
    ;
       
    
testGroupAllByGeneral func =
     func (\p q -> fst p == fst q) [('a', 1.0), ('a', 2.0), ('b', 3.0), ('c', 4.0), ('a', 5.0), ('b', 6.0)]
           == [[('a', 1.0), ('a', 2.0), ('a', 5.0)], [('b', 3.0), ('b', 6.0)], [('c', 4.0)]];
    
    
groupByFirst3 :: (a -> a -> Boolean) -> [(a, b)] -> [(a, [b])];
groupByFirst3 eq list =    
    map (\listOfPairs -> (fst (head listOfPairs), map snd listOfPairs)) (groupAllBy3 (\p q -> eq (fst p) (fst q)) list);

        
// @@@begin M2.groupAllByFirstBug saved Thu Jan 27 19:09:35 PST 2005.
// Warning: this section may be automatically regenerated by the GemCutter.
groupAllByFirstBug :: Prelude.Eq a => [(a, b)] -> [(a, [b])];
groupAllByFirstBug list = List.map (\lop -> (Prelude.fst (List.head lop), List.map Prelude.snd lop)) (M2.groupAllBy3 ((\eq p q -> eq (Prelude.fst p) (Prelude.fst q)) Prelude.equals) list);
// @@@end M2.groupAllByFirstBug

// @@@begin M2.groupAllByFirstBug2 saved Thu Jan 27 19:10:33 PST 2005.
// Warning: this section may be automatically regenerated by the GemCutter.
groupAllByFirstBug2 :: (a -> a -> Prelude.Boolean) -> [(a, b)] -> [(a, [b])];
groupAllByFirstBug2 eq list = List.map (\lop -> (Prelude.fst (List.head lop), List.map Prelude.snd lop)) (M2.groupAllBy3 ((\eq p q -> eq (Prelude.fst p) (Prelude.fst q)) eq) list);
// @@@end M2.groupAllByFirstBug2

//It is clear that sortIntExternal is faster...

//:pt testSort sortIntExternal (1000000 :: Int)
//Summary:    time = 4,156

//:pt testSort sort (1000000 :: Int)
//Summary:    time = 23,729
//:pt testSort2 (sort) (1000000 :: Prelude.Int)
//Summary:    time = 6,901

//:pt testSort (List.sortByExternal Prelude.compare) (1000000 :: Prelude.Int)
//Summary:    time = 11,998
//:pt testSort2 (List.sortByExternal Prelude.compare) (1000000 :: Prelude.Int)
//Summary:    time = 9,875
//conclusion: sortByExternal is faster than sort if the full sorted list is consumed.
//but if we can take advantage of lazyness, sort can be faster.

sortIntExternal :: [Int] -> [Int];
sortIntExternal list = 
    let
        javaList = (outputList list);
    in
        seq (jSort javaList) (inputList javaList);   

foreign unsafe import jvm "static method java.util.Collections.sort" private jSort :: JList -> ();

countDown :: Int -> [Int];
countDown n = Prelude.upFromThenTo n (n - 1) 1;

testSort f n = last (f (countDown n));

testSort2 f n = head (f (countDown n));

z1 :: Int -> Boolean;
z1 !x = 0 < x;

zAndAnd :: Boolean -> Boolean -> Boolean -> Boolean;
zAndAnd !x !y !z = x && y && z;

zOrOr :: Boolean -> Boolean -> Boolean -> Boolean;
zOrOr !x !y !z = x || y || z;

zOrAnd :: Boolean -> Boolean -> Boolean -> Boolean;
zOrAnd !x !y !z = x || y && z;

zAndOr :: Boolean -> Boolean -> Boolean -> Boolean;
zAndOr !x !y !z = x && y || z;

zAndAndOr :: Boolean -> Boolean -> Boolean -> Boolean -> Boolean;
zAndAndOr !x !y !z !w= (x && y && z) || w;

//tests the encoding of the composition of not with a boolean-valued operator
//we want to encode these efficiently in java bytecodes. The optimizations are somewhat
//complicated so hence the tests...

opTestNotAnd x y = not (x && y);

opTestNotOr x y = not (x || y);

opTestNotNot x = not (not x);


opTestEquals :: Int -> Int -> Boolean;
opTestEquals x y = x == y;

opTestEquals2 :: Int -> Int -> Boolean;
opTestEquals2 x y = not (x != y);


opTestNotEquals :: Int -> Int -> Boolean;
opTestNotEquals x y = x != y;

opTestNotEquals2 :: Int -> Int -> Boolean;
opTestNotEquals2 x y = not (x == y);


opTestLessThan :: Int -> Int -> Boolean;
opTestLessThan x y = x < y;

opTestLessThan2 :: Int -> Int -> Boolean;
opTestLessThan2 x y = not (x >= y);


opTestLessThanEquals :: Int -> Int -> Boolean;
opTestLessThanEquals x y = x <= y;

opTestLessThanEquals2 :: Int -> Int -> Boolean;
opTestLessThanEquals2 x y = not (x > y);


opTestGreaterThan :: Int -> Int -> Boolean;
opTestGreaterThan x y = x > y;

opTestGreaterThan2 :: Int -> Int -> Boolean;
opTestGreaterThan2 x y = not (x <= y);


opTestGreaterThanEquals :: Int -> Int -> Boolean;
opTestGreaterThanEquals x y = x >= y;

opTestGreaterThanEquals2 :: Int -> Int -> Boolean;
opTestGreaterThanEquals2 x y = not (x < y);




opTestDoubleEquals :: Double -> Double -> Boolean;
opTestDoubleEquals x y = x == y;

opTestDoubleEquals2 :: Double -> Double -> Boolean;
opTestDoubleEquals2 x y = not (x != y);


opTestDoubleNotEquals :: Double -> Double -> Boolean;
opTestDoubleNotEquals x y = x != y;

opTestDoubleNotEquals2 :: Double -> Double -> Boolean;
opTestDoubleNotEquals2 x y = not (x == y);


opTestDoubleLessThan :: Double -> Double -> Boolean;
opTestDoubleLessThan x y = x < y;

opTestDoubleLessThan2 :: Double -> Double -> Boolean;
opTestDoubleLessThan2 x y = not (x >= y);


opTestDoubleLessThanEquals :: Double -> Double -> Boolean;
opTestDoubleLessThanEquals x y = x <= y;

opTestDoubleLessThanEquals2 :: Double -> Double -> Boolean;
opTestDoubleLessThanEquals2 x y = not (x > y);


opTestDoubleGreaterThan :: Double -> Double -> Boolean;
opTestDoubleGreaterThan x y = x > y;

opTestDoubleGreaterThan2 :: Double -> Double -> Boolean;
opTestDoubleGreaterThan2 x y = not (x <= y);


opTestDoubleGreaterThanEquals :: Double -> Double -> Boolean;
opTestDoubleGreaterThanEquals x y = x >= y;

opTestDoubleGreaterThanEquals2 :: Double -> Double -> Boolean;
opTestDoubleGreaterThanEquals2 x y = not (x < y);


opTestCompareOr1 :: Int -> Int -> Boolean;
opTestCompareOr1 x y = x < 1 || y < 5;

opTestCompareOr2 :: Int -> Int -> Int -> Boolean;
opTestCompareOr2 x y z = x < 1 || y < 5 || z < 10;


opTestCompareOrStrict1 :: Int -> Int -> Boolean;
opTestCompareOrStrict1 !x !y = x < 1 || y < 5;

opTestCompareOrStrict2 :: Int -> Int -> Int -> Boolean;
opTestCompareOrStrict2 !x !y !z = x < 1 || y < 5 || z < 10;

//Prelude.id is actually optimized out. We need a way to ensure that the logical operators are not top level in a defining expression to
//ensure that they are not converted to "if" expressions in code generation. See Ray's check in note Aug 18, 2004 for details.
id2 :: Boolean -> Boolean;
id2 !x = x;

opTestExAnd x y = id2 (x && y);

opTestExOr x y = id2 (x || y);

opTestExNot x = id2 (not x);

opTestExNotAnd x y = id2 (not (x && y));

opTestExNotOr x y = id2 (not (x || y));

opTestExNotNot x = id2 (not (not x));


opTestExEquals :: Int -> Int -> Boolean;
opTestExEquals x y = id2 (x == y);

opTestExEquals2 :: Int -> Int -> Boolean;
opTestExEquals2 x y = id2 (not (x != y));


opTestExNotEquals :: Int -> Int -> Boolean;
opTestExNotEquals x y = id2 (x != y);

opTestExNotEquals2 :: Int -> Int -> Boolean;
opTestExNotEquals2 x y = id2 (not (x == y));


opTestExLessThan :: Int -> Int -> Boolean;
opTestExLessThan x y = id2 (x < y);

opTestExLessThan2 :: Int -> Int -> Boolean;
opTestExLessThan2 x y = id2 (not (x >= y));


opTestExLessThanEquals :: Int -> Int -> Boolean;
opTestExLessThanEquals x y = id2 (x <= y);

opTestExLessThanEquals2 :: Int -> Int -> Boolean;
opTestExLessThanEquals2 x y = id2 (not (x > y));


opTestExGreaterThan :: Int -> Int -> Boolean;
opTestExGreaterThan x y = id2 (x > y);

opTestExGreaterThan2 :: Int -> Int -> Boolean;
opTestExGreaterThan2 x y = id2 (not (x <= y));


opTestExGreaterThanEquals :: Int -> Int -> Boolean;
opTestExGreaterThanEquals x y = id2 (x >= y);

opTestExGreaterThanEquals2 :: Int -> Int -> Boolean;
opTestExGreaterThanEquals2 x y = id2 (not (x < y));




opTestExDoubleEquals :: Double -> Double -> Boolean;
opTestExDoubleEquals x y = id2 (x == y);

opTestExDoubleEquals2 :: Double -> Double -> Boolean;
opTestExDoubleEquals2 x y = id2 (not (x != y));


opTestExDoubleNotEquals :: Double -> Double -> Boolean;
opTestExDoubleNotEquals x y = id2 (x != y);

opTestExDoubleNotEquals2 :: Double -> Double -> Boolean;
opTestExDoubleNotEquals2 x y = id2 (not (x == y));


opTestExDoubleLessThan :: Double -> Double -> Boolean;
opTestExDoubleLessThan x y = id2 (x < y);

opTestExDoubleLessThan2 :: Double -> Double -> Boolean;
opTestExDoubleLessThan2 x y = id2 (not (x >= y));


opTestExDoubleLessThanEquals :: Double -> Double -> Boolean;
opTestExDoubleLessThanEquals x y = id2 (x <= y);

opTestExDoubleLessThanEquals2 :: Double -> Double -> Boolean;
opTestExDoubleLessThanEquals2 x y = id2 (not (x > y));


opTestExDoubleGreaterThan :: Double -> Double -> Boolean;
opTestExDoubleGreaterThan x y = id2 (x > y);

opTestExDoubleGreaterThan2 :: Double -> Double -> Boolean;
opTestExDoubleGreaterThan2 x y = id2 (not (x <= y));


opTestExDoubleGreaterThanEquals :: Double -> Double -> Boolean;
opTestExDoubleGreaterThanEquals x y = id2 (x >= y);

opTestExDoubleGreaterThanEquals2 :: Double -> Double -> Boolean;
opTestExDoubleGreaterThanEquals2 x y = id2 (not (x < y));


opTestExCompareOr1 :: Int -> Int -> Boolean;
opTestExCompareOr1 x y = id2 (x < 1 || y < 5);

opTestExCompareOr2 :: Int -> Int -> Int -> Boolean;
opTestExCompareOr2 x y z = id2 (x < 1 || y < 5 || z < 10);


opTestExCompareOrStrict1 :: Int -> Int -> Boolean;
opTestExCompareOrStrict1 !x !y = id2 (x < 1 || y < 5);

opTestExCompareOrStrict2 :: Int -> Int -> Int -> Boolean;
opTestExCompareOrStrict2 !x !y !z = id2 (x < 1 || y < 5 || z < 10);

opTestExParenAndOr x y z = id2 ((x && y) || z);
opTestExNotParenAndOr x y z = id2 (not (x && y) || z);
opTestExParenAndNotOr x y z = id2 ((x && y) || not z);
opTestExNotParenAndNotOr x y z = id2 (not (x && y) || not z);

opTestExAndParenOr x y z = id2 (x && (y || z));
opTestExNotAndParenOr x y z = id2 (not x && (y || z));
opTestExAndNotParenOr x y z = id2 (x && not (y || z)); 
opTestExNotAndNotParenOr x y z = id2 (not x && not (y || z));

opTestExParenOrAnd x y z = id2 ((x || y) && z);
opTestExNotParenOrAnd x y z = id2 (not (x || y) && z);
opTestExParenOrNotAnd x y z = id2 ((x || y) && not z);
opTestExNotParenOrNotAnd x y z = id2 (not (x || y) && not z);

opTestExOrParenAnd x y z = id2 (x || (y && z));
opTestExNotOrParenAnd x y z = id2 (not x || (y && z));
opTestExOrNotParenAnd x y z = id2 (x || not (y && z));
opTestExNotOrNotParenAnd x y z = id2 (not x || not (y && z));

opTestExAndAnd x y z = id2 ((x && y) && z);
opTestExNotAndAnd x y z = id2 (not (x && y) && z);
opTestExAndNotAnd x y z = id2 ((x && y) && not z);
opTestExNotAndNotAnd x y z = id2 (not (x && y) && not z);

opTestExAndAnd2 x y z = id2 (x && (y && z));
opTestExNotAndAnd2 x y z = id2 (not x && (y && z));
opTestExAndNotAnd2 x y z = id2 (x && not (y && z));
opTestExNotAndNotAnd2 x y z = id2 (not x && not (y && z));

opTestExOrOr x y z = id2 ((x || y) || z);
opTestExNotOrOr x y z = id2 (not (x || y) || z);
opTestExOrNotOr x y z = id2 ((x || y) || not z);
opTestExNotOrNotOr x y z = id2 (not (x || y) || not z);

opTestExOrOr2 x y z = id2 (x || (y || z));
opTestExNotOrOr2 x y z = id2 (not x || (y || z));
opTestExOrNotOr2 x y z = id2 (x || not (y || z));
opTestExNotOrNotOr2 x y z = id2 (not x || not (y || z));

opTestExExtendedTests1 x1 x2 x3 x4 x5 = id2 ((((x1 || x2) || x3) || x4) || x5);

opTestExExtendedTests2 x1 x2 x3 x4 x5 = id2 ((((x1 && x2) && x3) && x4) && x5);

opTestExExtendedTests3 x1 x2 x3 x4 x5 = id2 (x1 || (x2 || (x3 || (x4 || x5))));

opTestExExtendedTests4 x1 x2 x3 x4 x5 = id2 (x1 && (x2 && (x3 && (x4 && x5))));

opTestExExtendedTests5 x1 x2 x3 x4 x5 = id2 (not (not (not (not (x1 || x2) || x3) || x4) || x5));

opTestExExtendedTests6 x1 x2 x3 x4 x5 = id2 (not (not (not (not (x1 && x2) && x3) && x4) && x5));

opTestExExtendedTests7 x1 x2 x3 x4 x5 = id2 (not (x1 || not (x2 || not (x3 || not (x4 || x5)))));

opTestExExtendedTests8 x1 x2 x3 x4 x5 = id2 (not (x1 && not (x2 && not (x3 && not (x4 && x5)))));

opTestExExtendedTests7b x2 x3 x4 x5 = id2 (not (x2 || not (x3 || not (x4 || x5))));

opTestExExtendedTests8b x2 x3 x4 x5 = id2 (not (x2 && not (x3 && not (x4 && x5))));


opTestExExtendedTests9 x1 x2 x3 x4 x5 y2 y4 = id2 (((((sin x1 < sin y2) || x2) || (cos x3 != cos y4)) || x4) || x5);

opTestExExtendedTests10 x1 x2 x3 x4 x5 y2 y4 = id2 (((((sin x1 < sin y2) && x2) && (cos x3 != cos y4)) && x4) && x5);

opTestExExtendedTests11 x1 x2 x3 x4 x5 y2 y4 = id2 ((sin x1 < sin y2) || (x2 || ((cos x3 != cos y4) || (x4 || x5))));

opTestExExtendedTests12 x1 x2 x3 x4 x5 y2 y4 = id2 ((sin x1 < sin y2) && (x2 && ((cos x3 != cos y4) && (x4 && x5))));

opTestExExtendedTests13 x1 x2 x3 x4 x5 y2 y4 = id2 (not (not (not (not ((sin x1 < sin y2) || x2) || (cos x3 != cos y4)) || x4) || x5));

opTestExExtendedTests14 x1 x2 x3 x4 x5 y2 y4 = id2 (not (not (not (not ((sin x1 < sin y2) && x2) && (cos x3 != cos y4)) && x4) && x5));

opTestExExtendedTests15 x1 x2 x3 x4 x5 y2 y4 = id2 (not ((sin x1 < sin y2) || not (x2 || not ((cos x3 != cos y4) || not (x4 || x5)))));

opTestExExtendedTests16 x1 x2 x3 x4 x5 y2 y4 = id2 (not ((sin x1 < sin y2) && not (x2 && not ((cos x3 != cos y4) && not (x4 && x5)))));


opTestExExtendedTests17 x1 x2 x3 x4 x5 x6 x7 x8 = id2 ( ((x1 && x2) && (x3 && x4)) && ((x5 && x6) && (x7 && x8)));

opTestExExtendedTests18 x1 x2 x3 x4 x5 x6 x7 x8 = id2 ( ((x1 || x2) || (x3 || x4)) || ((x5 || x6) || (x7 || x8)));

opTestExExtendedTests19 x1 x2 x3 x4 x5 x6 x7 x8 = id2 ( ((x1 || x2) || (x3 || x4)) && ((x5 || x6) || (x7 || x8)));

opTestExExtendedTests20 x1 x2 x3 x4 x5 x6 x7 x8 = id2 ( ((x1 && x2) || (x3 && x4)) || ((x5 && x6) || (x7 && x8)));

opTestExExtendedTests21 x1 x2 x3 x4 x5 x6 x7 x8 = id2 ( ((x1 && x2) || (x3 && x4)) && ((x5 && x6) || (x7 && x8)));

opTestExExtendedTests22 x1 x2 x3 x4 x5 x6 x7 x8 = id2 ( ((x1 || x2) && (x3 || x4)) || ((x5 || x6) && (x7 || x8)));


opTestExExtendedTests23 x1 x2 x3 x4 x5 x6 x7 x8 = id2 (not (not (not (not x1 && not x2) && not (not x3 && not x4)) &&
        not (not (not x5 && not x6) && not (not x7 && not x8))));

opTestExExtendedTests24 x1 x2 x3 x4 x5 x6 x7 x8 = id2 (not (not (not (not x1 || not x2) || not (not x3 || not x4)) ||
        not (not (not x5 || not x6) || not (not x7 || not x8))));

opTestExExtendedTests25 x1 x2 x3 x4 x5 x6 x7 x8 = id2 (not (not (not (not x1 || not x2) || not (not x3 || not x4)) &&
        not (not (not x5 || not x6) || not (not x7 || not x8))));

opTestExExtendedTests26 x1 x2 x3 x4 x5 x6 x7 x8 = id2 (not (not (not (not x1 && not x2) || not (not x3 && not x4)) ||
        not (not (not x5 && not x6) || not (not x7 && not x8))));

opTestExExtendedTests27 x1 x2 x3 x4 x5 x6 x7 x8 = id2 (not (not (not (not x1 && not x2) || not (not x3 && not x4)) &&
        not (not (not x5 && not x6) || not (not x7 && not x8))));

opTestExExtendedTests28 x1 x2 x3 x4 x5 x6 x7 x8 = id2 (not (not (not (not x1 || not x2) && not (not x3 || not x4)) ||
        not (not (not x5 || not x6) && not (not x7 || not x8))));


opTestExExtendedTests29 x1 x2 x3 x4 x5 y2 y4 = id2 (not (not (not (not (not (sin x1 < sin y2) || x2) || not (cos x3 != cos y4)) || x4) || x5));

opTestExExtendedTests30 x1 x2 x3 x4 x5 y2 y4 = id2 (not (not (not (not (not (sin x1 < sin y2) && x2) && not (cos x3 != cos y4)) && x4) && x5));

opTestExExtendedTests31 x1 x2 x3 x4 x5 y2 y4 = id2 (not (not (sin x1 < sin y2) || not (x2 || not (not (cos x3 != cos y4) || not (x4 || x5)))));

opTestExExtendedTests32 x1 x2 x3 x4 x5 y2 y4 = id2 (not (not (sin x1 < sin y2) && not (x2 && not (not (cos x3 != cos y4) && not (x4 && x5)))));



opTestExExtendedTests33 x1 x2 x3 x4 x5 y2 y4 = id2 (not (not (not (not (not ((abs x1 :: Int) < abs y2) || x2) || not ((abs x3 :: Int) != abs y4)) || x4) || x5));

opTestExExtendedTests34 x1 x2 x3 x4 x5 y2 y4 = id2 (not (not (not (not (not ((abs x1 :: Int) < abs y2) && x2) && not ((abs x3 :: Int) != abs y4)) && x4) && x5));

opTestExExtendedTests35 x1 x2 x3 x4 x5 y2 y4 = id2 (not (not ((abs x1 :: Int) < abs y2) || not (x2 || not (not ((abs x3 :: Int) != abs y4) || not (x4 || x5)))));

opTestExExtendedTests36 x1 x2 x3 x4 x5 y2 y4 = id2 (not (not ((abs x1 :: Int) < abs y2) && not (x2 && not (not ((abs x3 :: Int) != abs y4) && not (x4 && x5)))));

outputTest1 = Prelude.output (5.0, "abc");

outputTest2 = Prelude.output {#1 = 5.0, #2 = "abc"};
         
recordCaseWithTailRecursionAndLetVariables :: {f1 :: Prelude.Integer, f2 :: Prelude.Integer, f3 :: Prelude.Integer, f4 :: Prelude.Integer} -> [Prelude.Integer] -> [Prelude.Integer];
recordCaseWithTailRecursionAndLetVariables abcd xss = 
    case abcd of {f1 = a, f2 = b, f3 = c, f4 = d} ->
        let
            q = b / d;
        in
            if (((Prelude.signum c == Prelude.signum d) || (Prelude.abs c < Prelude.abs d)) && ((c+d)*q <= a+b) && ((c+d)*q + (c+d) > a+b)) then
                (q : recordCaseWithTailRecursionAndLetVariables {f1 = c, f2 = d, f3 = a-q*c, f4 = b-q*d} xss)
            else
                case xss of x:xs -> 
                    recordCaseWithTailRecursionAndLetVariables {f1 = b, f2 = a+x*b, f3 = d, f4 = c+x*d} xs
                ;
    ;;

// testLetVarInlining was added in response to a bug which caused overly agressive inlining of let variables.
// The bug was fixed on April 27, 2005 by Raymond Cypher.
testLetVarInlining = 
    let 
        accumulator = makeJStringAccumulator;
        testLetVarInliningHelper :: Ord a => JStringAccumulator -> [a] -> [a] -> Ordering;
        testLetVarInliningHelper  accumulator !xs !ys =
            case xs of
            [] ->
                case ys of
                [] -> EQ;
                ys_head : ys_tail -> LT;
                ;
            xs_head : xs_tail ->
                case ys of
                [] -> GT;
                ys_head : ys_tail ->
                    let 
                        compareHeads = Prelude.seq (jStringAccumulator_AddString accumulator "evaluate compareHeads") (compare xs_head ys_head);
                    in
                        case compareHeads of
                        EQ -> testLetVarInliningHelper accumulator xs_tail ys_tail;
                        _  -> compareHeads;
                        ;
                ;
            ;        
    in
        if (Prelude.seq (testLetVarInliningHelper accumulator [1.0] [2.0]) (jStringAccumulator_getStrings accumulator) == "evaluate compareHeads") then Prelude.True else (Prelude.error "M2.testLetVarInlining failed.");
        
    
myFacAcc :: Prelude.Integer -> Prelude.Integer -> Prelude.Integer;   
private myFacAcc !a !n = 
  if n == 0 then a
  else myFacAcc (n*a) (n-1);

//a version of the factorial function that scales (doesn't use stack) and is constant space.
myFactorial :: Prelude.Integer -> Prelude.Integer;
myFactorial !n = myFacAcc 1 n; 

//this version of the factorial function also scales and is constant space. It is defined in terms of 
//standard Prelude functions.
myFactorial2 :: Prelude.Integer -> Prelude.Integer;
myFactorial2 n = List.product (Prelude.upFromTo 1 n);

//benchmark implementing Prelude.outputRecord so that fixed sized lists are used instead of ArrayList for records with <= 7 fields.
//It was a 6% time improvement to do this for n = 1,000,000. 
benchmarkFixedTuple5 n =
    last (Prelude.input (Prelude.output (replicate n (1.0, "Anton", 3 :: Int, True, 'a'))) :: [(Double, String, Int, Boolean, Char)]);

//benchmark implementing Prelude.outputRecord so that fixed sized lists are used instead of ArrayList for records with <= 7 fields.
//It was a 12% time improvement to do this for n = 1,000,000. 
benchmarkFixedTuple2 n =
    last (Prelude.input (Prelude.output (replicate n (1.0, "Anton"))) :: [(Double, String)]);

benchmarkFixedList5 n =
    last (Prelude.input (Prelude.output (replicate n [10 :: Int, 20, 30, 40, 50])) :: [[Int]]);

benchmarkFixedList2 n =
    last (Prelude.input (Prelude.output (replicate n [10 :: Int, 20])) :: [[Int]]);

outIn :: (Outputable a, Inputable a) => a -> a;
outIn x = Prelude.input (Prelude.output x);

testRecordOutIn =
    //test tuples from sizes 2 to 9. 8 and 9 tuples are beyond the optimization range for outputRecord
    outIn {} == {}
    && outIn {#1 = 34.0} == {#1 = 34.0}
    && outIn ("Apple", 5.0) == ("Apple", 5.0)
    && outIn (2 :: Int, "Muppet", True) == (2 :: Int, "Muppet", True)
    && outIn (55 :: Int, "Arthur", 2.0, False) == outIn (55 :: Int, "Arthur", 2.0, False)
    && outIn (55 :: Int, "Arthur", 2.0, False, 35.0) == (55 :: Int, "Arthur", 2.0, False, 35.0)
    && outIn (2 :: Int, "Muppet", True, "Pear", 20.0, 'f') == (2 :: Int, "Muppet", True, "Pear", 20.0, 'f')
    && outIn ([2 :: Int], "Muppet", [True], "Pear", 20.0, 'f', "Linda") == ([2 :: Int], "Muppet", [True], "Pear", 20.0, 'f', "Linda")
    && outIn ([2 :: Int], "Muppet", [True], "Pear", 20.0, 'f', ["Linda", "Anton"], Just 4.0) == ([2 :: Int], "Muppet", [True], "Pear", 20.0, 'f', ["Linda", "Anton"], Just 4.0)
    && outIn ("Apple", [2 :: Int], "Muppet", [True], "Pear", 20.0, 'f', ["Linda", "Anton"], Just 4.0) == ("Apple", [2 :: Int], "Muppet", [True], "Pear", 20.0, 'f', ["Linda", "Anton"], Just 4.0)
    || error "M2.testRecordOutIn failed.";
    
testListOutIn =
    outIn ([] :: [Int]) == []
    && outIn [10 :: Int] == [10]
    && outIn [10 :: Int, 20] == [10, 20]
    && outIn [10 :: Int, 20, 30] == [10, 20, 30]
    && outIn [10 :: Int, 20, 30, 40] == [10, 20, 30, 40]
    && outIn [10 :: Int, 20, 30, 40, 50] == [10 :: Int, 20, 30, 40, 50]
    && outIn [10 :: Int, 20, 30, 40, 50, 60] == [10 :: Int, 20, 30, 40, 50, 60]
    && outIn [10 :: Int, 20, 30, 40, 50, 60, 70] == [10 :: Int, 20, 30, 40, 50, 60, 70]
    && outIn [10 :: Int, 20, 30, 40, 50, 60, 70, 80] == [10 :: Int, 20, 30, 40, 50, 60, 70, 80]
    && outIn [10 :: Int, 20, 30, 40, 50, 60, 70, 80, 90] == [10 :: Int, 20, 30, 40, 50, 60, 70, 80, 90]
    || error "M2.testListOutIn failed.";                                                            

// Functions for benchmarking LegacyTuple vs. new (unified-with-records) tuples
// May 10 on the g-machine:
//   oldMethodEquals 50000  t=7167
//   newMethodEquals 50000  t=9820    (31% slower)    
//   oldElementEquals 50000 t=9097  
//   newElementEquals 50000 t=8686    (5% faster)  

newTupData :: Int -> [(Char, Int, Int, Int)];
newTupData !n =
    let 
        tupHelper :: Int -> [(Char, Int, Int, Int)] -> [(Char, Int, Int, Int)]; 
        tupHelper !i acc = 
            if i == n then
                acc
            else
                tupHelper (i+1) (('c', i, n-i, n+i) : acc);
    in
        tupHelper 0 [];
    
oldTupData :: Int -> [(LegacyTuple.Tuple4 Char Int Int Int)];
oldTupData !n =
    let
        tupHelper :: Int -> [(LegacyTuple.Tuple4 Char Int Int Int)] -> [(LegacyTuple.Tuple4 Char Int Int Int)];
        tupHelper !i acc =
            if i == n then
                acc
            else
                tupHelper (i+1) ((LegacyTuple.Tuple4 'c' i (n-i) (n+i)) : acc);
    in
        tupHelper 0 [];
    
oldElementEquals n =
    let
        forward = oldTupData n;
        backward = List.reverse forward;
        pwiseEq x y =
            equals (LegacyTuple.tuple4Field1 x) (LegacyTuple.tuple4Field1 y) &&
            equals (LegacyTuple.tuple4Field2 x) (LegacyTuple.tuple4Field2 y) &&
            equals (LegacyTuple.tuple4Field3 x) (LegacyTuple.tuple4Field3 y) &&
            equals (LegacyTuple.tuple4Field4 x) (LegacyTuple.tuple4Field4 y);
    in
        List.zipWith pwiseEq forward backward ++   // The all-True case
        List.zipWith pwiseEq forward forward;    // The all-False case

newElementEquals n =
    let
        forward = newTupData n;
        backward = List.reverse forward;
        pwiseEq x y =
            equals (Prelude.field1 x) (Prelude.field1 y) &&
            equals (Prelude.field2 x) (Prelude.field2 y) &&
            equals (Prelude.field3 x) (Prelude.field3 y) &&
            equals (Prelude.field4 x) (Prelude.field4 y);
    in
        List.zipWith pwiseEq forward backward ++   // The all-True case
        List.zipWith pwiseEq forward forward;    // The all-False case

newMethodEquals n =
    let
        forward = newTupData n;
        backward = List.reverse forward;
    in
        List.zipWith equals forward backward ++
        List.zipWith equals forward forward;

oldMethodEquals n =
    let
        forward = oldTupData n;
        backward = List.reverse forward;
    in
        List.zipWith equals forward backward ++
        List.zipWith equals forward forward;
                                                 
//this is the Prelude's implementation. The problem is that average is defined only on [Double] and
//so it is evidently not sufficiently general. The problem is that generalizing the implementation in a naive
//way results in a considerable performance penalty (3.982s to 6.372s). 

//:pt average (Prelude.upFromTo 1.0 1000000)
//Summary:    time = 3,982
average :: [Double] -> Double;
average !xs = sum xs / toDouble (length xs);

//:pt average (Prelude.upFromTo 1.0 1000000)
//Summary:    time = 6,372
average2 :: Num a => [a] -> Double;
average2 !xs = average (map toDouble xs);

//:pt average3 (Prelude.upFromTo 1.0 1000000)
//Summary:    time = 1,645
//It is interesting that average3 is both more general, as well as considerably faster, than average.
//Some reasons for this:
//average traverses the list twice, once to sum and once for the length.
//Also List.sum is a generic summing function that works for all Nums and so is slower in this
//case were the sum is a specialized sum over Doubles.
average3 :: Num a => [a] -> Double;
average3 !xs =
    let
        average3Helper :: Num a => [a] -> Double -> Int -> Double;
        average3Helper !xs !partialSum !partialLength =
            case xs of
            [] ->
                if (partialLength == 0) then
                    Prelude.notANumber
                else
                    partialSum / toDouble partialLength;
            xsHead : xsTail ->
                average3Helper xsTail (partialSum + toDouble xsHead) (partialLength + 1);
            ;
    in
        average3Helper xs 0 0;
    
//an experiment in what the penalty is for making average3 generic on Num a => [a].  
//:pt average4 (Prelude.upFromTo 1.0 1000000)    
//Summary:    time = 1,306
average4 :: [Double] -> Double;
average4 !xs =
    let
        average4Helper :: [Double] -> Double -> Int -> Double;
        average4Helper !xs !partialSum !partialLength =
            case xs of
            [] ->
                if (partialLength == 0) then
                    Prelude.notANumber
                else
                    partialSum / toDouble partialLength;
            xsHead : xsTail ->
                average4Helper xsTail (partialSum + xsHead) (partialLength + 1);
            ;
    in
        average4Helper xs 0 0; 
    
//here is a technique for using a refined version for a specific type, and a default version otherwise.
//If Typeable were automatically a superclass of all classes, it would not appear in the constraints.
//:pt average5 (Prelude.upFromTo 1.0 1000000)    
//Summary:    time = 2,972
//the performance test results seem to indicate a bug. We would expect this result to be the same as
//the average4 performance test.
average5 :: (Num a, Typeable a) => [a] -> Double;
average5 !xs =   
    if typeOf xs == typeOf ([] :: [Double]) then
        average4 (unsafeCoerce xs)
    else        
        average3 xs;

//:pt average6 (Prelude.upFromTo 1.0 1000000)
//Summary:    time = 2,994
average6 :: (Num a, Typeable a) => [a] -> Double;
average6 !xs =   
    average4 (unsafeCoerce xs);
          

averagePlinged :: [Double] -> Double;
averagePlinged !xs = sum xs / toDouble (length xs); 

//add an extra argument to avoid alias elimination.
averageIndirect :: Boolean -> [Double] -> Double;
averageIndirect !b !xs = averagePlinged xs;

//here is an interesting way of converting a Num a value to a String.
//simply using toDouble will lose precision for Integer values. 
numToString :: (Num a, Typeable a) => a -> String;
numToString n =
    if typeOf n == typeOf (1 :: Int) then
        Prelude.intToString (unsafeCoerce n)    
    else if typeOf n == typeOf (1 :: Prelude.Integer) then
        Prelude.integerToString (unsafeCoerce n)
    else
        Prelude.doubleToString (toDouble n);

//OK- so the time difference between 
//:pt average5 (Prelude.upFromTo 1.0 1000000)   
//and
//:pt average4 (Prelude.upFromTo 1.0 1000000)
//is a lecc bug (to be fixed). However, an interesting reason for it is that the list used to test the function is produced 
//and consumed by the test (in theory). However, what in the more typical case where the list is held onto?

//fully expands the list in memory
expandedList :: Int -> [Double];
expandedList n = 
    let
        list = upFromTo (1 :: Double) (toDouble n);
    in
        seq (last list) list;

//The following 3 results make sense:
//average5, despite having an overloaded type signature, is able to attain the performance as the non-overloaded
//average4 via specialization. average3 represents the situation where no specialization occcurs, so we pay
//a 12.6% penalty for not doing the optimization in average5 but instead writing code like average3.
//In some special cases it may be worthwhile troubling over such a difference.  
     
//:pt average5 (expandedList 1000000)    
//Summary:    time = 3,072
    
//:pt average4 (expandedList 1000000)
//Summary:    time = 3,067    

//:pt average3 (expandedList 1000000)    
//Summary:    time = 3,515

//the gain of average3 over average (the old impl of Prelude.average) is not as much as with the streamed list
//this is because the overhead of memory use makes up more of this benchmark. However, it is still a 27% improvement.  
    
//:pt average (expandedList 1000000)
//Summary:    time = 4,213    
    
    
///////////////////////////////////////////////////////////////////////
    
//map composed with fst. Inspecting our code, fst (and snd, field1, etc) are extremely commonly
//used compositions. 
    
//list is expanded in memory    
expandedListOfPairs :: Int -> [(Int, Int)];
expandedListOfPairs n = 
    let
        list = upFromTo (1 :: Int) n;
        pairedList = zip list list;
    in
        seq (last pairedList) pairedList;
    
    
mapFst :: r\#1 => [{r | #1 :: a}] -> [a];
mapFst !listOfRecords =
    case listOfRecords of
    headListOfRecords : tailListOfRecords ->
        headListOfRecords.#1 : mapFst tailListOfRecords;
    [] -> [];
    ;

//running: benchmarkMapFst1 500000
//Summary:    time = 3,494
//Standard deviation of runs = 36.66ms or 1.04% of average
//
//running: benchmarkMapFst2 500000
//Summary:    time = 3,505
//Standard deviation of runs = 55.24ms or 1.57% of average
//
//running: benchmarkMapFst3 500000
//Summary:    time = 3,395
//Standard deviation of runs = 54.72ms or 1.61% of average
    
//conclusion: small 3% improvement in inlining map fst as shown.    
benchmarkMapFst1 n = sum (map Prelude.fst (expandedListOfPairs n));
benchmarkMapFst2 n = sum (map Prelude.field1 (expandedListOfPairs n));
benchmarkMapFst3 n = sum (mapFst (expandedListOfPairs n));

//a "higher order pattern"

//running: mapJust (\x -> Prelude.Nothing :: Prelude.Maybe Prelude.Int) (Prelude.upFromTo (1 :: Prelude.Int) 2000000)
//Summary:    time = 2,854
//Standard deviation of runs = 8.66ms or 0.3% of average
//
//running: mapJust2 (\x -> Prelude.Nothing :: Prelude.Maybe Prelude.Int) (Prelude.upFromTo (1 :: Prelude.Int) 2000000)
//Summary:    time = 1,312
//Standard deviation of runs = 0ms or 0% of average

//running: List.last (mapJust (\x -> Prelude.Just 1 :: Prelude.Maybe Prelude.Int) (Prelude.upFromTo (1 :: Prelude.Int) 2000000))
//Summary:    time = 4,499
//Standard deviation of runs = 31.49ms or 0.69% of average

//running: List.last (mapJust2 (\x -> Prelude.Just 1 :: Prelude.Maybe Prelude.Int) (Prelude.upFromTo (1 :: Prelude.Int) 2000000))
//Summary:    time = 2,093
//Standard deviation of runs = 1ms or 0.04% of average


mapJust :: (a -> Maybe b) -> [a] -> [b];
mapJust f list = List.map Prelude.fromJust (filter Prelude.isJust (List.map f list));

mapJust2 :: (a -> Maybe b) -> [a] -> [b];
mapJust2 f list =
    case list of
    [] -> [];
    listHead : listTail ->
        case f listHead of
        Nothing -> mapJust2 f listTail;
        Just v -> v : mapJust2 f listTail;
        ;
    ;
  
     
    
//'find predicate list' = the first value of list for which the predicate function is True, if there is one.
//e.g. find isEven [1, 1, 4, 1, 2, 1, 1, 6] = Just 4                
findOld :: (a -> Boolean) -> [a] -> Maybe a;
findOld predicate = Prelude.compose Prelude.listToMaybe (List.filter predicate);

findIndexOld :: (a -> Boolean) -> [a] -> Maybe Int;
findIndexOld predicate = Prelude.compose Prelude.listToMaybe (List.findIndices predicate);


data DeepSeqTestType = 
    DeepSeqNested1      
        type1   :: DeepSeqTestType 
        type2   :: DeepSeqTestType | 
    DeepSeqNested2 
        type    :: DeepSeqTestType 
        string  :: String | 
    DeepSeqNested3 
        string  :: String 
        type    :: DeepSeqTestType | 
    DeepSeqString 
        string  :: String;
testDeepSeq =
    testDeepSeq1 == "a, b, c, d, e, f, g, h, i, j, k, l" &&
    testDeepSeq2 == "a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x" &&
    testDeepSeq3 == "a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x" &&
    testDeepSeq4 == "a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x" &&
    testDeepSeq5 == "a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x" ||
    error "Error in M2.testDeepSeq";
    
// Test the order of evaluation of members in a nested data structure with 'deepSeq'.
private testDeepSeq1 = 
    let
        accumulator = makeJStringAccumulator;
        dataInstance = DeepSeqNested1 (DeepSeqNested3 (jStringAccumulator_AddString accumulator "a") (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "b")) (DeepSeqString (jStringAccumulator_AddString accumulator "c"))) (jStringAccumulator_AddString accumulator "d"))) (DeepSeqNested2 (DeepSeqNested3 (jStringAccumulator_AddString accumulator "e") (DeepSeqNested1 (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "f")) (DeepSeqString (jStringAccumulator_AddString accumulator "g"))) (jStringAccumulator_AddString accumulator "h")) (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "i")) (DeepSeqString (jStringAccumulator_AddString accumulator "j"))) (jStringAccumulator_AddString accumulator "k")))) (jStringAccumulator_AddString accumulator "l"));
    in
        Prelude.deepSeq dataInstance (jStringAccumulator_getStrings accumulator);

// Test the order of evaluation of members in a nested data structure in fields in an ordinal record with 'deepSeq'.
private testDeepSeq2 = 
    let
        accumulator = makeJStringAccumulator;
        dataInstance = DeepSeqNested1 (DeepSeqNested3 (jStringAccumulator_AddString accumulator "a") (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "b")) (DeepSeqString (jStringAccumulator_AddString accumulator "c"))) (jStringAccumulator_AddString accumulator "d"))) (DeepSeqNested2 (DeepSeqNested3 (jStringAccumulator_AddString accumulator "e") (DeepSeqNested1 (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "f")) (DeepSeqString (jStringAccumulator_AddString accumulator "g"))) (jStringAccumulator_AddString accumulator "h")) (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "i")) (DeepSeqString (jStringAccumulator_AddString accumulator "j"))) (jStringAccumulator_AddString accumulator "k")))) (jStringAccumulator_AddString accumulator "l"));
        dataInstance2 = DeepSeqNested1 (DeepSeqNested3 (jStringAccumulator_AddString accumulator "m") (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "n")) (DeepSeqString (jStringAccumulator_AddString accumulator "o"))) (jStringAccumulator_AddString accumulator "p"))) (DeepSeqNested2 (DeepSeqNested3 (jStringAccumulator_AddString accumulator "q") (DeepSeqNested1 (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "r")) (DeepSeqString (jStringAccumulator_AddString accumulator "s"))) (jStringAccumulator_AddString accumulator "t")) (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "u")) (DeepSeqString (jStringAccumulator_AddString accumulator "v"))) (jStringAccumulator_AddString accumulator "w")))) (jStringAccumulator_AddString accumulator "x"));
    in
        Prelude.deepSeq (dataInstance, dataInstance2) (jStringAccumulator_getStrings accumulator);

// Test the order of evaluation of members in a nested data structure in fields in an ordinal record with 'deepSeq'.
private testDeepSeq3 = 
    let
        accumulator = makeJStringAccumulator;
        dataInstance = DeepSeqNested1 (DeepSeqNested3 (jStringAccumulator_AddString accumulator "a") (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "b")) (DeepSeqString (jStringAccumulator_AddString accumulator "c"))) (jStringAccumulator_AddString accumulator "d"))) (DeepSeqNested2 (DeepSeqNested3 (jStringAccumulator_AddString accumulator "e") (DeepSeqNested1 (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "f")) (DeepSeqString (jStringAccumulator_AddString accumulator "g"))) (jStringAccumulator_AddString accumulator "h")) (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "i")) (DeepSeqString (jStringAccumulator_AddString accumulator "j"))) (jStringAccumulator_AddString accumulator "k")))) (jStringAccumulator_AddString accumulator "l"));
        dataInstance2 = DeepSeqNested1 (DeepSeqNested3 (jStringAccumulator_AddString accumulator "m") (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "n")) (DeepSeqString (jStringAccumulator_AddString accumulator "o"))) (jStringAccumulator_AddString accumulator "p"))) (DeepSeqNested2 (DeepSeqNested3 (jStringAccumulator_AddString accumulator "q") (DeepSeqNested1 (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "r")) (DeepSeqString (jStringAccumulator_AddString accumulator "s"))) (jStringAccumulator_AddString accumulator "t")) (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "u")) (DeepSeqString (jStringAccumulator_AddString accumulator "v"))) (jStringAccumulator_AddString accumulator "w")))) (jStringAccumulator_AddString accumulator "x"));
    in
        Prelude.deepSeq {#2 = dataInstance2, #1 = dataInstance} (jStringAccumulator_getStrings accumulator);

// Test the order of evaluation of members in a nested data structure in fields in a textual record with 'deepSeq'.
private testDeepSeq4 = 
    let
        accumulator = makeJStringAccumulator;
        dataInstance = DeepSeqNested1 (DeepSeqNested3 (jStringAccumulator_AddString accumulator "a") (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "b")) (DeepSeqString (jStringAccumulator_AddString accumulator "c"))) (jStringAccumulator_AddString accumulator "d"))) (DeepSeqNested2 (DeepSeqNested3 (jStringAccumulator_AddString accumulator "e") (DeepSeqNested1 (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "f")) (DeepSeqString (jStringAccumulator_AddString accumulator "g"))) (jStringAccumulator_AddString accumulator "h")) (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "i")) (DeepSeqString (jStringAccumulator_AddString accumulator "j"))) (jStringAccumulator_AddString accumulator "k")))) (jStringAccumulator_AddString accumulator "l"));
        dataInstance2 = DeepSeqNested1 (DeepSeqNested3 (jStringAccumulator_AddString accumulator "m") (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "n")) (DeepSeqString (jStringAccumulator_AddString accumulator "o"))) (jStringAccumulator_AddString accumulator "p"))) (DeepSeqNested2 (DeepSeqNested3 (jStringAccumulator_AddString accumulator "q") (DeepSeqNested1 (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "r")) (DeepSeqString (jStringAccumulator_AddString accumulator "s"))) (jStringAccumulator_AddString accumulator "t")) (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "u")) (DeepSeqString (jStringAccumulator_AddString accumulator "v"))) (jStringAccumulator_AddString accumulator "w")))) (jStringAccumulator_AddString accumulator "x"));
    in
        Prelude.deepSeq {foo2 = dataInstance2, foo1 = dataInstance} (jStringAccumulator_getStrings accumulator);

// Test the order of evaluation of members in a nested data structure in fields in a mixed record with 'deepSeq'.
private testDeepSeq5 = 
    let
        accumulator = makeJStringAccumulator;
        dataInstance = DeepSeqNested1 (DeepSeqNested3 (jStringAccumulator_AddString accumulator "a") (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "b")) (DeepSeqString (jStringAccumulator_AddString accumulator "c"))) (jStringAccumulator_AddString accumulator "d"))) (DeepSeqNested2 (DeepSeqNested3 (jStringAccumulator_AddString accumulator "e") (DeepSeqNested1 (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "f")) (DeepSeqString (jStringAccumulator_AddString accumulator "g"))) (jStringAccumulator_AddString accumulator "h")) (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "i")) (DeepSeqString (jStringAccumulator_AddString accumulator "j"))) (jStringAccumulator_AddString accumulator "k")))) (jStringAccumulator_AddString accumulator "l"));
        dataInstance2 = DeepSeqNested1 (DeepSeqNested3 (jStringAccumulator_AddString accumulator "m") (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "n")) (DeepSeqString (jStringAccumulator_AddString accumulator "o"))) (jStringAccumulator_AddString accumulator "p"))) (DeepSeqNested2 (DeepSeqNested3 (jStringAccumulator_AddString accumulator "q") (DeepSeqNested1 (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "r")) (DeepSeqString (jStringAccumulator_AddString accumulator "s"))) (jStringAccumulator_AddString accumulator "t")) (DeepSeqNested2 (DeepSeqNested1 (DeepSeqString (jStringAccumulator_AddString accumulator "u")) (DeepSeqString (jStringAccumulator_AddString accumulator "v"))) (jStringAccumulator_AddString accumulator "w")))) (jStringAccumulator_AddString accumulator "x"));
    in
        Prelude.deepSeq {foo2 = dataInstance2, #1 = dataInstance} (jStringAccumulator_getStrings accumulator);
        
        
f1 :: Prelude.Integer -> Prelude.Integer;
f1 !x = if x < 2 then 1 else (x * (f1 (x-1)));

f2 :: Prelude.Integer -> Prelude.Integer;
f2 !x = if (x < 2) then 1 else ((f2 (x-1)) * x);

///////////////////////////////////////////////////////////////////////

// Tests for named data constructors

data private DCArgNameTestType =
    // Test ordered ordinal field names
    DCArgNameTestTypeDC1
        #1   :: Int
        #2   :: Double |
    // Test out-of-order ordinal field names
    // Test reuse of arg name #2
    DCArgNameTestTypeDC2
        #3   :: Int
        #2   :: Double |
    // Test textual field names
    DCArgNameTestTypeDC3
        arg1 :: Int
        arg2 :: Double |
    // Test mixed ordinal and textual field names
    // Test reuse of ordinal and textual arg names.
    DCArgNameTestTypeDC4
        arg1 :: Int
        #1   :: Double
        arg2 :: Double |
    // Unnamed arguments -- disallowed.
//    DCArgNameTestTypeDC5
//        Int
//        Double
//        Double |
    // Won't compile: Reuse of arg name within a data constructor.
//    DCArgNameTestTypeDC7
//        arg1 :: Int
//        arg1 :: Double |
    // Won't compile: #0 is not a valid name.
//    DCArgNameTestTypeDC6
//        #0 :: Double |
    DCArgNameTestTypeDC99
    deriving Eq, Ord;


//new version
//note the formatting convention: put each argument on a line of its own; use indenting to help 
//Compound type arguments (such as M2Map k a) still must be parenthesized (as before).
//Some of the field names can be omitted. They do not obtain a default field name value though.
//Order is the declaration order, not the fieldname order of records.
data private M2Map k a =
    private Tip |
    private Bin
        size      :: !Int
        key       :: !k
        value     :: a
        leftMap   :: !(M2Map k a)
        rightMap  :: !(M2Map k a);

// old version - still legal with new data declaration 
m2MapIsEmpty1 :: M2Map k a  -> Boolean; 
m2MapIsEmpty1 !t =
    case t of
    Tip -> True;
    Bin sz k x l r  -> False;
    ;

// new version. Ignore the fields of Bin
m2MapIsEmpty2 :: M2Map k a  -> Boolean;
m2MapIsEmpty2 !t =
    case t of
    Tip -> True;
    Bin {} -> False;
    ;

// old version - still legal with new data declaration 
m2MapSize1 :: M2Map k a -> Int; 
m2MapSize1 !t =
    case t of
    Tip -> 0;
    Bin sz k x l r  -> sz;
    ;

// new version - refers only to the size field 
// the braces indicate that you want to use field names in the matching rather than positional notation 
m2MapSize2 :: M2Map k a -> Int; 
m2MapSize2 !t =
    case t of
    Tip -> 0;
    Bin {size = sz} -> sz;
    ;

// new version #2. punning is allowed. This is equivalent to replacing {size} with {size = size} 
m2MapSize3 :: M2Map k a -> Int; 
m2MapSize3 !t =
    case t of
    Tip -> 0;
    Bin {size} -> size;
    ;

// old version - still legal with new data declaration 
m2MapLookup1 :: Ord k => k -> M2Map k a -> Maybe a; 
m2MapLookup1 !k !t =
    case t of
    Tip -> Nothing;
    Bin sz kx x l r ->
        case compare k kx of
        LT -> m2MapLookup1 k l;
        GT -> m2MapLookup1 k r;
        EQ -> Just x;
        ;  
    ; 

// new version - still legal with new data declaration 
// the field 'size' is omitted in the case matching since it is not used in the right hand side.
// Ordering of the fields doesn't matter (and doesn't follow the ordering of the data declaration) 
m2MapLookup2 :: Ord k => k -> M2Map k a -> Maybe a; 
m2MapLookup2 !k !t =
    case t of
    Tip -> Nothing;
    Bin {leftMap, rightMap, key, value} ->
        case compare k key of
        LT -> m2MapLookup2 k leftMap;
        GT -> m2MapLookup2 k rightMap;
        EQ -> Just value;
        ;  
    ; 

m2MapTest1 :: M2Map k a -> Maybe Int; 
m2MapTest1 !t =
    case t of
    Tip -> Nothing;
    Bin {leftMap = l, rightMap = _, size=_, key} -> Nothing;
    ;

data private M2TestData a b =
    private M2TestDataCons1 #1::a #2::b |
    private M2TestDataCons2 #1::b #2::a ;


m2DCArgTest1 :: M2TestData Boolean Int -> Boolean;
m2DCArgTest1 !t =
    case t of
    M2TestDataCons1 {#1=numOne} -> numOne;
    M2TestDataCons2 {#1} -> True;
    ;


// Test qualification of a data constructor alt in a case statement.
m2DCArgTest2 :: M2TestData Boolean Int -> Boolean;
m2DCArgTest2 !t =
    case t of
    M2TestDataCons1 {#1=numOne} -> numOne;
    M2.M2TestDataCons2 {#1} -> True;
    ;

m2DCArgTestFoo :: Prelude.Either Boolean Boolean -> Boolean;
m2DCArgTestFoo !t =
    case t of
    Prelude.Right a -> a;
    _ -> False;
    ;

// Test argument name disambiguation in GemCutter.
// Somewhat pathological - the argument name for "#1" becomes "field1_2".
data private M2TestData2 a b =
    private M2TestData2Cons1 
        #1       :: a 
        field1   :: b 
        field1_1 :: b;


testNamedDataConstructors :: Boolean;
testNamedDataConstructors = 
    testNamedDCs1
    && testNamedDCs2
    && testNamedDCs3
    && testStrictNamedDCSelection
    && testStrictNamedDCSelection2
    && testLazyNamedDCSelection
    && testTopLevelNamedDCSelection
    && testNamedDCSelection
    && testNamedDCSelection2
    && testNamedDCSelection3
    && testNamedDCSelection4
    || error "M2.testNamedDataConstructors failed.";


// Test field selection.
testNamedDCs1 = equals ([1.0].Cons.head) 1.0;
testNamedDCs2 = equals ([1.0].Prelude.Cons.tail) [];
testNamedDCs3 = equals ([1.0, 2.0, 3.0, 4.0, 5.0].Cons.tail.Cons.tail.Cons.tail.Cons.tail.Cons.head) 5.0;

// field selection in a lazy context
lazyId x = x;
testLazyNamedDCSelectionHelper = lazyId ([1.0].Cons.head);
testLazyNamedDCSelection = testLazyNamedDCSelectionHelper == 1.0;

// field selection in a strict context
strictId !x = x;                // Prelude.id should be strict in its arg, but just in case..
testStrictNamedDCSelectionHelper = strictId ([1.0].Cons.head);
testStrictNamedDCSelection = testStrictNamedDCSelectionHelper == 1.0;


// modeled on RecordTests.testStrictSelection
prependANum x = 
    if (head x > 5.0) then (4 : x) else (1 : x);

testStrictNamedDCSelection2Helper = 
    let
        someNumber = 1.0 + 2.0;
        list = [someNumber];
        list2 = prependANum list;
    in
        list2.Cons.tail.Cons.head;

testStrictNamedDCSelection2 = testStrictNamedDCSelection2Helper == 3.0;


// field selection in a top-level context
testTopLevelNamedDCSelectionHelper = [2.0].Cons.head;
testTopLevelNamedDCSelection = testTopLevelNamedDCSelectionHelper == 2.0;


// field selection twice from the same value.
// (Aug 8, 05) Note that for the time being these are slightly inefficient, as they are unpacked into separate case statements.
//    ie. dcValue.Cons.head + dcValue.Cons.tail.Cons.head    
//      becomes something like
//        (case dcValue of Cons {head} -> head) + (case (case dcValue of Cons {tail} -> tail) of Cons {head} -> head)
//      We could have saved one unpacking:
//        case dcValue of Cons {head, tail} -> head + (case tail of Cons {head} -> head)
testNamedDCSelection =
    let
        dcValue = [1.2, 2.3, 3.4];
    in
        (dcValue.Cons.head + dcValue.Cons.tail.Cons.head) == 3.5;


// field selection in a let.  This is transformed to a case, which needs lifting.
testNamedDCSelection2 =
    let
        dcValue = [1.2, 2.3, 3.4];
        dcValueHead = dcValue.Cons.head;
        dcValueTailHead = dcValue.Cons.tail.Cons.head;
    in
        (dcValueHead + dcValueTailHead) == 3.5;


testNamedDCSelection3 =
    let
        a = Just 2.0;
        b = Just 3.0;
    in
        case a of
        Just {value} -> value != b.Just.value;
        ;

        
data private M2TestData3 a b c =
    private M2TestData3Cons1 
        #1       :: a 
        #2       :: b 
        field1   :: c;

// Test extraction of an ordinal field.
testNamedDCSelection4 = (M2TestData3Cons1 2.0 "foo" Nothing).M2TestData3Cons1.#1 == 2.0;


// Runtime error (used by DataConstructorCode_Test.java)
public selectDCFieldShouldFail = ([] :: [Prelude.Double]).Cons.head;


////////////////////////////////////////////////////////////////////
// Basic comparison of the efficiency of data constructor field selections
// vs. the corresponding case expressions.

//Some tests for benchmarking 

/**
 * A test type with only one data constructor wrapping an int.
 * The single data constructor case is handled more efficiently in lecc that the general case.
 */
data private M2TestDataSingleDCIntWrapper =
    private M2TestDataSingleDCIntWrapper 
        wrappedInt      :: Int;


/**
 * A test type with two data constructors wrapping an int.
 * The single data constructor case is handled more efficiently in lecc that the general case.
 */
data private M2TestDataTwoDCIntWrapper =
    
    private M2TestDataTwoDCIntWrapper1
        wrappedInt      :: Int |
        
    private M2TestDataTwoDCIntWrapper2 
        wrappedInt      :: Int;


/**
 * A test type with thirty-five data constructors wrapping an int.
 * In lecc, case expressions are handled with a java switch statement, whose efficiency depends on the number of cases.
 */
data private M2TestDataBigDCIntWrapper =
    
    private M2TestDataBigDCIntWrapper1
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper2
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper3
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper4
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper5
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper6
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper7
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper8
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper9
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper10
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper11
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper12
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper13
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper14
        wrappedInt      :: Int |
    
    private M2TestDataBigDCIntWrapper15
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper16
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper17
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper18
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper19
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper20
        wrappedInt      :: Int |
    
    private M2TestDataBigDCIntWrapper21
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper22
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper23
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper24
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper25
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper26
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper27
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper28
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper29
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper30
        wrappedInt      :: Int |

    private M2TestDataBigDCIntWrapper31
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper32
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper33
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper34
        wrappedInt      :: Int |
        
    private M2TestDataBigDCIntWrapper35
        wrappedInt      :: Int ;
        
bigWrappedSingleDCIntList :: Int -> [M2TestDataSingleDCIntWrapper];
bigWrappedSingleDCIntList !n =
    let
        dataHelper !i =
            if (i == n) then
                []
            else
                (M2TestDataSingleDCIntWrapper 1) : dataHelper (i + 1);
    in
        dataHelper 0;   

bigWrappedTwoDCIntList :: Int -> [M2TestDataTwoDCIntWrapper];
bigWrappedTwoDCIntList !n =
    let
        dataHelper !i =
            if (i == n) then
                []
            else
                (M2TestDataTwoDCIntWrapper1 1) : dataHelper (i + 1);
    in
        dataHelper 0;   


bigWrappedBigDCIntList :: Int -> [M2TestDataBigDCIntWrapper];
bigWrappedBigDCIntList !n =
    let
        dataHelper !i =
            if (i == n) then
                []
            else
                (M2TestDataBigDCIntWrapper1 1) : dataHelper (i + 1);
    in
        dataHelper 0;   


getWrappedIntFromSingleDCIntWrapper_select :: M2TestDataSingleDCIntWrapper -> Int;
getWrappedIntFromSingleDCIntWrapper_select !x = x.M2TestDataSingleDCIntWrapper.wrappedInt;

getWrappedIntFromSingleDCIntWrapper_case :: M2TestDataSingleDCIntWrapper -> Int;
getWrappedIntFromSingleDCIntWrapper_case !x = 
    case x of 
        M2TestDataSingleDCIntWrapper wrappedInt -> wrappedInt;
    ;

getWrappedIntFromTwoDCIntWrapper_select :: M2TestDataTwoDCIntWrapper -> Int;
getWrappedIntFromTwoDCIntWrapper_select !x = x.M2TestDataTwoDCIntWrapper1.wrappedInt;

getWrappedIntFromTwoDCIntWrapper_case :: M2TestDataTwoDCIntWrapper -> Int;
getWrappedIntFromTwoDCIntWrapper_case !x = 
    case x of 
        M2TestDataTwoDCIntWrapper1 wrappedInt -> wrappedInt;
    ;

getWrappedIntFromBigDCIntWrapper_select :: M2TestDataBigDCIntWrapper -> Int;
getWrappedIntFromBigDCIntWrapper_select !x = x.M2TestDataBigDCIntWrapper1.wrappedInt;

getWrappedIntFromBigDCIntWrapper_case :: M2TestDataBigDCIntWrapper -> Int;
getWrappedIntFromBigDCIntWrapper_case !x = 
    case x of 
        M2TestDataBigDCIntWrapper1 wrappedInt -> wrappedInt;
    ;

selectSumSingleDC :: Int -> Int;
selectSumSingleDC !n = sum (map getWrappedIntFromSingleDCIntWrapper_select (bigWrappedSingleDCIntList n));
caseSumSingleDC :: Int -> Int;
caseSumSingleDC !n = sum (map getWrappedIntFromSingleDCIntWrapper_case (bigWrappedSingleDCIntList n));

selectSumTwoDC :: Int -> Int;
selectSumTwoDC !n = sum (map getWrappedIntFromTwoDCIntWrapper_select (bigWrappedTwoDCIntList n));
caseSumTwoDC :: Int -> Int;
caseSumTwoDC !n = sum (map getWrappedIntFromTwoDCIntWrapper_case (bigWrappedTwoDCIntList n));

selectSumBigDC :: Int -> Int;
selectSumBigDC !n = sum (map getWrappedIntFromBigDCIntWrapper_select (bigWrappedBigDCIntList n));
caseSumBigDC :: Int -> Int;
caseSumBigDC !n = sum (map getWrappedIntFromBigDCIntWrapper_case (bigWrappedBigDCIntList n));

//benchmark run Aug 24, 2005
//
//selectSumSingleDC 2000000
//Summary:    time = 5,326
//
//caseSumSingleDC 2000000
//Summary:    time = 5,352
//
//cases and field selections are roughly equal for the single DC case.
//
//
//selectSumTwoDC 2000000
//Summary:    time = 5,412
//
//caseSumTwoDC 2000000
//Summary:    time = 5,406
//
//cases and field selections are roughly equal for the two DC case.
//
//
//selectSumBigDC 2000000
//Summary:    time = 5,461
//
//caseSumBigDC 2000000
//Summary:    time = 5,439
//
//cases and field selections are roughly equal for the big DC case.


/**
 * A test type with only one data constructor wrapping a function.
 * 
 * f !x = x.Just.value 2.0
 * is equivalent to 
 * f !x = (case x of Just value -> value;) 2.0;
 * which appears different from
 * f !x = case x of Just value -> value 2.0;;
 * 
 * in that the selection is applied to the value 2.0.
 */
data private M2TestDataSingleDCFnWrapper =
    private M2TestDataSingleDCFnWrapper 
        wrappedFn       :: (Int -> Int);


bigWrappedSingleDCFnList :: Int -> [M2TestDataSingleDCFnWrapper];
bigWrappedSingleDCFnList !n =
    let
        wrappedFn !x = x + (1 :: Int);
        dataHelper !i =
            if (i == n) then
                []
            else
                (M2TestDataSingleDCFnWrapper wrappedFn) : dataHelper (i + 1);
    in
        dataHelper 0;   

applySingleDCFnWrapperFnCase !x =
    case x of 
        M2TestDataSingleDCFnWrapper wrappedFn -> wrappedFn (2::Int);
    ;

applySingleDCFnWrapperFnSelect !x = x.M2TestDataSingleDCFnWrapper.wrappedFn (2::Int);

selectSumSingleDC2 :: Int -> Int;
selectSumSingleDC2 !n = sum (map applySingleDCFnWrapperFnCase (bigWrappedSingleDCFnList n));
caseSumSingleDC2 :: Int -> Int;
caseSumSingleDC2 !n = sum (map applySingleDCFnWrapperFnCase (bigWrappedSingleDCFnList n));


//benchmark run Aug 24, 2005
//
//selectSumSingleDC2 2000000
//Summary:    time = 6,732
//
//caseSumSingleDC2 2000000
//Summary:    time = 6,773
//
//cases and field selections are roughly equal for the single DC case.


data M2TestDataSingleDCFnWrapper2 = 
    M2TestDataSingleDCFnWrapper2         wrappedFn :: (Double -> Double);

makeM2TestDataSingleDCFnWrapper2 = M2TestDataSingleDCFnWrapper2 (add 1.0);

fdcFn :: M2TestDataSingleDCFnWrapper2 -> Double -> Double;
fdcFn fdc dbl =
    (fdc.M2TestDataSingleDCFnWrapper2.wrappedFn) dbl;
    
fdcFn2 :: M2TestDataSingleDCFnWrapper2 -> Double -> Double;
fdcFn2 fdc dbl =
    case fdc of 
    M2TestDataSingleDCFnWrapper2 wrappedFn -> wrappedFn dbl;
    ;
    
fdcTest1 :: Int -> Double;    
fdcTest1 x = List.sum (map (fdcFn makeM2TestDataSingleDCFnWrapper2) (take x (repeat 1.0)));    

fdcTest2 :: Int -> Double;    
fdcTest2 x = List.sum (map (fdcFn2 makeM2TestDataSingleDCFnWrapper2) (take x (repeat 1.0)));    

//benchmark run Aug 25, 2005
//
//fdcTest1 2000000
//Summary:    time = 9,390
//
//fdcTest2 2000000
//Summary:    time = 8,107
//
//cases are roughly 13.7% faster than field selections here.




///////////////////////////////////////////////////////////////////////

//Tests for case extraction using pattern group constructors.

// All have ordinal field #1 except for 4.
data private M2PatGroupTestData a b c =
    private M2PatGroupTestDataCons1 
        #1       :: a 
        #2       :: b 
        field1   :: c |
    private M2PatGroupTestDataCons2
        #1       :: a 
        #2       :: b |
    private M2PatGroupTestDataCons3 
        #1       :: a 
        aField   :: c |
    private M2PatGroupTestDataCons4
        aField   :: c;


patGroupTest1 :: M2PatGroupTestData a b c -> Boolean;
private patGroupTest1 x =
    case x of
    (M2PatGroupTestDataCons1 | M2PatGroupTestDataCons4) {} -> True;
    _ -> False;
    ;

patGroupTest2 :: M2PatGroupTestData Boolean b c -> Boolean;
private patGroupTest2 x =
    case x of
    (M2PatGroupTestDataCons2 | M2PatGroupTestDataCons3) someField _ -> someField;
    _ -> False;
    ;

patGroupTest3 :: M2PatGroupTestData a b Double -> Double;
private patGroupTest3 x =
    case x of
    (M2PatGroupTestDataCons3 | M2PatGroupTestDataCons4) {aField} -> aField;
    _ -> -1.876;
    ;

patGroupTest4 :: M2PatGroupTestData a b Double -> Double;
private patGroupTest4 x =
    case x of
    (M2PatGroupTestDataCons3) {aField} -> aField;               // only one dc in the group
    _ -> -1.876;
    ;


///////////////////////////////////////////////////////////////////////

//  Tests for case extraction using ints and chars.

testIntCaseHelper x =
    case x of
    -1      -> "-1";
    -0      -> "0";
    1       -> "1";
    (2 | 3) -> "2 or 3";
    _       -> "Something else";
    ;

isMinusOne x =
    case x of
    -1          -> True;
    _           -> False;
    ; 
isZero_1 x =
    case x of
    -0          -> True;
    _           -> False;
    ; 
isZero_2 x =
    case x of
    0           -> True;
    _           -> False;
    ; 
isOne x =
    case x of
    1           -> True;
    _           -> False;
    ; 
    
// case on int in a lazy context
testLazyCaseOnIntHelper = 
    lazyId (case (98 + 1) of 
            99 -> 1.0; 
            _  -> 2.0;);

// case on int in a strict context
testStrictCaseOnIntHelper = 
    strictId (case (97 + 2) of 
              99 -> 1.0; 
              _  -> 2.0;);

testIntCase =
    assert(testLazyCaseOnIntHelper == 1.0) &&
    assert(testStrictCaseOnIntHelper == 1.0) &&
    assert(isMinusOne (-1)) &&
    assert(isZero_1 0) &&
    assert(isZero_2 0) &&
    assert(isOne 1) &&
    assert(equals (map testIntCaseHelper [-1, -0, 0, 1, 2, 3, 4, 5, 129873129319287391871239])
           ["-1", "0", "0", "1", "2 or 3", "2 or 3", "Something else", "Something else", "Something else"])
   ;

testCharCaseHelper x = 
    case x of
    ('a' | 'c' | 'e' | '\ucafe' | '\ubabe' | '\044' | '\'' | '\n') -> True;
    '\\' -> True;
    _ -> False;
    ;

isPercent1 x =
    case x of
    '%'         -> True;
    _           -> False;
    ; 
isPercent2 x =
    case x of
    '\045'      -> True;
    _           -> False;
    ; 
isPercent3 x =
    case x of
    '\u0025'    -> True;
    _           -> False;
    ; 

// case on char in a lazy context
testLazyCaseOnCharHelper = 
    lazyId (case 'a' of 
            'a' -> 1.0; 
            _   -> 2.0;);

// case on char in a strict context
testStrictCaseOnCharHelper = 
    strictId (case 'a' of 
              'a' -> 1.0; 
              _   -> 2.0;);

testCharCase = 
    assert(testLazyCaseOnCharHelper == 1.0) &&
    assert(testStrictCaseOnCharHelper == 1.0) &&
    assert(isPercent1 '%') &&
    assert(isPercent2 '%') &&
    assert(isPercent3 '%') &&
    assert(equals (map testCharCaseHelper (Prelude.append (toList "abcdefg") ['\u1234', '\ucafe', '\\', '\f', '\n', '\045', '\044']))
           (Prelude.append [True, False, True, False, True, False, False] [False, True, True, False, True, False, True]))
    ;


/////////////////////////////////////////////////////////////////////////////////////
///client prime puller -version 1

//experiment on how to write an external client that "pulls" values out of a CAL list
//lazily according to client demand.

//initially, can call this with an argument of M1.allPrimes.
nextNPrimes :: [Int] -> Int -> {nextNPrimes :: [Int], remainingPrimes :: [Int]};
nextNPrimes remainingPrimes nPrimesToTake =
    let    
        pair = List.splitAt nPrimesToTake remainingPrimes;
    in
        {nextNPrimes = pair.#1, remainingPrimes = pair.#2};
        

allPrimesExternal :: CalValue;
allPrimesExternal = unsafeCoerce (M1.allPrimes);
        
nextNPrimesExternal :: CalValue -> Int -> {nextNPrimes :: [Int], remainingPrimes :: CalValue};
nextNPrimesExternal remainingPrimesAsInternal nPrimesToTake =
    unsafeCoerce (nextNPrimes (unsafeCoerce remainingPrimesAsInternal) nPrimesToTake);

//sample of using nextNPrimesExternal in ICE. Note that since remainingPrimes is an InternalValue it
//is left in WHNF rather than being fully evaluated. This is a good thing since it is an infinite list!
//M2>nextNPrimesExternal allPrimesExternal 5
//
//running: nextNPrimesExternal allPrimesExternal 5
//Run Time:        219 ms
//
//Output:
//[[2, 3, 5, 7, 11], org.openquark.cal.machine.lecc.RTRecordSelection$Ordinal@1fd3d92]
    
    
/////////////////////////////////////////////////////////////////////////////////////
///client list puller -version 2

takeN :: [a] -> Int -> ([a], [a]); //result is (takeNList, remainingList)
takeN list nToTake = List.splitAt nToTake list;
                
takeNExternal :: Outputable a => CalValue -> Int -> ([a], CalValue);
takeNExternal list nToTake = unsafeCoerce (takeN (unsafeCoerce list) nToTake);

takeNExternal_ListOfInt :: CalValue -> Int -> ([Int], CalValue);
takeNExternal_ListOfInt list nToTake = takeNExternal list nToTake;

stringList :: [String];
stringList = List.cycle (List.sort ["Anton", "Linda", "Pat", "Yves", "Michael", "Andy", "Fred", "Frank", "Helen", "Sammy", "Sara", "Alexander"]);

stringListExternal :: CalValue;
stringListExternal = unsafeCoerce stringList;

takeNExternal_ListOfString :: CalValue -> Int -> ([String], CalValue);
takeNExternal_ListOfString list nToTake = takeNExternal list nToTake;

//Demo program: clientTwoListPuller
//
//How many more primes would you like? (enter q to quit)
//2
//the next 2 primes are [2, 3]
//How many more names would you like? (enter q to quit)
//10
//the next 10 names are [Alexander, Andy, Anton, Frank, Fred, Helen, Linda, Michael, Pat, Sammy]
//How many more primes would you like? (enter q to quit)
//3
//the next 3 primes are [5, 7, 11]
//How many more names would you like? (enter q to quit)
//3
//the next 3 names are [Sara, Yves, Alexander]
//How many more primes would you like? (enter q to quit)
//q

/////////////////////////////////////////////////////////////////////////////////////
/// touchless client list puller

//the below 2 functions represent a model of what is created when using RunTargetInfo classes i.e.
//explicit input and output policies. These are not directly accessed by the touchless client list
//puller but more serve as a source of documentation

allPrimesAdjunct :: Prelude.JObject;
allPrimesAdjunct = (\x -> Prelude.output ((Prelude.unsafeCoerce x) ::  Prelude.CalValue)) M1.allPrimes;

takeNIntAdjunct :: Prelude.JObject -> Prelude.JObject -> Prelude.JObject;
takeNIntAdjunct list nToTake =
    (\x -> Prelude.output ((Prelude.unsafeCoerce x) :: ([Int], CalValue)))
        (takeN 
            ((\x -> (Prelude.unsafeCoerce ((Prelude.input x) :: Prelude.CalValue)) :: [Prelude.Int]) list)
            ((Prelude.input :: Prelude.JObject -> Prelude.Int) nToTake)
         );

/////////////////////////////////////////////////////////////////////////////////////
// Derived-instances special-case testing

// Test derived instances for foreign types that do not represent Java primitives 
data foreign unsafe import jvm private "java.lang.String" 
    private ForeignString deriving Inputable, Outputable, Eq, Ord, Debug.Show; 

foreign unsafe import jvm "constructor"
    private new_ForeignString :: String -> ForeignString;

testDerivedForeignInstances =
    let
        a = new_ForeignString "aaaa";
        b = new_ForeignString "bbbb";
    in
        a == a &&
        a != b &&
        
        a < b &&
        b > a &&
        a <= a &&
        a <= b &&
        b >= b &&
        b >= a &&
        compare a b == LT &&
        compare b a == GT &&
        compare a a == EQ &&
        max a b == b && 
        min a b == a &&
        
        not (a == b) &&
        not (a != a) &&
        
        not (b < a) &&
        not (a > b) &&
        not (b <= a) &&
        not (a >= b) &&
        
        Debug.show a == "aaaa" &&
        Debug.show b == "bbbb" &&
        
        (input (output a)) == a

        || error "M2.testDerivedForeignInstances failed!";

// Test derived instances for foreign types that represent Java primitives
data foreign unsafe import jvm private "int"
    private ForeignInt deriving Inputable, Outputable, Eq, Debug.Show, Ord;

makeForeignInt :: Int -> ForeignInt;
makeForeignInt !x = unsafeCoerce x;

data foreign unsafe import jvm private "byte"
    private ForeignByte deriving Inputable, Outputable, Eq, Debug.Show, Ord;

makeForeignByte :: Byte -> ForeignByte;
makeForeignByte !x = unsafeCoerce x;

data foreign unsafe import jvm private "short"
    private ForeignShort deriving Inputable, Outputable, Eq, Debug.Show, Ord;

makeForeignShort :: Short -> ForeignShort;
makeForeignShort !x = unsafeCoerce x;

data foreign unsafe import jvm private "long"
    private ForeignLong deriving Inputable, Outputable, Eq, Debug.Show, Ord;

makeForeignLong :: Long -> ForeignLong;
makeForeignLong !x = unsafeCoerce x;

data foreign unsafe import jvm private "float"
    private ForeignFloat deriving Inputable, Outputable, Eq, Debug.Show, Ord;

makeForeignFloat :: Float -> ForeignFloat;
makeForeignFloat !x = unsafeCoerce x;

data foreign unsafe import jvm private "double"
    private ForeignDouble deriving Inputable, Outputable, Eq, Debug.Show, Ord;

makeForeignDouble :: Double -> ForeignDouble;
makeForeignDouble !x = unsafeCoerce x;

data foreign unsafe import jvm private "boolean"
    private ForeignBoolean deriving Inputable, Outputable, Eq, Debug.Show, Ord;

makeForeignBoolean :: Boolean -> ForeignBoolean;
makeForeignBoolean !x = unsafeCoerce x;

data foreign unsafe import jvm private "char"
    private ForeignChar deriving Inputable, Outputable, Eq, Debug.Show, Ord;

makeForeignChar :: Char -> ForeignChar;
makeForeignChar !x = unsafeCoerce x;

testDerivedForeignPrimitiveInstances =
    
    // Prelude.Eq
    assert (makeForeignBoolean True == makeForeignBoolean True) &&
    assert (makeForeignChar 'c' == makeForeignChar 'c') &&
    assert (makeForeignByte 10 == makeForeignByte 10) &&
    assert (makeForeignShort 10 == makeForeignShort 10) &&
    assert (makeForeignInt 10 == makeForeignInt 10) &&
    assert (makeForeignLong 10 == makeForeignLong 10) &&
    assert (makeForeignFloat 10 == makeForeignFloat 10) &&
    assert (makeForeignDouble 10.0 == makeForeignDouble 10.0) &&

    assert (makeForeignBoolean False != makeForeignBoolean True) &&
    assert (makeForeignChar 'b' != makeForeignChar 'c') &&
    assert (makeForeignByte 9 != makeForeignByte 10) &&
    assert (makeForeignShort 9 != makeForeignShort 10) &&
    assert (makeForeignInt 9 != makeForeignInt 10) &&
    assert (makeForeignLong 9 != makeForeignLong 10) &&
    assert (makeForeignFloat 9 != makeForeignFloat 10) &&
    assert (makeForeignDouble 9.0 != makeForeignDouble 10.0) &&
    
    // Prelude.Ord
    assert (makeForeignBoolean False < makeForeignBoolean True) &&
    assert (makeForeignChar 'b' < makeForeignChar 'c') &&
    assert (makeForeignByte 9 < makeForeignByte 10) &&
    assert (makeForeignShort 9 < makeForeignShort 10) &&
    assert (makeForeignInt 9 < makeForeignInt 10) &&
    assert (makeForeignLong 9 < makeForeignLong 10) &&
    assert (makeForeignFloat 9 < makeForeignFloat 10) &&
    assert (makeForeignDouble 9.0 < makeForeignDouble 10.0) &&

    assert (makeForeignBoolean False <= makeForeignBoolean True) &&
    assert (makeForeignChar 'b' <= makeForeignChar 'c') &&
    assert (makeForeignByte 9 <= makeForeignByte 10) &&
    assert (makeForeignShort 9 <= makeForeignShort 10) &&
    assert (makeForeignInt 9 <= makeForeignInt 10) &&
    assert (makeForeignLong 9 <= makeForeignLong 10) &&
    assert (makeForeignFloat 9 <= makeForeignFloat 10) &&
    assert (makeForeignDouble 9.0 <= makeForeignDouble 10.0) &&

    assert (makeForeignBoolean True >= makeForeignBoolean False) &&
    assert (makeForeignChar 'd' >= makeForeignChar 'c') &&
    assert (makeForeignByte 11 >= makeForeignByte 10) &&
    assert (makeForeignShort 11 >= makeForeignShort 10) &&
    assert (makeForeignInt 11 >= makeForeignInt 10) &&
    assert (makeForeignLong 11 >= makeForeignLong 10) &&
    assert (makeForeignFloat 11 >= makeForeignFloat 10) &&
    assert (makeForeignDouble 11.0 >= makeForeignDouble 10.0) &&

    assert (makeForeignBoolean True > makeForeignBoolean False) &&
    assert (makeForeignChar 'd' > makeForeignChar 'c') &&
    assert (makeForeignByte 11 > makeForeignByte 10) &&
    assert (makeForeignShort 11 > makeForeignShort 10) &&
    assert (makeForeignInt 11 > makeForeignInt 10) &&
    assert (makeForeignLong 11 > makeForeignLong 10) &&
    assert (makeForeignFloat 11 > makeForeignFloat 10) &&
    assert (makeForeignDouble 11.0 > makeForeignDouble 10.0) &&

    assert (compare (makeForeignBoolean True) (makeForeignBoolean False) == GT) &&
    assert (compare (makeForeignChar 'd') (makeForeignChar 'c') == GT) &&
    assert (compare (makeForeignByte 11) (makeForeignByte 10) == GT) &&
    assert (compare (makeForeignShort 11) (makeForeignShort 10) == GT) &&
    assert (compare (makeForeignInt 11) (makeForeignInt 10) == GT) &&
    assert (compare (makeForeignLong 11) (makeForeignLong 10) == GT) &&
    assert (compare (makeForeignFloat 11) (makeForeignFloat 10) == GT) &&
    assert (compare (makeForeignDouble 11.0) (makeForeignDouble 10.0) == GT) &&
    
    assert (min (makeForeignBoolean True) (makeForeignBoolean False) == (makeForeignBoolean False)) &&
    assert (min (makeForeignChar 'd') (makeForeignChar 'c') == (makeForeignChar 'c')) &&
    assert (min (makeForeignByte 11) (makeForeignByte 10) == (makeForeignByte 10)) &&
    assert (min (makeForeignShort 11) (makeForeignShort 10) == (makeForeignShort 10)) &&
    assert (min (makeForeignInt 11) (makeForeignInt 10) == (makeForeignInt 10)) &&
    assert (min (makeForeignLong 11) (makeForeignLong 10) == (makeForeignLong 10)) &&
    assert (min (makeForeignFloat 11) (makeForeignFloat 10) == (makeForeignFloat 10)) &&
    assert (min (makeForeignDouble 11.0) (makeForeignDouble 10.0) == (makeForeignDouble 10.0)) &&
    
    assert (max (makeForeignBoolean True) (makeForeignBoolean False) == (makeForeignBoolean True)) &&
    assert (max (makeForeignChar 'd') (makeForeignChar 'c') == (makeForeignChar 'd')) &&
    assert (max (makeForeignByte 11) (makeForeignByte 10) == (makeForeignByte 11)) &&
    assert (max (makeForeignShort 11) (makeForeignShort 10) == (makeForeignShort 11)) &&
    assert (max (makeForeignInt 11) (makeForeignInt 10) == (makeForeignInt 11)) &&
    assert (max (makeForeignLong 11) (makeForeignLong 10) == (makeForeignLong 11)) &&
    assert (max (makeForeignFloat 11) (makeForeignFloat 10) == (makeForeignFloat 11)) &&
    assert (max (makeForeignDouble 11.0) (makeForeignDouble 10.0) == (makeForeignDouble 11.0)) &&
    
    // Debug.Show
    assert (Debug.show (makeForeignBoolean True) == "true") &&
    assert (Debug.show (makeForeignChar 'c') == "c") &&
    assert (Debug.show (makeForeignByte 12) == "12") &&
    assert (Debug.show (makeForeignShort 12) == "12") &&
    assert (Debug.show (makeForeignInt 12) == "12") &&
    assert (Debug.show (makeForeignLong 12) == "12") &&
    assert (Debug.show (makeForeignFloat 12) == "12.0") &&
    assert (Debug.show (makeForeignDouble 12) == "12.0")
    
    || error "M2.testDerivedForeignPrimitiveInstances failed";


/////////////////////////////////////////////////////////////////////////////////////
// trctester excercises a path in the runtime which results in a null pointer exception
// encountered when a recursive evaluation involving a tail recursive function occurs.
trctester = trc trctester;

trc :: [Prelude.Double] -> [Prelude.Double];
trc list = 
   case list of 
      x : xs -> trc xs;
      [] -> [0.0];
      ; 

//////////////////////////////////////////////////////////////////////////////////////////
// Test compilation of in-lined let variables containing tail recursive calls.
// This excercises a compiler path that had a bug which was fixed on July 29th, 2005
testTailRecursiveVarInlining :: Prelude.Boolean -> Prelude.Boolean -> Prelude.Double -> Prelude.Double -> Prelude.Double;
testTailRecursiveVarInlining a b c d =
    let
        v1 = testTailRecursiveVarInlining Prelude.False Prelude.False 2.0 3.0;
        v2 = if (a) then (testTailRecursiveVarInlining Prelude.False Prelude.False 2.0 4.0) else 2.0;
    in
        if (a) then v1 else (if b then v2 else 1.0);

// Test derived Enum instances for enumeration types that do not have 
// instances for any other type class (especially Ord).

data private EnumButNotOrd =
    EBNO1 |
    EBNO2 |
    EBNO3 |
    EBNO4 |
    EBNO5
    deriving Enum;

private equalsEBNO !x !y =
    case x of
    EBNO1 -> 
        case y of 
        EBNO1 -> True; 
        _ -> False;
        ;
    EBNO2 -> 
        case y of 
        EBNO2 -> True; 
        _ -> False;
        ;
    EBNO3 -> 
        case y of 
        EBNO3 -> True; 
        _ -> False;
        ;
    EBNO4 -> 
        case y of 
        EBNO4 -> True; 
        _ -> False;
        ;
    EBNO5 -> 
        case y of 
        EBNO5 -> True; 
        _ -> False;
        ;
    ;

equalsEBNOList !x !y =
    case x of
    [] ->
        case y of
        [] -> True;
        _ -> False;
        ;
    firstX : restX ->
        case y of
        [] -> False;
        firstY : restY ->
            if equalsEBNO firstX firstY then
                equalsEBNOList restX restY
            else
                False;
       ;
    ;
    
testDerivedEnumIndependence =
    Prelude.upFrom EBNO3 `equalsEBNOList` [EBNO3, EBNO4, EBNO5] &&
    Prelude.upFromTo EBNO1 EBNO2 `equalsEBNOList` [EBNO1, EBNO2] &&
    Prelude.upFromThen EBNO1 EBNO3 `equalsEBNOList` [EBNO1, EBNO3, EBNO5] &&
    take 3 (Prelude.upFromThenTo EBNO2 EBNO2 EBNO3) `equalsEBNOList` [EBNO2, EBNO2, EBNO2] &&
    Prelude.upFromThenTo EBNO1 EBNO2 EBNO4 `equalsEBNOList` [EBNO1, EBNO2, EBNO3, EBNO4]
    || error "M2.testDerivedEnumIndependence failed";

// Test code to make sure that lifted lazy expressions correctly initialise supercombinator instances where
// the supercombinator initialisation depends on accessing the execution context.    
testLiftedExpressionsHelper x y = if x then y else y;
testLiftedExpressions x = Prelude.seq (testLiftedExpressionsHelper Prelude.True (if x then (Prelude.output {x = 1.0}) else (Prelude.output {y = 2.0}))) True;

data private Numeric =
    NumericOne |
    NumericTwo |
    NumericThree |
    NumericFour 
    deriving Prelude.Enum, Prelude.IntEnum, Prelude.Outputable, Prelude.Eq
    ;

testDerivedIntEnumInstances =
    assert (Prelude.enumToInt NumericOne == 0) &&
    assert (Prelude.enumToInt NumericTwo == 1) &&
    assert (Prelude.enumToInt NumericThree == 2) &&
    assert (Prelude.enumToInt NumericFour == 3) &&
    
    assert (Prelude.intToEnum 0 == NumericOne) &&
    assert (Prelude.intToEnum 1 == NumericTwo) &&
    assert (Prelude.intToEnum 2 == NumericThree) &&
    assert (Prelude.intToEnum 3 == NumericFour) &&
    
    assert (Prelude.intToEnumChecked (-2) == (Nothing :: Maybe Numeric)) &&
    assert (Prelude.intToEnumChecked 2 == Just NumericThree) &&
    assert (Prelude.intToEnumChecked 50 == (Nothing :: Maybe Numeric))
    ;

////////////////////////////////////////////////////////////////////
// Code to test a compilation bug involving closely connected funtions
// where one function is an alias of another.
private mutualA =
    let
        /**
         * @arg x
         * @arg y
         */
        b = mutualB;
    in
        b;

private mutualB x =
    let
        /**
         * @arg x
         * @arg y
         */
        a = mutualA;
    in
        (\q -> Prelude.id (\y -> a q y)) x;
//////////////////////////////////////////////////    


// Tests for marshalling a foreign type which is the java.lang class corresponding to a java primitive.
data foreign unsafe import jvm "java.lang.Boolean" JBoolean;
foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.M2.BoolTest.nullBoolean" private nullJBoolean :: JBoolean;
foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.M2.BoolTest.trueBoolean" private trueJBoolean :: JBoolean;
foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.M2.BoolTest.falseBoolean" private falseJBoolean :: JBoolean;
foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.M2.BoolTest.typeOfBoolean" private typeOfJBoolean :: JBoolean -> String;

testMarshallingJBoolean = 
    (((typeOfJBoolean nullJBoolean) == "null") &&
    ((typeOfJBoolean trueJBoolean) == "true") &&
    ((typeOfJBoolean falseJBoolean) == "false")) || (Prelude.error "bad marshalling");


///////////////////////////////////////////////////////////

//the assertion fails on the third example. Note that the line and column information is on the third assert.
//we are using this as our new pattern for examples.
//Error while executing: M2.lengthExamples: line 6792, column 8: Assert failed.
//Also works with error and undefined.
lengthExamples =
    assert (length [] == 0)
    && assert (length [1, 2, 10.0] == 3)
    && assert (length [True, False] == 1)
    && assert (length [[[]]] == 1)
    ;

//Get an unhandled case error. It gives the precise case that was not handled.
//Error while executing: M2.caseExample: line 6802, column 9: Unhandled case value of Prelude.Just.
caseExample =
    case (Just (Just 'a')) of
    Just x -> 
        case x of
        Nothing -> "Zaphod";
        ;
    ; 

seqExample1 =
    seq (trace "should trace" 1.0 + 2.0) True;

seqExample2 =
    seq [trace "should not trace" 1.0 + 2.0] True;

seqExample3 =
    let
        x = {name = trace "a" "Kermit", ageOfFriends = [trace "b" 10.0, trace "c" 5.0], frog = trace "d" True, zFactor = 23.0};
    in
        seq x x.zFactor;

deepSeqExample1 =
    deepSeq [trace "should trace" 1.0 + 2.0] True;

//traces bcda
deepSeqExample2 =
    let
        x = {name = trace "a" "Kermit", ageOfFriends = [trace "b" 10.0, trace "c" 5.0], frog = trace "d" True, zFactor = 23.0};
    in
        deepSeq x x.zFactor;


//////////////////////////////////////////////////////////////////////////

/**
 * Traverses a value and gathers leaf values of type Double within the value into a list.
 * The value is assumed to be built out of list and records (to arbitrary levels of nesting and recursion), with various terminal
 * types. The leaf values that are of type Double are gathered.
 */
gatherDoubleValues :: Typeable a => a -> [Double];
gatherDoubleValues value = gatherDoubleValues2 (toDynamic value);


//implementation note: for efficiency it would be better to implement via a helper which threads through
//an accumulating parameter to gathers a [[Double]] and concat it only at the end.
//however, we don't do this yet...
gatherDoubleValues2 :: Dynamic -> [Double];
gatherDoubleValues2 value =
    let
        typeOfValue = dynamicUnderlyingType value;        
    in
        if isDoubleType typeOfValue then
            [fromJust (fromDynamic value)]
             
        else if isListType typeOfValue then
            concatMap gatherDoubleValues2 (fromJust (fromDynamicList value))
             
        else if isRecordType typeOfValue then
            concatMap gatherDoubleValues2 (fromJust (dynamicRecordFieldValues value))
    
        else
            [];
    
gatherDoubleValuesExamples =
    assert (gatherDoubleValues (1 + 2.0) == [3])
    && assert (gatherDoubleValues [10, 20, 4.0] == [10, 20, 4.0])                                         
    && assert (
        gatherDoubleValues
            [{name = "Anton", age = 1.9, favoriteNumbers = [1.0, 2.0, 3.0], isCanadian = True},
             {name = "Archimedes", age = 2500, favoriteNumbers = [Math.pi, 0, -1], isCanadian = False}]
         == [1.9, 1.0, 2.0, 3.0, 2500, Math.pi, 0, -1])
    && assert (
        gatherDoubleValues
            {address = {street = "Heather", number = 7880.0, age = 79.0}, friendlyList = [2.0, 10.0]}
        == [79, 7880, 2, 10])
    //note that Double values wrapped in things other than (recursive constructions of) lists and records are not gathered.        
    && assert (gatherDoubleValues (Just 2.0) == [])
    ;
                        

/**
 * Traverses a value and gathers leaf values of a specified type within the value into a list.
 * The value is assumed to be built out of list and records (to arbitrary levels of nesting and recursion), with various terminal
 * types. The leaf values that are of the type specified by the type variable "b" in the declaration below are gathered.
 */
gatherLeafValues :: (Typeable a, Typeable b) => a -> [b];
gatherLeafValues value = gatherLeafValues2 (toDynamic value);

gatherLeafValues2 :: (Typeable a) => Dynamic -> [a];
gatherLeafValues2 value =
    let
        typeOfValue = dynamicUnderlyingType value;

        elementType :: [a] -> a;
        elementType = undefined;
        //resultElementType has type (Typeable a) => a, where a is the a in the type declaration
        //it results in an error if reduced, due to the use of undefined. This is because it should
        //never be reduced- its only purpose is to get a TypeRep.
        resultElementType = elementType (gatherLeafValues2 value);
    in
        if typeOfValue == typeOf resultElementType then
            [fromJust (fromDynamic value)]
             
        else if isListType typeOfValue then
            concatMap gatherLeafValues2 (fromJust (fromDynamicList value))
             
        else if isRecordType typeOfValue then
            concatMap gatherLeafValues2 (fromJust (dynamicRecordFieldValues value))
    
        else
            [];

gatherLeafValuesExamples =
    assert (gatherLeafValues (1 + 2.0) == [3.0])
    && assert (gatherLeafValues [10, 20, 4.0] == [10, 20, 4.0])                                         
    && assert (
        gatherLeafValues
            [{name = "Anton", age = 1.9, favoriteNumbers = [1.0, 2.0, 3.0], isCanadian = True},
             {name = "Archimedes", age = 2500, favoriteNumbers = [Math.pi, 0, -1], isCanadian = False}]
         == [1.9, 1.0, 2.0, 3.0, 2500, Math.pi, 0, -1])
    && assert (
        gatherLeafValues
            {address = {street = "Heather", number = 7880.0, age = 79.0}, friendlyList = [2.0, 10.0]}
        == [79.0, 7880, 2, 10])        
    && assert (gatherLeafValues (Just 2.0) == ([] :: [Double])) 
    && assert (gatherLeafValues (Just 2.0) == [Just 2.0]) 
    
    //note that for the following examples, the left hand side of the example are all identical.
    //However, the left hand side is a polymorphic value of type Typeable b => [b], so what "b" is is resolved by
    //the type of the right hand side.
    && assert (gatherLeafValues [("apple", 5), ("orange", 4), ("pear", 2.0)] == ["apple", "orange", "pear"])
    && assert (gatherLeafValues [("apple", 5), ("orange", 4), ("pear", 2.0)] == [5.0, 4, 2.0])
    //leaf values can be compound types as in this example which is extracting (String, Double).
    && assert (gatherLeafValues [("apple", 5), ("orange", 4), ("pear", 2.0)] == [("apple", 5), ("orange", 4), ("pear", 2.0)])
    && assert (gatherLeafValues [("apple", 5), ("orange", 4), ("pear", 2.0)] == ([] :: [Boolean]))        
    ;

/////////////////////////////////////////////////////////////////////////////////
// Some code for testing grouped case alternates
data GroupDataType = 
    GroupDataType1 field1 :: !Int    field2 :: String field3 :: Double |
    GroupDataType2 field1 :: !Double field2 :: Int    field3 :: String |
    GroupDataType3 field1 :: !String field2 :: Double field3 :: Int |
    GroupDataType4 field2 :: !String field3 :: !Double field1 :: Int |
    GroupDataType5 field2 :: Int field3 :: String field1 :: Double |
    GroupDataType6 field1 :: Int  field3 :: String  field2 :: Double |
    GroupDataType7 field1 :: !Int  field3 :: String  field2 :: Double;
    
     
testGroupDataType x =
    case x of
    (GroupDataType1 | GroupDataType4) {field1} -> field1 + 2;
    _ -> 0;
    ; 

testGroupDataType_2 x =
    case x of
    (GroupDataType1 | GroupDataType5) field1 _ _ -> field1 + 2;
    _ -> 0; 
    ;

testGroupDataType_3 x =
    case x of
    (GroupDataType1 | GroupDataType6) field1 _ _ -> field1 + 2;
    _ -> 0; 
    ;
    
testGroupDataType_4 x =
    case x of
    (GroupDataType1 | GroupDataType6) field1 field2 _ -> Prelude.seq field2 (field1 + 2);
    _ -> 0; 
    ;

testGroupDataType_5 x =
    case x of
    (GroupDataType1 | GroupDataType7) field1 _ _ -> field1 + 2;
    _ -> 0; 
    ;

exerciseGroupDataType = 
    assert ((testGroupDataType (GroupDataType1 1 "a" 1.0)) == 3)
    && assert ((testGroupDataType_2 (GroupDataType1 1 "a" 1.0)) == 3)
    && assert ((testGroupDataType_3 (GroupDataType6 1 "a" 1.0)) == 3)
    && assert ((testGroupDataType_4 (GroupDataType6 1 "a" 1.0)) == 3)
    && assert ((testGroupDataType_5 (GroupDataType7 1 "a" 1.0)) == 3);
    
data GroupDataType2 = 
    GroupDataType2_1 field1 :: !Int  field2 :: String   field3 :: Double |
    GroupDataType2_2 field1 :: !Int  field2 :: !String  field3 :: String;
        
        
testGroupDataType2 :: GroupDataType2 -> Int;
testGroupDataType2 x = 
    case x of 
    (GroupDataType2_1 | GroupDataType2_2) {field1} -> testGroupDataType2Helper field1 field1;
    ;   
testGroupDataType2Helper :: Int -> Int -> Int;
testGroupDataType2Helper !x y = x + y + 2;   

groupDataTest = 
    assert (testGroupDataType (GroupDataType4 "a" 1.0 2) == 4) &&
    assert (testGroupDataType_2 (GroupDataType5 1 "a" 1.0) == 3) &&
    assert (testGroupDataType2 (GroupDataType2_1 7 "a" 1.0) == 16);



cafOne = 1.0;

addOne x y = x + 1.0;
addOneCAF x y = x + cafOne;


caftest1 x = List.foldLeftStrict addOne 0.0 (take x (repeat 1.0));
caftest2 x = List.foldLeftStrict addOneCAF 0.0 (take x (repeat 1.0));

caftest3 x = List.last (List.take x (Prelude.upFrom 1.0));
  
caftest4 :: Int -> [Int];
caftest4 !x = if (x == 0) then [] else (Prelude.deepSeq (List.take 20 (Prelude.upFrom (1::Int))) (caftest4 (x - 1)));


caftest5 :: Int -> [Int];
caftest5 !x = if (x == 0) then [] else (Prelude.deepSeq (List.take 10 (Prelude.upFrom (1::Int))) (caftest5 (x - 1)));

testMissingCases :: GroupDataType -> String;
testMissingCases x =
    case x of  
    GroupDataType3 {} -> "blah";
    ;

strictOutput :: CalValue -> JObject;
strictOutput !element = output element;
 
testInternalValue :: Prelude.Boolean;
testInternalValue =
    assert ((1.0 + (unsafeCoerce ((input (strictOutput (unsafeCoerce 1.0))) :: CalValue))) == 2.0) && 
    assert ((1.0 + (unsafeCoerce ((input (output ((unsafeCoerce 1.0) :: CalValue))) :: CalValue))) == 2.0);


/////////////////////////////////////////////////////////////////////////////////
// Some performance tests on arrays versus lists

/**
 * Sums the int list [1..100] n times. So the result is 5050*n.
 */
sumList :: Int -> Int;
sumList n =
    let
        list :: [Int];
        list = upFromTo 1 100;
        
        sumListHelper :: Int -> Int -> Int;
        sumListHelper !index !partialSum =
            if (index <= 0) then
                partialSum                
            else
                sumListHelper (index - 1) (partialSum + List.sum list);
    in
        sumListHelper n 0;

/**
 * Sums the int array [1..100] n times. So the result is 5050*n.
 */    
sumArray :: Int -> Int;
sumArray n =
    let
        array :: Array Int;
        array = Array.fromList (upFromTo 1 100);
        
        sumArrayHelper :: Int -> Int -> Int;
        sumArrayHelper !index !partialSum =
            if (index <= 0) then
                partialSum
            else
                sumArrayHelper (index - 1) (partialSum + Array.sum array);
    in
        sumArrayHelper n 0;  
    
/**
 * Like sumArray, but converts the array to a list and uses list's sum
 * each time the array is summed. This simulates using list's functions
 * for arrays.
 */    
sumArray_v2 :: Int -> Int;
sumArray_v2 n =
    let
        array :: Array Int;
        array = Array.fromList (upFromTo 1 100);
        
        arraySum :: Array Int -> Int;
        arraySum !array = List.sum (Array.toList array);
        
        sumArrayHelper :: Int -> Int -> Int;
        sumArrayHelper !index !partialSum =
            if (index <= 0) then
                partialSum
            else
                sumArrayHelper (index - 1) (partialSum + arraySum array);
    in
        sumArrayHelper n 0;      
        
/*
Oct 7, 2005
sumList is faster than sumArray...
 
running: sumList 100000
Run Time:        6,500 ms

running: sumArray 100000
Run Time:        8,640 ms

Oct 12, 2005
sumArray is alot faster than sumArray_v2.
Conclusion: it is better to use array specific versions of functions that convert to
a list whenever possible...

running: sumArray 100000
Run Time:        7,562 ms

running: sumArray_v2 100000
Run Time:        12,547 ms
*/
    
    
/**
 * Computes andList n times on a list of 100 True's.
 */
andListBenchmark :: Int -> Boolean;
andListBenchmark n =
    let
        list :: [Boolean];
        list = List.replicate 100 True;
        
        helper :: Int -> Boolean;
        helper !index =
            if (index <= 0) then
                True                
            else if List.andList list then
                helper (index - 1)
            else
                error "unexpected branch";
    in
        helper n;
    
/**
 * Computes andArray n times on an array of 100 True's.
 */
andArrayBenchmark :: Int -> Boolean;
andArrayBenchmark n =
    let
        array :: Array Boolean;
        array = Array.replicate 100 True;        
        
        helper :: Int -> Boolean;
        helper !index =
            if (index <= 0) then
                True                
            else if Array.andArray array then
                helper (index - 1)
            else
                error "unexpected branch";               
    in
        helper n;    

/*    
Oct 7, 2005
andArray is highly tuned, unlike sum, so we're seeing much better performance.
running: andListBenchmark 500000
Run Time:        4,578 ms

running: andArrayBenchmark 500000
Run Time:        219 ms   
*/ 

/*
 * does a map over a list of 100 elements n times.
 * The result should be 100*(n+1)*n/2
 */ 
mapListBenchmark :: Int -> Int;    
mapListBenchmark n =
    let
        list :: [Int];
        list = replicate 100 0;
        
        helper :: Int -> [Int] -> [Int];
        helper !index !currentList =
            if (index <= n) then
                //mapListBenchmark 10000 will cause stack overflow without the deepStrict
                helper (index + 1) (Prelude.deepStrict (map (Prelude.add index)) currentList)                       
            else
                currentList;
    in
        List.sum (helper 1 list);    

/*
 * does a map over a list of 100 elements n times.
 * The result should be 100*(n+1)*n/2
 */    
mapArrayBenchmark :: Int -> Int;     
mapArrayBenchmark n =
    let
        array :: Array Int;
        array = Array.replicate 100 0;
        
        helper :: Int -> Array Int -> Array Int;
        helper !index !currentArray =
            if (index <= n) then
                helper (index + 1) (Array.map (Prelude.add index) currentArray)                     
            else
                currentArray;
    in
        Array.sum (helper 1 array);   
    
/* 
running: mapListBenchmark 10000
Run Time:        1,844 ms

running: mapArrayBenchmark 10000
Run Time:        922 ms
*/
    
//the generated Java source should be directly calling a foreign function for string equality testing   
testForeignResolution = show (Prelude.stringToDouble "9.0") == "9.0";

// Test the laziness of equalsString and use of null string value.    
foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.M2.NullProvider.nullString" private nullString :: Prelude.String;

nullStringTesterHelper2 :: Boolean -> Boolean -> Boolean;
nullStringTesterHelper2 b o = if b then b else (Prelude.seq o b);

nullStringTesterHelper1 :: String -> String -> Boolean;
nullStringTesterHelper1 !s1 !s2 = nullStringTesterHelper2 Prelude.True (s1 == s2);

nullStringTester = nullStringTesterHelper1 nullString "ab";

// This is a function where the definition of the let variable should be optimized
// and compiled strictly, rather than lifted.  The strict optimization should
// kick in because the expression consists soley of primitive ops which can be optimized
// and variables known to be evaluated.
rlift :: Int -> Int -> Int;
rlift !x !y = 
   let
      z = (x + y) / 2;
   in
       if (x > y) then z else z;
       
data CommonFields = 
    CommonFields1  
        f1 :: Int 
        f2 :: Double
        f3 :: Int |
    CommonFields2
        f2 :: !Double
        f3 :: !Int
        f1 :: !Int |
    CommonFields3
       f3 :: Int
       f1 :: !Int
       f2 :: !Double;

// f1 is not strict in both DCs so the generated java source
// will retrieve the field f1 as a boxed RTValue and the
// definition of z will be a lazy application of addInt
// i.e.
// RTValue commonFieldsTest1$f1$2 = $case1.get_f1();
// RTValue letVar_commonFieldsTest1$z$3 = new RTApp2L(i_Add_Int_0, commonFieldsTest1$f1$2, $L1_Int_2);
commonFieldsTest1 x =
   case x of
       (CommonFields1 | CommonFields2) {f1} ->
          let z = f1 + 2;
          in z + z;
          ;

// f1 is strict in both DCs so the generated java source
// will retrieve the field f1 as a unboxed int and the
// definition of z will be direct evaluation of java '+'
// since addInt is optimized in a lazy context of all
// arguments are known to be evaluated.
// i.e.
// int commonFieldsTest2$f1$2$u = $case1.get_f1_As_Int($ec);
// int letVar_commonFieldsTest2$z$3$u = commonFieldsTest2$f1$2$u + 2;
commonFieldsTest2 x =
   case x of
       (CommonFields3 | CommonFields2) {f1} ->
          let z = f1 + 2;
          in z + z;
          ;
          

// Tests of retrieving unboxed values with single field selection.
data SimpleEnum = SimpleEnum;
data PrimTypes =
   PTInt sf :: !Int lf ::Int |
   PTBoolean sf :: !Boolean lf :: Boolean |
   PTByte sf :: !Byte lf :: Byte |
   PTChar sf :: !Char lf :: Char |
   PTDouble sf :: !Double lf :: Double | 
   PTFloat sf :: !Float lf :: Float |
   PTLong sf :: !Long lf :: Long | 
   PTShort sf :: !Short lf :: Short |
   PTString sf :: !String lf :: String |
   PTForeign sf :: !MyStringBuilder lf :: MyStringBuilder |
   PTForeignPrim sf :: !MyInt lf :: MyInt |
   PTEnum sf :: !SimpleEnum lf :: SimpleEnum;
   
// The generated java source code for these functions
// should show the strict field (i.e. 'sf') being 
// retrieved as an unboxed value by a call to 
// 'getFieldByIndex_As_...'.   
dcfsTest1 !x = x.PTInt.sf == x.PTInt.lf;
dcfsTest2 !x = x.PTBoolean.sf == x.PTBoolean.lf;   
dcfsTest3 !x = x.PTByte.sf == x.PTByte.lf;   
dcfsTest4 !x = x.PTChar.sf == x.PTChar.lf;   
dcfsTest5 !x = x.PTDouble.sf == x.PTDouble.lf;   
dcfsTest6 !x = x.PTFloat.sf == x.PTFloat.lf;   
dcfsTest7 !x = x.PTLong.sf == x.PTLong.lf;   
dcfsTest8 !x = x.PTShort.sf == x.PTShort.lf;   
dcfsTest9 !x = x.PTString.sf == x.PTString.lf;   

// Test that the data cons field selection syntax is functioning properly.
dcfsTest = assert (dcfsTest1 (PTInt 1 1)) &&
           assert (dcfsTest2 (PTBoolean True True)) &&
           assert (dcfsTest3 (PTByte 1 1)) &&
           assert (dcfsTest4 (PTChar 'a' 'a')) &&
           assert (dcfsTest5 (PTDouble 1 1)) &&
           assert (dcfsTest6 (PTFloat 1 1)) &&
           assert (dcfsTest7 (PTLong 1 1)) &&
           assert (dcfsTest8 (PTShort 1 1)) &&
           assert (dcfsTest9 (PTString "a" "a"));

// These two functions make sure that mutually dependent functions
// which could be considered aliases of each other are not
// considered aliases.
// This should compile and we should generate source for both of these.
alias1 = alias2;
alias2 = alias1;

////////////////////////////////////////////////////////////////////////
//Question from Yannick

data Table =
    Table
        name::String
        columns :: [Column]
    deriving Debug.Show                    
    ;

data Column =
    Column
        name :: String
        owner :: Table    
    ;
    
instance Show Column where
    show = showColumn;
    ;
  
showColumn :: Column -> String;    
showColumn column =
    let
        owner = column.Column.owner;
        ownerName = owner.Table.name;
        ownerNColumns = List.length owner.Table.columns;
    in        
        Prelude.concat [
            "(Column: name = ",
            show column.Column.name,
            " owner = ",
            show ownerName,
            " nOwnerColums = ",
            show ownerNColumns,
            ")"
            ];
         
newTable :: String -> Table;
newTable tableName = Table tableName [];

updateColumnOwner :: Table -> Column -> Column;
updateColumnOwner table column =
   case column of
   Column {name} -> Column name table;
   ;   

addColumn :: Table -> String -> Table;
addColumn table columnName =
   case table of
   Table {name, columns} ->
       let
           newTable =
               Table
                   name 
                   ((Column columnName newTable) : (map (updateColumnOwner newTable) columns));
       in
           newTable;
   ;
       
table1 = newTable "Employees";

table2 = addColumn table1 "Name";

table3 = addColumn table2 "Salary";

table4 = addColumn table3 "HireDate";


////////////////////////////////////////////////////////////////////////
//begin - sorting benchmark
//Unless specifically mentioned below, all benchmarking in this section was done Feb 3, 2006.

/**
initial version from Yann Le Biannic's Wiki.
This is a classic version from various introductory papers on functional programming. 
However, it is not production quality. For example, the list is filtered twice per pivot 
selection whereas it really only needs to be done once.
It should also be mentioned that this quicksort is sorting a linked list (with O(n) element access)
and not an array (with constant time element access), unlike most of the versions for other languages.
*/
quicksort :: [Int] -> [Int];
quicksort source =
    let 
    
        partition_min pivot = filter (\x -> x < pivot); 
        partition_max pivot = filter (\x -> x >= pivot);
    in
    case source of
        [] -> [];
        pivot:tail -> quicksort (partition_min pivot tail)
                          ++ [pivot]
                          ++ quicksort (partition_max pivot tail);
        ;

/**
Version written by Rick to avoid filtering the list twice per pivot. It still works directly with the O(n) element
access list type. 
*/        
quicksort2 :: [Prelude.Int] -> [Prelude.Int];
quicksort2 !list =
    let
        partition :: Prelude.Int -> [Prelude.Int] -> [Prelude.Int] -> [Prelude.Int] -> ([Prelude.Int], [Prelude.Int]);
        partition !pivot !list left right =
            case list of
            [] -> (left, right);
            l : ls -> 
                if (l < pivot) then
                    partition pivot ls (l : left) right
                else
                    partition pivot ls left (l : right);
            ;
    
    in
        case list of
        [] -> [];
        l : ls -> 
            let
                lr = partition l ls [] [];
                left = Prelude.fst lr;
                right = Prelude.snd lr;
            in
                (quicksort2 left) ++ (l : (quicksort2 right));
        ;


/**
The [Int] is first converted to an Array Int,
this is then output to a JObject (which is actually an int array, by the definition of {@link Array.outputPrimitive@}),
which is then input to a JIntArray (this is a downcast),
this is then sorted by sorter,
the array is then upcasted to a JObject,
which is then input to an Array Int,
which is then converted to a [Int].
 */        
sortWithSpecifiedSorter :: [Prelude.Int] -> (JIntArray -> JIntArray) -> [Prelude.Int];  
sortWithSpecifiedSorter !list sorter =
    Array.toList #
    Array.inputPrimitive #
    Prelude.output #
    sorter #
    Prelude.input #    
    Array.outputPrimitive #   
    Array.fromList $
    list;    
        
/**
Marshals the [Int] to a Java primitive int array, does an in-place quicksort in a foreign function, then marshalls back.
*/
quicksort3 :: [Prelude.Int] -> [Prelude.Int];
quicksort3 !list = 
    sortWithSpecifiedSorter list intArray_javaQuicksort;   

foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.M2.TestSupport$FastQuicksort.sort" 
    intArray_javaQuicksort :: JIntArray -> JIntArray;           


/**
Marshals the [Int] to a Java primitive int array, does an in-place quicksort using a CAL function with side-effects,
then marshals back.
 */    
quicksort4 :: [Prelude.Int] -> [Prelude.Int];
quicksort4 !list = 
    sortWithSpecifiedSorter list quicksortIntArray_v1;  

/**
Marshals the [Int] to a Java primitive int array, does an in-place quicksort using a CAL function with side-effects,
then marshals back.
 */    
quicksort5 :: [Prelude.Int] -> [Prelude.Int];
quicksort5 !list = 
    sortWithSpecifiedSorter list quicksortIntArray_v2;

/**
Marshals the [Int] to a Java primitive int array, does an in-place quicksort using a CAL function with side-effects,
then marshals back.
 */    
quicksort6 :: [Prelude.Int] -> [Prelude.Int];
quicksort6 !list = 
    sortWithSpecifiedSorter list quicksortIntArray_v3;
 
    
data foreign unsafe import jvm "int[]" JIntArray deriving Inputable, Outputable;

foreign unsafe import jvm "newArray" 
    intArray_new :: Int -> JIntArray;
foreign unsafe import jvm "lengthArray" 
    intArray_length :: JIntArray -> Int;
foreign unsafe import jvm "subscriptArray" 
    intArray_subscript :: JIntArray -> Int -> Int;
foreign unsafe import jvm "updateArray" 
    intArray_update :: JIntArray -> Int -> Int -> Int; 
    
//intArray_swap could be implemented as a CAL algebraic function rather than a CAL foreign function but is done this way
//for the purpose of providing 2 differen CAL based JIntArray quicksorting functions, one of which uses this, and one which
//does not.
foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.M2.TestSupport$IntArray.swap" 
    intArray_swap :: JIntArray -> Int -> Int -> ();     

    
/**
Quicksort on primitive int arrays implemented fully in CAL without the use of unneccessary foreign functions.

Note: length, subscript and update for Java arrays correspond to Java language constructs rather than functions.
We need to wrap these with helper Java functions to access this functionality from CAL.
*/
quicksortIntArray_v1 :: JIntArray -> JIntArray;
quicksortIntArray_v1 !array =
    let
    
        swap :: Int -> Int -> ();
        swap !index1 !index2 =
            let
               swapHelper !temp =
                   intArray_update array index2 (intArray_subscript array index1)
                   `seq`
                   intArray_update array index1 temp
                   `seq`
                   ();
            in
               swapHelper (intArray_subscript array index2);              
                                  
        qsort :: Int -> Int -> JIntArray;
        qsort !begin !end =
            if begin < end then
                let                  
                    partition :: Int -> Int -> Int -> Int;
                    partition !i !index !pivot =
                        if i >= end then
                            swap index end
                            `seq`
                            index
                        else if intArray_subscript array i <= pivot then
                            swap i index
                            `seq`
                            partition (i + 1) (index + 1) pivot
                        else
                            partition (i + 1) index pivot;                
                                            
                    index = partition begin begin (intArray_subscript array end);
                in
                    qsort begin (index - 1)
                    `seq`
                    qsort (index + 1) end
            else
                array;
                    
    in
        qsort 0 (intArray_length array - 1);
    
/**
Like quicksortIntArray_v1 but uses a foreign function for swapping array elements. 
*/
quicksortIntArray_v2 :: JIntArray -> JIntArray;
quicksortIntArray_v2 !array =
    let                                             
        qsort :: Int -> Int -> JIntArray;
        qsort !begin !end =
            if begin < end then
                let                  
                    partition :: Int -> Int -> Int -> Int;
                    partition !i !index !pivot =
                        if i >= end then
                            intArray_swap array index end
                            `seq`
                            index
                        else if intArray_subscript array i <= pivot then
                            intArray_swap array i index
                            `seq`
                            partition (i + 1) (index + 1) pivot
                        else
                            partition (i + 1) index pivot;                
                                            
                    index = partition begin begin (intArray_subscript array end);
                in
                    qsort begin (index - 1)
                    `seq`
                    qsort (index + 1) end
            else
                array;
                    
    in
        qsort 0 (intArray_length array - 1); 
    
/**
Quicksort on primitive int arrays implemented fully in CAL without the use of unneccessary foreign functions.

Note: length, subscript and update for Java arrays correspond to Java language constructs rather than functions.
We need to wrap these with helper Java functions to access this functionality from CAL.

The difference with v1 is in the definition of the swap function to use an eager let variable instead of a local
swapHelper function, and the 

*/
quicksortIntArray_v3 :: JIntArray -> JIntArray;
quicksortIntArray_v3 !array =
    let    
        
        swap :: Int -> Int -> ();
        swap !index1 !index2 =
            let
                temp = eager (intArray_subscript array index2);
            in
                temp
                `seq`
                intArray_update array index2 (intArray_subscript array index1)
                `seq`
                intArray_update array index1 temp
                `seq`
                ();
            
                                  
        qsort :: Int -> Int -> JIntArray;
        qsort !begin !end =
            if begin < end then
                let                  
                    partition :: Int -> Int -> Int -> Int;
                    partition !i !index !pivot =
                        if i >= end then
                            swap index end
                            `seq`
                            index
                        else if intArray_subscript array i <= pivot then
                            swap i index
                            `seq`
                            partition (i + 1) (index + 1) pivot
                        else
                            partition (i + 1) index pivot;                
                                            
                    index = eager (partition begin begin (intArray_subscript array end));
                in
                    qsort begin (index - 1)
                    `seq`
                    qsort (index + 1) end
            else
                array;
                    
    in
        qsort 0 (intArray_length array - 1);    
     
/* 
Feb 3, 2006
  
Comparison of various Quicksorts for CAL lists. 
  
 
M2>:pt quicksort (take 500000 (randomInts 2006))
Summary:    time = 40,702
         
M2>:pt quicksort2 (take 500000 (randomInts 2006))
Summary:    time = 11,998

M2>:pt quicksort3 (take 500000 (randomInts 2006))
Summary:    time = 2,703

//This shows the contribution of marshaling to and from an int array, and the outputting the whole thing to a JObject by calling
//Prelude.output on the final [Int] (as per the behavior of ICE).
M2>:pt sortWithSpecifiedSorter (take 500000 (randomInts 2006)) id
Summary:    time = 2,439

M2>:pt quicksort4 (take 500000 (randomInts 2006))
Summary:    time = 4,203

M2>:pt quicksort5 (take 500000 (randomInts 2006))
Summary:    time = 2,952

*/
    
/*
March 23, 2006
Added quicksort6 benchmark and redid the quicksort4 benchmark:
    
running: quicksort4 (List.take 500000 (Random.randomInts 2006))
Summary:    time = 4,323
Summary:    time = 4,135

running: quicksort6 (List.take 500000 (Random.randomInts 2006))
Summary:    time = 3,166
Summary:    time = 3,109
*/

/*
March 23, 2006:
redid comparison with sorting only the JIntArray type
Note: I scaled the problem up from arrays of length 500,000 to 2,000,000 since the timings are a bit too quick at 500,000
to get really low variance between benchmark runs and sessions
 
I did 4 :pt runs in sequence i.e. b1, b2, b3, .., b1, b2, b2, ..., b1, b2, b3, ... , b1, b2, b3,...
Each sequence was in the same ICE session using Eclipse run mode, java 1.4, client jvm.
The last 2 runs were using the global program optimizer (optimization level 1).
This didn't make much of a difference for the quick sorting benchmarks (indeed it can't for the foreign intArray_javaQuicksort)
except in the case of one of the pure CAL ones, quicksortIntArray_v1, where it made a dramatic difference taking the time from
8.057 seconds to 2.813 seconds.
The global optimizer is still work in progress.

In the end, the best pure CAL solution is quicksortIntArray_v1 at opt level 1, and
the time ratio to Yann's pure Java version (intArray_javaQuicksort) is: 2.813 sec / 0.703 sec = 4.00

The best pure CAL solution at optimization level 0 is quicksortIntArray_v3 for a ratio of 3.827 / 0.703 = 5.44

In the April 2 benchmarks, the time ratio of the best pure CAL sort to the pure Java was:
1.749 seconds / 0.109 seconds = 16.0



//this is the time to create a random int array of length 2,000,000
M2>:pt randomIntArray 2000000
optimization level 0 i.e. least amount of optimization
Summary:    time = 5,828 
Summary:    time = 5,838 
optimization level 1 i.e. most amount of optimization
Summary:    time = 6,125 
Summary:    time = 6,093 

//list creation + sorting time in a foreign Java quicksort.
//So sorting time = 0.703 seconds (6.531 - 5.828)
M2>:pt intArray_javaQuicksort (randomIntArray 2000000)
optimization level 0
Summary:    time = 6,531 
Summary:    time = 6,536
optimization level 1
Summary:    time = 6,766
Summary:    time = 6,749

//list creation + sorting time in a pure CAL quicksort. Note that quicksortIntArray_v3 is also a pure CAL quicksort.
//So sorting time = 8.057 seconds (13.885 - 5.828) for optimization level 0
//Sorting time = 2.813 seconds (8.906 - 6.093) for optimization level 1!!!
M2>:pt quicksortIntArray_v1 (randomIntArray 2000000)
optimization level 0
Summary:    time = 13,885
Summary:    time = 13,952
optimization level 1
Summary:    time = 9,219
Summary:    time = 8,906

//list creation + sorting time in a pure CAL quicksort with a foreign array element swap helper. 
//So sorting time = 2.688 seconds (8.516 - 5.828)
M2>:pt quicksortIntArray_v2 (randomIntArray 2000000)
optimization level 0
Summary:    time = 8,516
Summary:    time = 8,489
optimization level 1
Summary:    time = 8,781
Summary:    time = 8,578

//list creation + sorting time in a pure CAL quicksort.
//So sorting time = 3.827 seconds (9.655 - 5.828)
M2>:pt quicksortIntArray_v3 (randomIntArray 2000000)
optimization level 0
Summary:    time = 9,655
Summary:    time = 9,630
optimization level 1
Summary:    time = 9,937
Summary:    time = 9,734
*/


randomIntArray :: Int -> JIntArray;
randomIntArray !size =  input # Array.outputPrimitive # Array.fromList $ take size (randomInts 2006);  

/*
 Feb 3, 2006
 
Comparison with sorting only the JIntArray type. 


//this is the time to create a random int array of length 500,000
M2>:pt randomIntArray 500000
Summary:    time = 1,359

//list creation + sorting time in a foreign Java quicksort.
//So sorting time = 0.109 seconds (1.468 - 1.359)
M2>:pt intArray_javaQuicksort (randomIntArray 500000)
Summary:    time = 1,468

//list creation + sorting time in a pure CAL quicksort.
//So sorting time = 1.749 seconds
M2>:pt quicksortIntArray_v1 (randomIntArray 500000)
Summary:    time = 3,108

//list creation + sorting time in a pure CAL quicksort with a foreign array element swap helper. 
//So sorting time = 0.515 seconds
M2>:pt quicksortIntArray_v2 (randomIntArray 500000)
Summary:    time = 1,874

*/


/*
Feb 3, 2006

Comparison with standard CAL sorts for the List type, as well as the Array type.
 
I sorted a list of 500,000 random ints in various ways. This was done using Java 1.4 client jvm on my machine running in Eclipse.

-the version based exactly on Yann Le Biannic's Wiki (quicksort) took 41.280 seconds. 
This compares with the result of 56.91 seconds in Yann's Wiki and is in the same ballbark- 
he's using a different machine, JVM, a different list of ints, etc, which would account for the difference.

-a version based on some simple changes to quicksort takes 40.702 seconds, a negligible improvement.

-a version based on List.sort, the standard CAL sort for Lists takes 27.008 seconds.

-a version based on List.sortExternal, the other standard CAL sort for Lists takes 8.826 seconds.

-a version based on Array.sort takes 1.656 seconds.

-constructing the random list of 500,000 ints (and outputting the results to a JObject, as per the ICE semantics)
 takes 1.047 seconds. Essentially this time overhead is built into all the above benchmark timings that I made.

Observations:
-the CAL sorts are mergesorts, which offer guaranteed n*log(n) performance rather than quicksort which can be n^2. 
In fact, when I first was benchmarking quicksort, I happened to stumble into one of the bad cases and got rather
 dismal results for quicksort, so I changed to using random lists. (Note that all the benchmarks below sort the
  exact same random list). However, mergesort is known to be slower in general than quicksort.
-Yann's implementations of quicksort in Java and C++ are making use of data structures with constant time element access 
i.e. arrays. CAL's List type is not like this, but CAL's Array type is. So in a sense, comparison with Array.sort is a more
 comparable situation between CAL and the other languages.
-List.sortExternal takes longer than Array.sort essentially because Array.sort can take advantage of the unboxed representation
 of Ints. It would be possible to write a specialized Int sort of Lists (e.g. List.sortInts, or something similar) with 
 performance comparable to Array.sort.
-the most comparable CAL time to Yann's benchmarks would be 1.656 - 1.047 = 0.609 seconds. This is quite comparable to his 
version for Java with generics (and CAL's Array.sort is similarly generic in nature, with type Ord a => Array a -> Array a)
 where the time Yann got was 0.562 seconds.

*/
    
testSortingBenchmarks =
    let
        list = (take 25 (randomInts 2006));
        sortedList = quicksort list;
    in
        assert (sortedList == quicksort2 list)
        && assert (sortedList == quicksort3 list)
        && assert (sortedList == quicksort4 list)
        && assert (sortedList == quicksort5 list)
        && assert (sortedList == quicksort6 list)
        ;

//end - sorting benchmark    
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
//begin - primes benchmark based on Sieve of Eratosthenes 
    
/*
Feb 3, 2006

On Yann Le Biannic's Wiki (as of Feb 3, 2006) there is a cross-language primes benchmark. 
Most versions on the Wiki (Java, C++ etc) use a primality test that makes use of previously 
discovered primes. The CAL version is just M2.getNthPrime, which does not use previously discovered primes, 
and hence is not implementing the same algorithm.

M2.getNthPrime was written many years ago and has been used by the CAL team as an internal benchmark tracking
the progress of the CAL runtime compared to earlier versions of itself. It has also been written in a particular
way i.e. it was originally written in the GemCutter. The goal below is to write a primality tester more
in the spirit of the Wiki primes benchmarks.

The results for 100,000 are:

//the quick Java version from Yann's wiki. This is exposed as a CAL foreign function below      
M2>:pt java_sieveBasedGetNthPrime 100000
Summary:    time = 328

//A close port of the Java implementation of java_sieveBasedGetNthPrime as an algebraic CAL function. 
M2>:pt sieveBasedGetNthPrime 100000
Summary:    time = 688
    
*/

/*
//the quick Java version from Yann's wiki. This is exposed as a CAL foreign function below      
    class QuickPrimeGenerator {
 
    static int generate(int rank) {
        int [] primes = new int [rank+1];
        primes[0] = 3;
        primes[1] = 5;
        int candidate = 7;
        int i = 1; 
        while (i < rank) {
            int maxDivider = (int)java.lang.Math.sqrt(candidate);
            for (int j = 0; j <= i; ++j) {
                int divider = primes[j];
                if (candidate % divider == 0) {
                    break;
                } else if (divider > maxDivider) {
                    // found a prime
                    primes[++i] = candidate;
                    break;
                }
            }
            candidate += 2;
        }
        return primes[rank];
    }
*/
foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.M2.TestSupport$QuickPrimeGenerator.generate" 
    java_sieveBasedGetNthPrime :: Int -> Int;
  
/*
A close port of the Java implementation of java_sieveBasedGetNthPrime as an algebraic CAL function.
 */    
sieveBasedGetNthPrime :: Int -> Int;    
sieveBasedGetNthPrime !rank =
    let        
        primes = Prelude.eager (intArray_new (rank + 1));     

        generate :: Int -> Int -> Int;
        generate !i !candidate =
            if i < rank then
                let
                    maxDivisor :: Int;
                    maxDivisor = Prelude.eager (Prelude.truncate (Math.sqrt (toDouble candidate)));
                    
                    isPrime :: Int -> Boolean;
                    isPrime !j =                       
                        if j > i then
                          True
                        else
                            let
                                 divisor = Prelude.eager (intArray_subscript primes j);
                            in
                                 if candidate % divisor == 0 then
                                     False
                                 else if divisor > maxDivisor then
                                     True
                                 else
                                      isPrime (j + 1);                                
                in
                   if isPrime 0 then                       
                       intArray_update primes (i + 1) candidate
                       `seq`
                       generate (i + 1) (candidate + 2)
                   else
                       generate i (candidate + 2)
            else
                candidate - 2;
            
    in
        intArray_update primes 0 3
        `seq`
        intArray_update primes 1 5
        `seq`
        generate 1 7;    
    
testSieveBasedPrimeGenerators =
    assert (map sieveBasedGetNthPrime (upFromTo 1 20) == map java_sieveBasedGetNthPrime (upFromTo 1 20))
    && assert (map sieveBasedGetNthPrime (upFromTo 1 10) == [5, 7, 11, 13, 17, 19, 23, 29, 31, 37])
    ;


/*
A close port of the Java implementation of java_sieveBasedGetNthPrime as an algebraic CAL function.
This is a modification of sieveBasedGetNthPrime2 to make it more declarative
 */    
sieveBasedGetNthPrime2 :: Int -> Int;    
sieveBasedGetNthPrime2 !rank =
    let        
        primes = Prelude.eager (intArray_new (rank + 1));     

        /**
         * This function has the side effect of populating the array primes with the
         * prime of rank 0 (3), prime of rank 2 (5), ..., prime of rank 'rank'.
         * 
         * @arg i an index into the array primes. the primes array is populated at indices 0, ..., i with a prime
         * @arg candidate candidate value to test for primality. This value is the next possible prime greater than the primes_i.
         * @return the prime of rank 'rank'.
         */
        populatePrimesArrayLoop :: Int -> Int -> Int;
        populatePrimesArrayLoop !i !candidate =
            if i < rank then
                let
                    maxDivisor :: Int;
                    maxDivisor = Prelude.eager (Prelude.truncate (Math.sqrt (toDouble candidate)));
                    
                    /**
                     * assumes that primes is populated with successive odd primes from index 0 .. i.
                     * @arg candidate to test for primality. This value is the next possible prime greater than primes_i.
                     * @return true if candidate is prime.
                     */
                    isPrime :: Int -> Boolean;
                    isPrime !candidate =
                        let                                          
                            isPrimeLoop :: Int -> Boolean;
                            isPrimeLoop !j =                       
                                if j > i then
                                  True
                                else
                                    let
                                         divisor = Prelude.eager (intArray_subscript primes j);
                                    in
                                         if candidate % divisor == 0 then
                                             False
                                         else if divisor > maxDivisor then
                                             True
                                         else
                                              isPrimeLoop (j + 1);  
                         in
                             isPrimeLoop 0;
                         
                in
                   if isPrime candidate then                       
                       intArray_update primes (i + 1) candidate
                       `seq`
                       populatePrimesArrayLoop (i + 1) (candidate + 2)
                   else
                       populatePrimesArrayLoop i (candidate + 2)
            else
                candidate - 2;
            
    in
        intArray_update primes 0 3
        `seq`
        intArray_update primes 1 5
        `seq`
        populatePrimesArrayLoop 1 7;    
    
testSieveBasedPrimeGenerators2 =
    assert (map sieveBasedGetNthPrime2 (upFromTo 1 20) == map java_sieveBasedGetNthPrime (upFromTo 1 20))
    && assert (map sieveBasedGetNthPrime2 (upFromTo 1 10) == [5, 7, 11, 13, 17, 19, 23, 29, 31, 37])
    ;
         
//end - primes benchmark based on Sieve of Eratosthenes 
////////////////////////////////////////////////////////////////////////
      
      
// Test data type containing a plinged field of type InternalValue.
// This is included to test for a compilationg bug in trying to generate the 
// buildDeepSeq method.
data Cursor = 
    private Cursor 
        state :: !CalValue
        isAfterLastRow :: !Boolean
        advancedCursor :: Cursor
    ;

////////////////////////////////////////////////////////////////////////
//some examples of using Debug module functions

//a constant applicative form (CAF)
sevens :: [Int];
sevens = 7 : sevens;

//CAF
naturals :: [Integer];
naturals = upFrom 1;

//CAF
strangeTuple :: (Int, Maybe Char, (Int, Maybe Char));
strangeTuple = let x = Just 'z'; in (20, x, (20, x));

/**
some examples of the use of showInternal, showInternalGraph and internalValueStats
for a talk on April 18, 2006. Also see the examples in Debug_Tests.testShowInternalLecc
*/
debugFunctionsTalk =   
    assert
    //an unevaluated CAF
    (showInternal sevens
        == "M2.sevens")     
        
    &&
    assert
    //after forcing evaluation of the first 10 elements, we can see the structure of the graph.
    //notice that it has a constant space representation
    ((output (take 10 sevens)) `seq` (showInternal sevens)
        == "<@1 = (Prelude.Cons 7 <@1>)>")
     
    &&
    assert
    //notice the indirection node. This is because a CAF's value is cached globally and only ever evaluated once.
    (showInternalGraph sevens
        == "*<@1 = (Prelude.Cons 7 <@1>)>")
        
    &&
    assert
    //the distinct nodes are: the indirection node, the Cons node, and the 7 node.
    //the Cons node is shared.
    (show (internalValueStats sevens)
        == "(nDistinctNodes = 3, nDistinctIndirectionNodes = 1, nSharedNodes = 1)")
            
    &&
    assert
    //an unevaluated CAF
    (showInternalGraph naturals
        == "M2.naturals")
        
    &&
    assert
    //after forcing evaluation of the first 5 elements, we can see that naturals has a representation proportional to
    //how evaluated it is.
    ((output (take 5 naturals)) `seq` (showInternal naturals)
        == "(Prelude.Cons 1 (Prelude.Cons 2 (Prelude.Cons 3 (Prelude.Cons 4 (Prelude.Cons 5 (Prelude.upFromInteger (Prelude.addInteger 5 1)))))))")
      
    &&
    assert 
    //notice the indirection nodes before each Cons node.
    (showInternalGraph naturals 
        == "*(Prelude.Cons 1 *(Prelude.Cons 2 *(Prelude.Cons 3 *(Prelude.Cons 4 *(Prelude.Cons 5 (Prelude.upFromInteger (Prelude.addInteger 5 1)))))))")

    && 
    assert
    //after retraversing the first 3 elements of naturals, we clean up indirections, 
    //so there are no indirections in front of Cons 2 and Cons 3 and Cons 4.
    ((output (take 3 naturals)) `seq` (showInternalGraph naturals)
        == "*(Prelude.Cons 1 (Prelude.Cons 2 (Prelude.Cons 3 (Prelude.Cons 4 *(Prelude.Cons 5 (Prelude.upFromInteger (Prelude.addInteger 5 1)))))))") 
       
    &&
    assert
    (show (internalValueStats naturals)
        == "(nDistinctNodes = 16, nDistinctIndirectionNodes = 2, nSharedNodes = 0)")
        
    &&
    assert
    //notice the sharing of the Just node defined via a let variable. 
    (output strangeTuple `seq` showInternal strangeTuple
        == "(20, <@1 = (Prelude.Just z)>, (20, <@1>))")
        
    && 
    assert
    //notice the sharing of the Just node defined via a let variable as well as the Int value 20.
    (showInternalGraph strangeTuple
        == "*(<@1 = 20>, <@2 = (Prelude.Just z)>, (<@1>, <@2>))")
        
    &&
    assert
    //showInternal shows an inefficiency in the implementation of allPrimes. Notice the final composition of filtering operations.
    (output (take 5 M1.allPrimes) `seq` showInternal M1.allPrimes 
        == "(Prelude.Cons 2 (Prelude.Cons 3 (Prelude.Cons 5 (Prelude.Cons 7 (Prelude.Cons 11 (M1.sieve (List.filter (M1.nonMultiple 11) (List.filter (M1.nonMultiple 7) (List.filter (M1.nonMultiple 5) (List.filter (M1.nonMultiple 3) (List.filter (M1.nonMultiple 2) (Prelude.upFromInt 12))))))))))))")
    ;


//hand rolled tracing on the List.zip function
myZip !list1 list2 =      
    ("M2.myZip " ++ showInternal list1 ++ " " ++ showInternal list2 ++ "\n")
    `Debug.trace`
    (
        case list1 of
        x : xs ->
            case list2 of
            y : ys -> (x, y) : myZip xs ys;
            [] -> [];
            ;
        [] -> [];    
    );

//run the following on the ICE console to test
//myZip (Prelude.upFromTo (1::Prelude.Int) 3) ['a', 'b', 'c']

//run the following (for n = 10 for example) in a tracing capable build
//summing the first n primes, but only tracing the summing part
sumFirstNPrimes !n =
    let
        first10Primes = map getNthPrime (upFromTo 0 (n - 1));        
    in        
        setTracingEnabled False
        `seq`
        first10Primes
        `deepSeq`
        setTracingEnabled True
        `seq`
        sum first10Primes;

//run the following (for n = 10 for example) in a tracing capable build
//default tracing, as a comparison with sumFirstNPrimes    
sumFirstNPrimes2 !n =
    let
        first10Primes = map getNthPrime (upFromTo 0 (n - 1));        
    in                
        first10Primes
        `deepSeq`        
        sum first10Primes;    
       


//Testing SourceModel's support of handling the optional access modifier (i.e. the default private scope)
//(This is intended to support the testing done via the SourceModel_Test.testRoundTrip_ModuleDefnsFromWorkspace test)

testSMDefaultPrivate = undefined;

private testSMPrivate = undefined;

protected testSMProtected = undefined;

testSM= undefined;

foreign unsafe import jvm "static field java.lang.Math.PI" testSMDefaultPrivateForeign :: Double;

foreign unsafe import jvm "static field java.lang.Math.PI" private testSMPrivateForeign :: Double;

foreign unsafe import jvm "static field java.lang.Math.PI" protected testSMProtectedForeign :: Double;

foreign unsafe import jvm "static field java.lang.Math.PI" public testSMPublicForeign :: Double;

class TestSMDefaultPrivateClass a where
    testSMDefaultPrivateMethod :: a;
    ;

private class TestSMPrivateClass a where
    private testSMPrivateMethod :: a;
    ;
    
protected class TestSMProtectedClass a where
    protected testSMProtectedMethod :: a;
    ;
    
public class TestSMPublicClass a where
    public testSMPublicMethod :: a;
    ;
    
data TestSMDefaultPrivateType =
    TestSMDefaultPrivateDataCons;

data private TestSMPrivateType =
    private TestSMPrivateDataCons;

data protected TestSMProtectedType =
    protected TestSMProtectedDataCons;

data public TestSMPublicType =
    public TestSMPublicDataCons;

data foreign unsafe import jvm "char"
    TestSMDefaultPrivateForeignType;

data foreign unsafe import jvm private "char"
    private TestSMPrivateForeignType;

data foreign unsafe import jvm protected "char"
    protected TestSMProtectedForeignType;

data foreign unsafe import jvm public "char"
    public TestSMPublicForeignType;
 
///////////////////////////////////////////////////////////

/**
 * A tail recursion function with more than 15 arguments.
 * This is used to test a situation which requires generating
 * a lazy application node specific to the function.  Lazy 
 * application nodes for up to 15 arguments are built into
 * the run time.
 */
largeArityTailRecursion :: [Double] -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> Double;
largeArityTailRecursion !a !b c d e f g h i j k l m n o p q =
	case a of
	x : xy -> largeArityTailRecursion xy (b + 1.0) c d e f g h i j k l m n o p q;
	[] -> b;
	;
	
/**
 * Test a lazy fully saturated application of a tail recursive
 * function with more than 15 arguments.
 */	
testLargArityLazyTailRecursion :: Boolean;	
public testLargArityLazyTailRecursion =
	let
	    helper :: Double -> Boolean;
	    helper x = (x + 1.0) == 5000001.0;
	in
	    helper (largeArityTailRecursion (upFromTo 1.0 5000000) 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0);	
    
     
/*
 * Test an application of a data constructor selection to an argument
 * in a strict context.
 */
data DCFsTest = DCFsTest x :: (Int -> Int);   
testStrictDCFieldSelection d = (d.DCFsTest.x 1) + 1;


/*
 * These three functions test a bug involving partial applications and strongly
 * coupled functions.
 * partialAppTestHelper1 and partialAppTestHelper2 are mutually referential.  This means that
 * the lecc will generate a single java class containing the logic for these functions.
 * The generated class will contain both an f3L and an f2L since it contains functions of
 * both arity 2 and 3.
 * In partialAppTest the first argument to Prelude.seq is a partial application of partialAppTestHelper1.
 * Because it is the first argument to seq this expression is compiled strictly.  An optimization
 * existed for applications that couldn't be proved to be fully saturated that occured in a strict context.
 * Instead of generating something like. a.apply(b, c).evaluate();  the lecc code generator would generate
 * a.f2L(b, c).evaluate();  This took advantage of the fact that the default version of f2L() simply does an 
 * application of the two arguments.  However, if 'a' was an instance of RTPartialApp the f2L() method would 
 * call the appropriate fnL method with the full set of arguments, thus saving building the application nodes.
 * Unfortunately this relied on the fact that if 'a' was an instance of a generated function class it would 
 * only have one fnL method.  i.e. The 'a' class could only represent a single function with a single arity.
 * With functions being grouped into a single class this is no longer true and the optimization is no longer
 * valid.
 * Before fixing this partialAppTest would generate an error from the call to Prelude.error in
 * partialAppTestHelper1, even though there is no full application of partialAppTestHelper1.
 */
partialAppTestHelper1 :: Prelude.Double -> Prelude.Double -> Prelude.Double -> Prelude.Double;
partialAppTestHelper1 x y z =
     if (z > 0) then (partialAppTestHelper1 x y (z-1)) else ((Prelude.error "Shouldn't be called.") `seq` (partialAppTestHelper2 x y));
     
partialAppTestHelper2 :: Prelude.Double -> Prelude.Double -> Prelude.Double;     
partialAppTestHelper2 x y =
    if (x > 0) then (partialAppTestHelper1 x x x) else 0;
    
partialAppTest = (partialAppTestHelper1 1.0 1.0) `seq` Prelude.True;

/**
 * This function tests for a code generation bug when handling multiple applications of 'eager'.
 */
testMultipleEagerApplications :: Long;
testMultipleEagerApplications = Prelude.fromInt (eager (eager 0));

/**
 * Test handling of circular let variable definition.
 * When this function is run it should produce the error message:
 * "Invalid reduction state in indirection.  This is probably caused by a circular let variable definition."
 */
circularLetVarDefinition =
    let 
        a = b;
        b = c;
        c = a;
    in
        a + b + c + 1.0;

/**
 * Test handling of circular record definition.
 * When this function is run it should produce the error message:
 * "Invalid reduction state in record selection.  This is probably caused by a circular record definition."
 */
circularRecordDefinition = 
    let
        (a, b, c) = (c, a, b);
    in
        a + b + c + 1.0;


testDoubleFunction :: Double -> Double;
testDoubleFunction x = x + 1.0;

/*
 * A series of functions designed to test code generation of let variables
 * using Prelude.seq at the top level of the definition. 
 */
testLetVarSeq1 =
    let
        x = seq (testDoubleFunction 1.0) (2.0);
    in
        x + (testDoubleFunction x);

testLetVarSeq2 =
    let
        x = seq (testDoubleFunction 1.0) (testDoubleFunction 2.0);
    in
        x + (testDoubleFunction x);

testLetVarSeq3 = 
    let
        x = seq (seq (testDoubleFunction 1.0) (testDoubleFunction 2.0)) (seq (testDoubleFunction 3.0) (testDoubleFunction 4.0));
    in
        x + (testDoubleFunction x);

testLetVarSeq4 =
    let
        x = eager (seq (testDoubleFunction 1.0) (2.0));
    in
        x + (testDoubleFunction x);

testLetVarSeq5 =
    let
        x = (testDoubleFunction 1.0) `seq` (testDoubleFunction 2.0) `seq` (testDoubleFunction 3.0) `seq` (testDoubleFunction 4.0);
    in
        x + (testDoubleFunction x);

testLetVarSeq6 =
    let
        x = (testDoubleFunction 1.0) `seq` ((testDoubleFunction 2.0) `seq` ((testDoubleFunction 3.0) `seq` (testDoubleFunction 4.0)));
    in
        x + (testDoubleFunction x);

testLetVarSeq7 =
    let
        x = (((testDoubleFunction 1.0) `seq` (testDoubleFunction 2.0)) `seq` (testDoubleFunction 3.0)) `seq` (testDoubleFunction 4.0);
    in
        x + (testDoubleFunction x);

testLetVarSeq = 
    assert (testLetVarSeq1 == 5.0)
    && assert (testLetVarSeq2 == 7.0)
    && assert (testLetVarSeq3 == 11.0)
    && assert (testLetVarSeq4 == 5.0)
    && assert (testLetVarSeq5 == 11.0)
    && assert (testLetVarSeq6 == 11.0)
    && assert (testLetVarSeq7 == 11.0);

testGMachine_Indirect_Chains =
    let
        myList = output (upFromTo 1 (10000 :: Int));

    in
        myList
        `seq`
        List.last (input myList :: [Int]);

/**
 * A definition to test various toolings' handling of shadowed let definitions (e.g. CAL Eclipse plugin's go to definition feature).
 */
testShadowedLetDefns =
    let
        x = 1.0;
    in
        let
            x = 2.0;
            y =
                let
                    x = 3.0;
                in
                    x;
            z = x;
        in
            x;

/**
 * This is a test case for a CAF with an indirectly circular reference.
 * It should trace out a continuous stream of "foo".
 */
infiniteCAF :: ();
public infiniteCAF = if False
                  then ()
                  else
                      trace "foo\n" infiniteCAF;

/**
 * This is a test case for a function with an indirectly circular reference.
 * It should trace out a continuous stream of "foo".
 */infiniteFunc :: Int -> (); 
public infiniteFunc n = if False
                  then ()
                  else
                      trace "foo\n" (infiniteFunc n);


/**
 * Test function with > 15 arguments and unboxable return.
 */
lotsOfArgsWithUnboxedReturn a b c d e f g h i j k l m n o p q r =
    case a of 
    [] -> 1.0;
    x : xs -> b + c + d + e + f + g + 2.0;
    ;

/**
 * Test function with > 15 arguments, unboxable return and a strict/unboxable argument.
 */
lotsOfArgsWithUnboxedReturnAndStrictUnboxableArg a !b c d e f g h i j k l m n o p q r =
    case a of 
    [] -> 1.0;
    x : xs -> b + c + d + e + f + g + 2.0;
    ;

/**
 * Test function with > 15 arguments, unboxable return, and tail recursion.
 */
lotsOfArgsWithUnboxedReturnAndRecursion a b c d e f g h i j k l m n o p q r =
    case a of 
    [] -> lotsOfArgsWithUnboxedReturnAndRecursion [1.0, 2.0] b c d e f g h i j k l m n o p q r;
    x : xs -> b + c + d + e + f + g + 2.0;
    ;
 
/**
 * Test function with > 15 arguments, unboxable return, tail recursion, and a strict/unboxable argument.
 */
lotsOfArgsWithUnboxedReturnAndRecursionAndStrictUnboxableArg a !b c d e f g h i j k l m n o p q r =
    case a of 
    [] -> lotsOfArgsWithUnboxedReturnAndRecursion [1.0, 2.0] b c d e f g h i j k l m n o p q r;
    x : xs -> b + c + d + e + f + g + 2.0;
    ;

lotsOfArgsTest = 
    (lotsOfArgsWithUnboxedReturn [] 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 11.0 12.0 13.0 14.0 15.0 16.0 17.0 18.0)
    + (lotsOfArgsWithUnboxedReturnAndStrictUnboxableArg [] 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 11.0 12.0 13.0 14.0 15.0 16.0 17.0 18.0)
    + (lotsOfArgsWithUnboxedReturnAndRecursion [] 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 11.0 12.0 13.0 14.0 15.0 16.0 17.0 18.0)
    + (lotsOfArgsWithUnboxedReturnAndRecursionAndStrictUnboxableArg [] 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 11.0 12.0 13.0 14.0 15.0 16.0 17.0 18.0);

/////

// The following is a regression test for the bytecode generator's processing of an inline foreign call to a method
// throwing a checked exception inside a tail-recursive loop.
//
// The error reported is:
// Error while executing: Fatal Executor error.
// Caused by: java.lang.VerifyError: (class: org/openquark/cal_Cal_Test_General_M2/Exception_Handler_Code_Gen_Test__loop__1, method: fUnboxed1S signature: (Lorg/openquark/cal/internal/machine/lecc/RTValue;Lorg/openquark/cal/internal/machine/lecc/RTExecutionContext;)I) Illegal exception table ??,  Detail: (class: org/openquark/cal_Cal_Test_General_M2/Exception_Handler_Code_Gen_Test__loop__1, method: fUnboxed1S signature: (Lorg/openquark/cal/internal/machine/lecc/RTValue;Lorg/openquark/cal/internal/machine/lecc/RTExecutionContext;)I) Illegal exception table ??
//
// This is caused by an invalid exception table entry whose range is empty (i.e. its start(inclusive) and end(exclusive) program counter values
// are the same). This affected all variants of the generated method for the loop: f, f1L, f1S, fUnboxed1S
//
// The java model for fUnboxed1S looks like this:
//
//public final int fUnboxed1S(RTValue dummy, RTExecutionContext $ec) throws CALExecutorException {
//    $ec.clearRootMembers();
//    TRLoop: while (true) {
//        if ($ec.isQuitRequested()) {
//            throw RTValue.INTERRUPT_EXCEPTION;
//        }
//        try {
//            // Top level supercombinator logic
//            if (!TestSupport.falseWithThrowsDecl()) {
//                return 0;
//            } else {
//                continue TRLoop;
//            }
//        } catch (java.io.IOException caught_exception) {
//            throw 
//                new RTForeignFunctionException(
//                    RTValue.generateForeignFunctionErrorMessage(
//                        caught_exception, 
//                        "org.openquark.cal_Cal_Test_General_M2.Exception_Handler_Code_Gen_Test__loop__1", 
//                        "Cal.Test.General.M2", 
//                        "exceptionHandlerCodeGenTest$loop$1"), 
//                    caught_exception);
//        }
//    }
//}
//
// The fix is in the encodeTryCatchBlock method of the AsmJavaBytecodeGenerator. See the comment there for the details about the fix.
//

/**
 * A foreign function that always returns {@link False@}, but whose underlying method is declared to potentially throw a checked exception.
 * @return {@link False@} always.
 */
foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.M2.TestSupport.falseWithThrowsDecl"
    private falseWithThrowsDecl :: Boolean;

/** A test function that contains a tail-recursive loop whose body calls a foreign function that may throw a checked exception. */
exceptionHandlerCodeGenTest :: Boolean;
exceptionHandlerCodeGenTest =
    let
        loop :: Double -> ();
        loop !dummy =
            if not (eager falseWithThrowsDecl) then
                ()
            else
                loop dummy
            ;
    in
        assert (loop 4.0 == ())
    ;

/** An entry point for {@link exceptionHandlerCodeGenTest@} for running in standalone JAR mode. */
runExceptionHandlerCodeGenTest :: [String] -> ();
public runExceptionHandlerCodeGenTest !args =
    if exceptionHandlerCodeGenTest then
        traceOnStdOut "M2.exceptionHandlerCodeGenTest passed.\n" ()
    else
        traceOnStdOut "M2.exceptionHandlerCodeGenTest failed.\n" ()
    ;

/////

// Test Class literal support in CAL

data foreign unsafe import jvm "java.lang.Class" JClass1 deriving Eq, Inputable, Outputable, Show;
data foreign unsafe import jvm "java.lang.Class" JClass2 deriving Eq, Inputable, Outputable, Show;

data foreign unsafe import jvm "java.io.Serializable" JSerializable deriving Eq, Inputable, Outputable, Show;
data foreign unsafe import jvm "java.lang.reflect.GenericDeclaration" JReflectGenericDeclaration deriving Eq, Inputable, Outputable, Show;
data foreign unsafe import jvm "java.lang.reflect.Type" JReflectType deriving Eq, Inputable, Outputable, Show;
data foreign unsafe import jvm "java.lang.reflect.AnnotatedElement" JReflectAnnotatedElement deriving Eq, Inputable, Outputable, Show;

foreign unsafe import jvm "cast" jclass1_to_jclass2 :: JClass1 -> JClass2;

foreign unsafe import jvm "cast" jclass1_to_jSerializable :: JClass1 -> JSerializable;
foreign unsafe import jvm "cast" jclass1_to_jReflectGenericDeclaration :: JClass1 -> JReflectGenericDeclaration;
foreign unsafe import jvm "cast" jclass1_to_jReflectType :: JClass1 -> JReflectType;
foreign unsafe import jvm "cast" jclass1_to_jReflectAnnotatedElement :: JClass1 -> JReflectAnnotatedElement;
foreign unsafe import jvm "cast" jobject_to_jclass1 :: JObject -> JClass1;

// JClass1 values
foreign unsafe import jvm "class boolean" jclass1_boolean :: JClass1;
foreign unsafe import jvm "class byte" jclass1_byte :: JClass1;
foreign unsafe import jvm "class char" jclass1_char :: JClass1;
foreign unsafe import jvm "class short" jclass1_short :: JClass1;
foreign unsafe import jvm "class int" jclass1_int :: JClass1;
foreign unsafe import jvm "class long" jclass1_long :: JClass1;
foreign unsafe import jvm "class float" jclass1_float :: JClass1;
foreign unsafe import jvm "class double" jclass1_double :: JClass1;
foreign unsafe import jvm "class void" jclass1_void :: JClass1;

foreign unsafe import jvm "class java.lang.Boolean" jclass1_boxed_Boolean :: JClass1;
foreign unsafe import jvm "class java.lang.Byte" jclass1_boxed_Byte :: JClass1;
foreign unsafe import jvm "class java.lang.Character" jclass1_boxed_Character :: JClass1;
foreign unsafe import jvm "class java.lang.Short" jclass1_boxed_Short :: JClass1;
foreign unsafe import jvm "class java.lang.Integer" jclass1_boxed_Integer :: JClass1;
foreign unsafe import jvm "class java.lang.Long" jclass1_boxed_Long :: JClass1;
foreign unsafe import jvm "class java.lang.Float" jclass1_boxed_Float :: JClass1;
foreign unsafe import jvm "class java.lang.Double" jclass1_boxed_Double :: JClass1;
foreign unsafe import jvm "class java.lang.Void" jclass1_boxed_Void :: JClass1;

foreign unsafe import jvm "class java.lang.Object" jclass1_Object :: JClass1;
foreign unsafe import jvm "class java.lang.String" jclass1_String :: JClass1;
foreign unsafe import jvm "class java.util.List" jclass1_List :: JClass1;

foreign unsafe import jvm "class java.lang.Object[]" jclass1_Object_array :: JClass1;
foreign unsafe import jvm "class java.lang.String[]" jclass1_String_array :: JClass1;
foreign unsafe import jvm "class java.util.List[]" jclass1_List_array :: JClass1;

foreign unsafe import jvm "class int[]" jclass1_int_array :: JClass1;
foreign unsafe import jvm "class int[][]" jclass1_int_array_array :: JClass1;

// JClass2 values
foreign unsafe import jvm "class boolean" jclass2_boolean :: JClass2;
foreign unsafe import jvm "class byte" jclass2_byte :: JClass2;
foreign unsafe import jvm "class char" jclass2_char :: JClass2;
foreign unsafe import jvm "class short" jclass2_short :: JClass2;
foreign unsafe import jvm "class int" jclass2_int :: JClass2;
foreign unsafe import jvm "class long" jclass2_long :: JClass2;
foreign unsafe import jvm "class float" jclass2_float :: JClass2;
foreign unsafe import jvm "class double" jclass2_double :: JClass2;
foreign unsafe import jvm "class void" jclass2_void :: JClass2;

foreign unsafe import jvm "class java.lang.Boolean" jclass2_boxed_Boolean :: JClass2;
foreign unsafe import jvm "class java.lang.Byte" jclass2_boxed_Byte :: JClass2;
foreign unsafe import jvm "class java.lang.Character" jclass2_boxed_Character :: JClass2;
foreign unsafe import jvm "class java.lang.Short" jclass2_boxed_Short :: JClass2;
foreign unsafe import jvm "class java.lang.Integer" jclass2_boxed_Integer :: JClass2;
foreign unsafe import jvm "class java.lang.Long" jclass2_boxed_Long :: JClass2;
foreign unsafe import jvm "class java.lang.Float" jclass2_boxed_Float :: JClass2;
foreign unsafe import jvm "class java.lang.Double" jclass2_boxed_Double :: JClass2;
foreign unsafe import jvm "class java.lang.Void" jclass2_boxed_Void :: JClass2;

foreign unsafe import jvm "class java.lang.Object" jclass2_Object :: JClass2;
foreign unsafe import jvm "class java.lang.String" jclass2_String :: JClass2;
foreign unsafe import jvm "class java.util.List" jclass2_List :: JClass2;

foreign unsafe import jvm "class java.lang.Object[]" jclass2_Object_array :: JClass2;
foreign unsafe import jvm "class java.lang.String[]" jclass2_String_array :: JClass2;
foreign unsafe import jvm "class java.util.List[]" jclass2_List_array :: JClass2;

foreign unsafe import jvm "class int[]" jclass2_int_array :: JClass2;
foreign unsafe import jvm "class int[][]" jclass2_int_array_array :: JClass2;

// values as superclass/superinterface types

foreign unsafe import jvm "class boolean" jclass_boolean_as_jSerializable :: JSerializable;
foreign unsafe import jvm "class boolean" jclass_boolean_as_jReflectGenericDeclaration :: JReflectGenericDeclaration;
foreign unsafe import jvm "class boolean" jclass_boolean_as_jReflectType :: JReflectType;
foreign unsafe import jvm "class boolean" jclass_boolean_as_jReflectAnnotatedElement :: JReflectAnnotatedElement;
foreign unsafe import jvm "class boolean" jclass_boolean_as_jobject :: JObject;


testForeignClassLiterals =
    assert (jclass2_boolean == jclass1_to_jclass2 jclass1_boolean)
    && assert (jclass2_byte == jclass1_to_jclass2 jclass1_byte)
    && assert (jclass2_char == jclass1_to_jclass2 jclass1_char)
    && assert (jclass2_short == jclass1_to_jclass2 jclass1_short)
    && assert (jclass2_int == jclass1_to_jclass2 jclass1_int)
    && assert (jclass2_long == jclass1_to_jclass2 jclass1_long)
    && assert (jclass2_float == jclass1_to_jclass2 jclass1_float)
    && assert (jclass2_double == jclass1_to_jclass2 jclass1_double)
    && assert (jclass2_void == jclass1_to_jclass2 jclass1_void)
    && assert (jclass2_boxed_Boolean == jclass1_to_jclass2 jclass1_boxed_Boolean)
    && assert (jclass2_boxed_Byte == jclass1_to_jclass2 jclass1_boxed_Byte)
    && assert (jclass2_boxed_Character == jclass1_to_jclass2 jclass1_boxed_Character)
    && assert (jclass2_boxed_Short == jclass1_to_jclass2 jclass1_boxed_Short)
    && assert (jclass2_boxed_Integer == jclass1_to_jclass2 jclass1_boxed_Integer)
    && assert (jclass2_boxed_Long == jclass1_to_jclass2 jclass1_boxed_Long)
    && assert (jclass2_boxed_Float == jclass1_to_jclass2 jclass1_boxed_Float)
    && assert (jclass2_boxed_Double == jclass1_to_jclass2 jclass1_boxed_Double)
    && assert (jclass2_boxed_Void == jclass1_to_jclass2 jclass1_boxed_Void)
    && assert (jclass2_Object == jclass1_to_jclass2 jclass1_Object)
    && assert (jclass2_String == jclass1_to_jclass2 jclass1_String)
    && assert (jclass2_List == jclass1_to_jclass2 jclass1_List)
    && assert (jclass2_Object_array == jclass1_to_jclass2 jclass1_Object_array)
    && assert (jclass2_String_array == jclass1_to_jclass2 jclass1_String_array)
    && assert (jclass2_List_array == jclass1_to_jclass2 jclass1_List_array)
    && assert (jclass2_int_array == jclass1_to_jclass2 jclass1_int_array)
    && assert (jclass2_int_array_array == jclass1_to_jclass2 jclass1_int_array_array)

    
    && assert (jclass1_byte != jclass1_boxed_Byte)
    && assert (jclass1_char != jclass1_boxed_Character)
    && assert (jclass1_short != jclass1_boxed_Short)
    && assert (jclass1_int != jclass1_boxed_Integer)
    && assert (jclass1_long != jclass1_boxed_Long)
    && assert (jclass1_float != jclass1_boxed_Float)
    && assert (jclass1_double != jclass1_boxed_Double)
    && assert (jclass1_void != jclass1_boxed_Void)
    
    
    && assert (show jclass2_boolean == "boolean")
    && assert (show jclass2_byte == "byte")
    && assert (show jclass2_char == "char")
    && assert (show jclass2_short == "short")
    && assert (show jclass2_int == "int")
    && assert (show jclass2_long == "long")
    && assert (show jclass2_float == "float")
    && assert (show jclass2_double == "double")
    && assert (show jclass2_void == "void")
    && assert (show jclass2_boxed_Boolean == "class java.lang.Boolean")
    && assert (show jclass2_boxed_Byte == "class java.lang.Byte")
    && assert (show jclass2_boxed_Character == "class java.lang.Character")
    && assert (show jclass2_boxed_Short == "class java.lang.Short")
    && assert (show jclass2_boxed_Integer == "class java.lang.Integer")
    && assert (show jclass2_boxed_Long == "class java.lang.Long")
    && assert (show jclass2_boxed_Float == "class java.lang.Float")
    && assert (show jclass2_boxed_Double == "class java.lang.Double")
    && assert (show jclass2_boxed_Void == "class java.lang.Void")
    && assert (show jclass2_Object == "class java.lang.Object")
    && assert (show jclass2_String == "class java.lang.String")
    && assert (show jclass2_List == "interface java.util.List")
    && assert (show jclass2_Object_array == "class [Ljava.lang.Object;")
    && assert (show jclass2_String_array == "class [Ljava.lang.String;")
    && assert (show jclass2_List_array == "class [Ljava.util.List;")
    && assert (show jclass2_int_array == "class [I")
    && assert (show jclass2_int_array_array == "class [[I")
    
    
    && assert (jclass_boolean_as_jSerializable == jclass1_to_jSerializable jclass1_boolean)
    && assert (jclass_boolean_as_jReflectGenericDeclaration == jclass1_to_jReflectGenericDeclaration jclass1_boolean)
    && assert (jclass_boolean_as_jReflectType == jclass1_to_jReflectType jclass1_boolean)
    && assert (jclass_boolean_as_jReflectAnnotatedElement == jclass1_to_jReflectAnnotatedElement jclass1_boolean)
    && assert (jobject_to_jclass1 jclass_boolean_as_jobject == jclass1_boolean)
    ;

/////

// Regression test for foreign instanceof functions with array types

foreign unsafe import jvm "instanceof int[]" jInstanceOfIntArray :: JObject -> Boolean;

data foreign unsafe import jvm "java.lang.String[]" JStringArray deriving Inputable, Outputable;
data foreign unsafe import jvm "java.util.List[]" JListArray deriving Inputable, Outputable;
data foreign unsafe import jvm "java.util.ArrayList[]" JArrayListArray deriving Inputable, Outputable;

foreign unsafe import jvm "newArray" jStringArray_new :: Int -> JStringArray;
foreign unsafe import jvm "newArray" jListArray_new :: Int -> JListArray;
foreign unsafe import jvm "newArray" jArrayListArray_new :: Int -> JArrayListArray;

foreign unsafe import jvm "instanceof java.lang.Object[]" jInstanceOfObjectArray :: JObject -> Boolean;
foreign unsafe import jvm "instanceof java.util.List[]" jInstanceOfListArray :: JObject -> Boolean;

testInstanceOfArrayTypes =
    assert (jInstanceOfIntArray $ output $ intArray_new 0)
    && assert (jInstanceOfIntArray $ output $ intArray_new 3)
    && assert (not $ jInstanceOfIntArray $ output "a string")
    && assert (not $ jInstanceOfIntArray $ output 3.2)
    && assert (not $ jInstanceOfObjectArray $ output $ intArray_new 0)
    && assert (not $ jInstanceOfListArray $ output $ intArray_new 0)
    && assert (jInstanceOfObjectArray $ output $ jStringArray_new 0)
    && assert (not $ jInstanceOfListArray $ output $ jStringArray_new 0)
    && assert (jInstanceOfObjectArray $ output $ jListArray_new 0)
    && assert (jInstanceOfListArray $ output $ jListArray_new 0)
    && assert (jInstanceOfObjectArray $ output $ jArrayListArray_new 0)
    && assert (jInstanceOfListArray $ output $ jArrayListArray_new 0)
    ;

/////

// Regression test for foreign cast functions where they are called with values whose Java types are incompatible with the cast type

// Suppose there are classes A, B, and C, where B and C are subclasses of A.
// The cast is from A to B. The actual expression being cast has a static Java type of C.
// While the JVM allows such a checkcast operation, the Java language does not, because
// C is not compatible with B for a cast operation. -- This is an issue for the java source generation mode.

data foreign unsafe import jvm "java.lang.ClassCastException"
    private JClassCastException deriving Inputable, Outputable, Show;

instance Exception JClassCastException where;

foreign unsafe import jvm "cast" jCastToString :: JObject -> String;

data foreign unsafe import jvm "java.lang.Object[]" JObjectArray deriving Inputable, Outputable;

foreign unsafe import jvm "cast" jCastToIntArray :: JObject -> JIntArray;
foreign unsafe import jvm "cast" jCastToObjectArray :: JObject -> JObjectArray;
foreign unsafe import jvm "cast" jCastToListArray :: JObject -> JListArray;

expectClassCastException castExpr =
    (castExpr `seq` False)
    `catch`
    (\e -> (e::JClassCastException) `seq` True)
    ;

testForeignCast =
    assert (let goodCastExpr x = eager $ jCastToString $ output "a string"; in not $ expectClassCastException $ goodCastExpr ())
    && assert (let badCastExpr x = eager $ jCastToString $ output 3.2; in expectClassCastException $ badCastExpr ())
    && assert (let badCastExpr x = eager $ jCastToString $ output $ intArray_new 0; in expectClassCastException $ badCastExpr ())
    && assert (let badCastExpr x = eager $ jCastToString $ output $ jArrayListArray_new 0; in expectClassCastException $ badCastExpr ())

    && assert (let goodCastExpr x = eager $ jCastToIntArray $ output $ intArray_new 0; in not $ expectClassCastException $ goodCastExpr ())
    && assert (let goodCastExpr x = eager $ jCastToIntArray $ output $ intArray_new 3; in not $ expectClassCastException $ goodCastExpr ())
    && assert (let badCastExpr x = eager $ jCastToIntArray $ output "a string"; in expectClassCastException $ badCastExpr ())
    && assert (let badCastExpr x = eager $ jCastToIntArray $ output 3.2; in expectClassCastException $ badCastExpr ())
    && assert (let badCastExpr x = eager $ jCastToObjectArray $ output $ intArray_new 0; in expectClassCastException $ badCastExpr ())
    && assert (let badCastExpr x = eager $ jCastToListArray $ output $ intArray_new 0; in expectClassCastException $ badCastExpr ())
    && assert (let goodCastExpr x = eager $ jCastToObjectArray $ output $ jStringArray_new 0; in not $ expectClassCastException $ goodCastExpr ())
    && assert (let badCastExpr x = eager $ jCastToListArray $ output $ jStringArray_new 0; in expectClassCastException $ badCastExpr ())
    && assert (let goodCastExpr x = eager $ jCastToObjectArray $ output $ jListArray_new 0; in not $ expectClassCastException $ goodCastExpr ())
    && assert (let goodCastExpr x = eager $ jCastToListArray $ output $ jListArray_new 0; in not $ expectClassCastException $ goodCastExpr ())
    && assert (let goodCastExpr x = eager $ jCastToObjectArray $ output $ jArrayListArray_new 0; in not $ expectClassCastException $ goodCastExpr ())
    && assert (let goodCastExpr x = eager $ jCastToListArray $ output $ jArrayListArray_new 0; in not $ expectClassCastException $ goodCastExpr ())
    ;

/////

// Regression test for a case alternative unpacking (), Prelude.Unit, and MyUnit

testCaseExprUnpackingUnitLikeDataCons =
    assert 
    (
        case Prelude.Unit of
        () ->
            let
                /**
                 * Some CALDoc comment inside the defining expr of a case alt unpacking ().
                 */
                true :: Boolean;
                (true, _) = (True, False);
            in
                true
            ;
    )
    &&
    assert
    (
        case Prelude.Unit of
        Prelude.Unit -> True;
        _ -> False;
    )
    &&
    assert
    (
        (
            case Prelude.Unit of
            Prelude.Unit -> 3.2;
            _ -> 6.4;
        )
        == 3.2
    )
    &&
    assert
    (
        case (\x -> ()) "foo" of
        Prelude.Unit -> True;
        _ -> False;
    )
    &&
    assert
    (
        (
            case (\x -> ()) "foo" of
            Prelude.Unit -> 3.2;
            _ -> 6.4;
        )
        == 3.2
    )
    &&
    assert
    (
        case MyUnit of
        MyUnit -> True;
        _ -> False;
    )
    &&
    assert
    (
        (
            case MyUnit of
            MyUnit -> 3.2;
            _ -> 6.4;
        )
        == 3.2
    )
    ;

/////

// Regression tests for foreign functions

/*
 * It is sometimes necessary to invoke a method/field from a class other than which it was defined.
 * For example, if package scope class A defines a static public field f, and public class B extends A, 
 * then B.f in a different package will not result in a compilation error but A.f will.
 * 
 * Or for example, if package scope class A defines a non-static public method m, and public class B extends A, 
 * then in a different package we cannot invoke m on an object of type B if:
 * - the invocation is done via reflection, or
 * - the reference is first cast to the method's declared type, in this case A, i.e. ((A)b).m()
 */

// Testing StringBuilder.charAt() imported as a CAL foreign function
data foreign unsafe import jvm "java.lang.StringBuilder" 
    private JStringBuilder deriving Inputable, Outputable, Eq;

foreign unsafe import jvm "constructor"
    private stringBuilder_new2 :: String -> JStringBuilder;    
    
foreign unsafe import jvm "method charAt"
    private stringBuilder_charAt :: JStringBuilder -> Int -> Char; 

testStringBuilderCharAt =
    assert ((stringBuilder_charAt (stringBuilder_new2 "abc") 1) == 'b')
    ;

// Testing via PublicSubClass
data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.M2.TestSupport$PublicSubClass"
    JPublicSubClass deriving Inputable, Outputable, Eq;

foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.M2.TestSupport$PublicSubClass.sixtyFour"
    jPublicSubClass_sixtyFour :: Int;

foreign unsafe import jvm "constructor"
    jPublicSubClass_new :: JPublicSubClass;

foreign unsafe import jvm "method fortyTwo"
    jPublicSubClass_fortyTwo :: JPublicSubClass -> Int;

foreign unsafe import jvm "field threePointTwo"
    jPublicSubClass_threePointTwo :: JPublicSubClass -> Double;

foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.M2.TestSupport$PublicSubClass.SIX_POINT_FOUR"
    jPublicSubClass_SIX_POINT_FOUR :: Double;

data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.M2.TestSupport$PublicInterface"
    JPublicInterface deriving Inputable, Outputable, Eq;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.M2.TestSupport$PublicSubClass"
    jPublicSubClass_new_as_JPublicInterface :: JPublicInterface;

foreign unsafe import jvm "method nine"
    jPublicInterface_nine :: JPublicInterface -> Int;

testMethodsInPackagedScopedBaseClassViaPublicSubClass =
    assert (jPublicSubClass_sixtyFour == 64)
    && assert (jPublicSubClass_fortyTwo jPublicSubClass_new == 42)
    && assert (jPublicSubClass_threePointTwo jPublicSubClass_new == 3.2)
    && assert (jPublicSubClass_SIX_POINT_FOUR == 6.4)
    && assert (jPublicInterface_nine jPublicSubClass_new_as_JPublicInterface == 9)
    ;

/////

// Regression test for a long data cons name in an algebraic type with a long name itself.
//
// The bug being regression tested involved a java constructor for an inner class having a name that is different from that of
// the class it was defined in. The problem stemmed from the generation of these names, where different methods in
// CALToJavaNames would be responsible for generating the base class name CAL_Bar and the full internal inner class name TYPE_Foo$CAL_Bar,
// *and using different name truncation logic.* The fix involved making sure that the truncation logic was shared by the different
// code paths.

// The error messages produced by javac:
//junit.framework.AssertionFailedError: Compilation of workspace failed: [Error: Failed to finalize Java code for: RuntimePerformance_Tests Detail: Error compiling generated source for module RuntimePerformance_Tests.
//D:\runtime\source\lecc_runtime\org\openquark\cal_Cal_Test_General_M2\TYPE_Context_Spaces___Dimensioned_Aggregation_Job.java:56: invalid method declaration; return type required
//        private CAL_Context_Spaces___Dimensioned_Aggregation_Job() {
//                        ^
//D:\runtime\source\lecc_runtime\org\openquark\cal_Cal_Test_General_M2\TYPE_Context_Spaces___Dimensioned_Aggregation_Job.java:59: invalid method declaration; return type required. Caused by: org.openquark.cal.internal.machine.CodeGenerationException]

data ContextSpaces_DimensionedAggregationJob =
    ContextSpaces_DimensionedAggregationJob
        dummy :: ()
    ;

testTruncationOfInnerClassNameCorrespondingToDataCons =
    assert (ContextSpaces_DimensionedAggregationJob () `seq` True);


/////
// Regression tests for loading a foreign class which the package name has less than 2 segments

/*
 * These are tests for loading foreign entity with package names with only one or no segment 
 * For example, "org_open_cal.OpenQuarkOneSegmentTestClass" and "OpenQuarkDefaultPackageTestClass" 
 * 
 * Originally this problem arise when the ClassLoader tries to parse the package name based on the period within the string.
 * 
 */

// Test 1: one segment
data foreign unsafe import jvm "org_openquark_cal.OpenQuarkOneSegmentTestClass" 
    private JOnePackageSegmentClass deriving Inputable, Outputable, Eq;

foreign unsafe import jvm "constructor org_openquark_cal.OpenQuarkOneSegmentTestClass"
    private constOneSegment :: Int -> JOnePackageSegmentClass;    
    
foreign unsafe import jvm "method getDummyValue"
    private methodDummyValue :: JOnePackageSegmentClass -> Int -> Int; 

foreign unsafe import jvm "static method org_openquark_cal.OpenQuarkOneSegmentTestClass.getValueFive" 
    private staticMethodGetFive :: Double;

foreign unsafe import jvm "field valueInt"
    private fieldValue :: JOnePackageSegmentClass -> Int;
    
foreign unsafe import jvm "instanceof org_openquark_cal.OpenQuarkOneSegmentTestClass"
    private isOpenQuarkOneSegmentTestClass :: JOnePackageSegmentClass -> Boolean;
    
testForeignFunctionWithOnePackageSegment =
    assert (methodDummyValue (constOneSegment 3) 6 == 6)
    && assert (fieldValue (constOneSegment 3) == 3)
    && assert (staticMethodGetFive == 5) 
    && assert (isOpenQuarkOneSegmentTestClass (constOneSegment 3))
    ;
   

// Test 2: zero segment (default package). These should all cause CAL compilation errors
//since default (or unnamed) packages cannot be imported or used by classes in named packages.

/*
data foreign unsafe import jvm "OpenQuarkDefaultPackageTestClass" 
    private JZeroPackageSegmentClass deriving Inputable, Outputable, Eq;
    
data foreign unsafe import jvm "OpenQuarkDefaultPackageTestClass[][]" 
    private JZeroPackageSegmentClassArray2 deriving Inputable, Outputable, Eq;
 
foreign unsafe import jvm "constructor OpenQuarkDefaultPackageTestClass"
    private constZeroSegment :: Int -> JZeroPackageSegmentClass;    
    
foreign unsafe import jvm "method getDummyValue"
    private methodDummyValue2 :: JZeroPackageSegmentClass -> Int -> Int; 

foreign unsafe import jvm "static method OpenQuarkDefaultPackageTestClass.getValueFive" 
    private staticGetFive2 :: Double;

foreign unsafe import jvm "field valueInt"
    private fieldValue2 :: JZeroPackageSegmentClass -> Int;
    
foreign unsafe import jvm "instanceof OpenQuarkDefaultPackageTestClass"
    private isOpenQuarkDefaultPackageTestClass :: JZeroPackageSegmentClass -> Boolean;
*/

/////

/**
 * @return true if the testing predicates in this module all run successfully.
 */
mainM2 :: Boolean;
public mainM2 =
    test1 
// TODO
// debugFunctionsTalk depends on the names of functions.  However, the renaming deep test
// renames all identifiers in M2 and then runs mainM2, at which point debugFunctionsTalk fails.
// If we want to keep running this test as part of mainM2, then it should be moved to some other 
// module to keep it from interfering with the deep tests.
//    //test of machine specific debugging functionality. Uses the CAF M1.allPrimes and relies on this being unevaluated upon entry,
//    //which is why this function occurs early
//    && assert (if Debug.machineType == Debug.MachineType_Lecc then debugFunctionsTalk else True)
    && M2.test2 
    && test3 
    && test4 
    && test5 
    && test6 
    && test7 
    && test8 
    && test9 
    && test10 
    && test11 
    && test12 
    && test13 
    && test14 
    && test15 
    && test16 
    && test17 
    && test18 
    && test19   
    && test20 
    && test21  
    && test22 
    && test23 
    && test24 
    && test25 
    && test26 
    && lazyTest
    && testUnicodeEscapeWithMoreThanOneU
    && M1.testOverloading  
    && M1.testForeignFunctions 
    && M2.badgemtest 
    && zap4 
    && ciTest1 
    && ciTest2 
    && ciTest3 
    && testZipperWith
    && "abc" ++ "defg" == "abcdefg"     
    && (List.take 10 M1.allPrimes ++ List.drop 10 (List.take 20 M1.allPrimes) == List.take 20 M1.allPrimes)
    && Nofib.testBenchmarks
    && testAlternativeImplementationsOfPreludeFunctions    
    && testBooleanCaseStatements
    && letVarTest    
    && testSeq
    && testSeq2
    && testStrictDataConstructors
    && testStrictFunctions
    && testSum
    && orListOldExamples
    && andListOldExamples
    && anyOldExamples
    && allOldExamples
    && testLength
    && (verificationError == 0)
    && ((ternaryTest [1.0, -1.0, 0.0, 2.0, -3.0]) == [-1.0, 0.0, -3.0])
    && testFindIndices
    && removeDuplicatesByOldExamples
    && testLiftTests
    && testLetters
    && testStuff
    && sum2 [1, 2, 3] == 6
    && sum2LiftedTraditionally [2, 3, 4, 5] == 14
    && sum2JohnssonLifted [2, 5, 10] == 17
    && testOutputListWithOld
    && testInputListWithOld
    && testExpressionTypeSignatures
    && caseTest
    && testLetVarInlining
    && testRecordOutIn
    && testListOutIn
    && testBackquotedOperators
    && testMyMaybeDerivedInstances
    && testMyTuple2DerivedInstances
    && testMyComposersEnumDerivedInstances
    && testMyUnitDerivedInstances
    && testMyBooleanDerivedInstances
    && testMyWrapDerivedInstances
    && testMyOrderingDerivedInstances
    && testMyBottomMiddleTopDerivedInstances
    && testMyABCDEFGDerivedInstances
    && testMyFooBarBazDerivedInstances
    && testMyListDerivedInstances
    && testMyTuple3DerivedInstances
    && testMyTuple3BDerivedInstances
    && testPreludeDerivedOrdInstances
    && testMyPhantomType1DerivedInstances
    && testMyPhantomType2DerivedInstances
    && M1.testTripleDerivedInstances
    && testMedEnumDerivedInstances
    && testOutThenInMyInt
    && testOutThenInMyLong 
    && testMyString
    && testComposeOpPrecedence
    && testComposeOpSemantics
    && testApplyOpAssociativity
    && testApplyOpPrecedence
    && testApplyOpSemantics
    && testDeepSeq
    && testDerivedEnumIndependence
    && testDerivedForeignInstances
    && testDerivedForeignPrimitiveInstances
    && testNamedDataConstructors
    && InliningTests.testMain 
    && testLiftedExpressions Prelude.True
    && testDerivedIntEnumInstances
    && testMarshallingJBoolean
    && testIntCase
    && testCharCase
    && gatherDoubleValuesExamples
    && gatherLeafValuesExamples
    && groupDataTest
    && testInternalValue
    && assert testLargArityLazyTailRecursion
    && assert nullStringTester
    && assert dcfsTest
    && assert testSortingBenchmarks
    && assert testSieveBasedPrimeGenerators
    && assert testSieveBasedPrimeGenerators2
    && assert (testStrictDCFieldSelection (DCFsTest (add 1)) == 3)
    && assert partialAppTest
    && assert testLetVarSeq
    && assert (testGMachine_Indirect_Chains == 10000)
    && assert exerciseGroupDataType
    && assert (lotsOfArgsTest == 60.0)
    && assert exceptionHandlerCodeGenTest
    && assert testForeignClassLiterals
    && assert testInstanceOfArrayTypes
    && assert testCaseExprUnpackingUnitLikeDataCons
    && assert testForeignCast
    && assert testStringBuilderCharAt
    && assert testMethodsInPackagedScopedBaseClassViaPublicSubClass
    && assert testTruncationOfInnerClassNameCorrespondingToDataCons
    && assert testForeignFunctionWithOnePackageSegment    
    || error "M2.mainM2 failed."
    ;
//please leave mainM2 last! It makes it easier to see what tests are hooked up.
