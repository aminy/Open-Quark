/*
 * Copyright (c) 2007 BUSINESS OBJECTS SOFTWARE LIMITED
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *  
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *  
 *     * Neither the name of Business Objects nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *  
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


/*
 * DerivedInstanceFunctionGenerator_Test_Support.cal
 * Creation date: Apr 25, 2006.
 * By: Joseph Wong
 */

/**
 * This module contains helper functions for testing the instances generated by the DerivedInstanceFunctionGenerator.
 * (These functions were originally placed in {@link module = "Cal.Test.General.M2"@}.)
 * 
 * @author Joseph Wong
 */
module Cal.Test.JUnitSupport.DerivedInstanceFunctionGenerator_Test_Support;

import Cal.Core.Prelude using
    typeClass = Bounded, Enum, Eq, IntEnum, Ord, Typeable;
    typeConstructor = Boolean, Int;
    dataConstructor = True, Just;
    function = 
        and, compare, enumToInt, error, fst, intToEnum, intToEnumChecked, max, maxBound, min, minBound, typeOf, upFrom, 
        upFromThen, upFromThenTo, upFromTo;
    ;

import Cal.Collections.List using
    function = foldLeftStrict, last, length, map, subscript, take, zip;
    ;

import Cal.Core.Debug using
    function = show;
    ;

/**
 * Tests the generated implementations of the class methods of {@link Eq@} and {@link Ord@}, by doing systematic comparisons between
 * all possible pairs constructed from the supplied list of values, which is sorted in accending order
 */
testOrdInstanceWithValuesInAccendingOrder :: (Ord a, Typeable a) => [a] -> Boolean;
public testOrdInstanceWithValuesInAccendingOrder accendingListOfValues =
    let
        /**
         * Makes a new list of tuples, with 0,1,2... being the first elements of the tuples,
         * and the values from the original list being the second elements
         */ 
        indexedList = zip (upFrom (0 :: Int)) accendingListOfValues;
        
        /** Tests the provided indexed element with each and every one of the indexed elements in the provided list */ 
        testWithIndexedElement :: (Ord c) => [(Int, c)] -> (Int, c) -> Boolean;
        testWithIndexedElement iList iElem1 =
            foldLeftStrict and True (map (testIndexedPair iElem1) iList);
        
        /**
         * Performs the test for the specified pair of indexed elements
         * - this makes sure that the result of the comparison of the indices ({@code iElem1.#1@} and {@code iElem2.#1@})
         *   matches that of the comparison of the corresponding {@link Ord@} instance values ({@code iElem1.#2@} and {@code iElem2.#2@})
         */
        testIndexedPair :: (Ord c) => (Int, c) -> (Int, c) -> Boolean;
        testIndexedPair !iElem1 !iElem2 =
            ((iElem1.#1 == iElem2.#1)                   == (iElem1.#2 == iElem2.#2))
            && ((iElem1.#1 != iElem2.#1)                == (iElem1.#2 != iElem2.#2))
            && ((iElem1.#1 < iElem2.#1)                 == (iElem1.#2 < iElem2.#2))
            && ((iElem1.#1 <= iElem2.#1)                == (iElem1.#2 <= iElem2.#2))
            && ((iElem1.#1 >= iElem2.#1)                == (iElem1.#2 >= iElem2.#2))
            && ((iElem1.#1 > iElem2.#1)                 == (iElem1.#2 > iElem2.#2))
            && ((compare iElem1.#1 iElem2.#1)           == (compare iElem1.#2 iElem2.#2))
            && ((max iElem1.#1 iElem2.#1) == iElem1.#1) == ((max iElem1.#2 iElem2.#2) == iElem1.#2)
            && ((min iElem1.#1 iElem2.#1) == iElem1.#1) == ((min iElem1.#2 iElem2.#2) == iElem1.#2);
    in
        // perform the test for all possible pairs of indexed elements (index1, value1), (index2, value2).
        foldLeftStrict and True (map (testWithIndexedElement indexedList) indexedList)
        || error ("DerivedInstanceFunctionGenerator_Test_Support.testOrdInstanceWithValuesInAccendingOrder failed for argument type " ++ show (typeOf accendingListOfValues));

/**
 * Tests the generated implementations of the class methods of {@link Bounded@} (for types that are also {@link Ord@} instances),
 * by doing systematic comparisons between the min and max bounds and the supplied list of values,
 * which is sorted in accending order, and whose first and last elements are the intended min and max bounds respectively
 */
testBoundedInstanceWithValuesInAccendingOrder :: (Bounded a, Ord a, Typeable a) => [a] -> Boolean;
public testBoundedInstanceWithValuesInAccendingOrder accendingListOfValues =
    let
        /**
         * Makes a new list of tuples, with 0,1,2... being the first elements of the tuples,
         * and the values from the original list being the second elements
         */ 
        indexedList = zip (upFrom (0 :: Int)) accendingListOfValues;
        
        /** Index of last element in list */
        lastIndex :: Int;
        lastIndex = (last indexedList).#1;
        
        /** Performs the test for the specified ndexed element */
        testIndexedElement :: (Bounded b, Ord b) => (Int, b) -> Boolean;
        testIndexedElement !iElem =
            (if iElem.#1 == 0 then iElem.#2 == minBound else iElem.#2 > minBound)
            && (if iElem.#1 == lastIndex then iElem.#2 == maxBound else iElem.#2 < maxBound)
            && iElem.#2 >= minBound
            && iElem.#2 <= maxBound;
    in
        // perform the test for all indexed elements (index, value).
        foldLeftStrict and True (map testIndexedElement indexedList)
        || error ("DerivedInstanceFunctionGenerator_Test_Support.testBoundedInstanceWithValuesInAccendingOrder failed for argument type " ++ show (typeOf accendingListOfValues));        

/**
 * Tests the generated implementations of the class methods of {@link Enum@} (for types that are also {@link Eq@} instances),
 * by doing systematic comparisons between the results obtained from the four class methods
 * ({@link upFrom@}, {@link upFromTo@}, {@link upFromThen@}, {@link upFromThenTo@}),
 * with the expected results (generated by using the instance functions of the {@code Enum Int@} instance).
 */
testEnumInstanceWithValuesInAccendingOrder :: (Enum a, Eq a, Typeable a) => [a] -> Boolean;
public testEnumInstanceWithValuesInAccendingOrder accendingListOfValues =
    let
        /**
         * Makes a new list of tuples, with 0,1,2... being the first elements of the tuples,
         * and the values from the original list being the second elements
         */ 
        indexedList = zip (upFrom (0 :: Int)) accendingListOfValues;
        
        /** The list of index values */
        indices :: [Int];
        indices = map fst indexedList;
        
        /** Index of last element in list */
        lastIndex :: Int;
        lastIndex = (last indexedList).#1;
        
        /** Number of elements */
        numElements :: Int;
        numElements = length indexedList;
        
        /** Translates an index into the corresponding value */
        indexToValue !x = subscript accendingListOfValues x;
        
        /** Tests {@link upFrom@} */
        testUpFrom !startIndexedElem =
            (upFrom startIndexedElem.#2) == map indexToValue (upFromTo startIndexedElem.#1 lastIndex);
        
        /** Tests {@link upFromTo@} */
        testUpFromTo !startIndexedElem !endIndexedElem =
            (upFromTo startIndexedElem.#2 endIndexedElem.#2) == map indexToValue (upFromTo startIndexedElem.#1 endIndexedElem.#1);
        
        /**
         * Tests {@link upFromThen@}
         * 
         * The {@link take@} call is for handling the case where {@code start==then@}, which results in an infinite list
         */
        testUpFromThen !startIndexedElem !thenIndexedElem =
            (take (2 * numElements) (upFromThen startIndexedElem.#2 thenIndexedElem.#2))
            == (take (2 * numElements) (map indexToValue (upFromThenTo startIndexedElem.#1 thenIndexedElem.#1 (if startIndexedElem.#1 <= thenIndexedElem.#1 then lastIndex else 0))));
        
        /**
         * Tests {@link upFromThenTo@}
         *
         * The {@link take@} call is for handling the case where {@code start==then@}, which results in an infinite list
         */
        testUpFromThenTo !startIndexedElem !thenIndexedElem !endIndexedElem =
            (take (2 * numElements) (upFromThenTo startIndexedElem.#2 thenIndexedElem.#2 endIndexedElem.#2))
            == (take (2 * numElements) (map indexToValue (upFromThenTo startIndexedElem.#1 thenIndexedElem.#1 endIndexedElem.#1)));
        
        // chain the tests up
        testThreeArgs = testUpFromThenTo;
        testTwoArgs !x !y =
            testUpFromTo x y
            && testUpFromThen x y
            && foldLeftStrict and True (map (testThreeArgs x y) indexedList);
        testIndexedElement !x =
            testUpFrom x
            && foldLeftStrict and True (map (testTwoArgs x) indexedList);
    in
        // perform the test for all indexed elements (index, value).
        foldLeftStrict and True (map testIndexedElement indexedList)
        || error ("DerivedInstanceFunctionGenerator_Test_Support.testEnumInstanceWithValuesInAccendingOrder failed for argument type " ++ show (typeOf accendingListOfValues));        

/**
 * Tests the generated implementations of the class methods of {@link IntEnum@} (for types that are also {@link Eq@} instances),
 * by doing systematic comparisons between the results obtained from the three class methods
 * ({@link intToEnum@}, {@link intToEnumChecked@}, {@link enumToInt@}),
 * with the expected results (generated by using the instance functions of the {@code IntEnum Int@} instance).
 */
testIntEnumInstanceWithValuesInAccendingOrder :: (Eq a, IntEnum a, Typeable a) => [a] -> Boolean;
public testIntEnumInstanceWithValuesInAccendingOrder accendingListOfValues =
  let
      /**
       * Makes a new list of tuples, with 0,1,2... being the first elements of the tuples,
       * and the values from the original list being the second elements
       */ 
      indexedList = zip (upFrom (0 :: Int)) accendingListOfValues;
      
      testIndexedElement :: (Eq b, IntEnum b) => (Int, b) -> Boolean;
      testIndexedElement !iElem =
          intToEnum (enumToInt iElem.#2) == iElem.#2
          && intToEnumChecked (enumToInt iElem.#2) == Just iElem.#2;
  in
      // perform the test for all indexed elements (index, value).
      foldLeftStrict and True (map testIndexedElement indexedList)
      || error ("DerivedInstanceFunctionGenerator_Test_Support.testIntEnumInstanceWithValuesInAccendingOrder failed for argument type " ++ show (typeOf accendingListOfValues));        
